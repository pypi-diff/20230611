# Comparing `tmp/scamp_extensions-0.3.3-py3-none-any.whl.zip` & `tmp/scamp_extensions-0.3.5.post1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,37 +1,40 @@
-Zip file size: 85531 bytes, number of entries: 35
--rw-rw-r--  2.0 unx     2474 b- defN 20-Aug-20 16:39 scamp_extensions/__init__.py
+Zip file size: 91234 bytes, number of entries: 38
+-rw-rw-r--  2.0 unx     2635 b- defN 23-Jun-09 20:32 scamp_extensions/__init__.py
 -rw-rw-r--  2.0 unx     1565 b- defN 20-Aug-20 16:39 scamp_extensions/composers/__init__.py
 -rw-rw-r--  2.0 unx    31336 b- defN 20-Aug-20 16:39 scamp_extensions/composers/barlicity.py
 -rw-rw-r--  2.0 unx     1586 b- defN 22-May-03 17:02 scamp_extensions/engraving/__init__.py
--rw-rw-r--  2.0 unx    19781 b- defN 22-May-03 17:09 scamp_extensions/engraving/note_graph.py
+-rw-rw-r--  2.0 unx    19781 b- defN 23-May-26 04:24 scamp_extensions/engraving/note_graph.py
 -rw-rw-r--  2.0 unx     1617 b- defN 20-Aug-20 16:39 scamp_extensions/interaction/__init__.py
 -rw-rw-r--  2.0 unx     6295 b- defN 20-Aug-20 16:39 scamp_extensions/interaction/key_plane.py
+-rw-rw-r--  2.0 unx     1553 b- defN 23-Jun-10 23:34 scamp_extensions/parsing/__init__.py
+-rw-rw-r--  2.0 unx     3803 b- defN 23-Apr-26 05:43 scamp_extensions/parsing/midi.py
 -rw-rw-r--  2.0 unx     1845 b- defN 20-Aug-20 16:39 scamp_extensions/pitch/__init__.py
--rw-rw-r--  2.0 unx    33470 b- defN 22-Apr-15 21:15 scamp_extensions/pitch/scale.py
+-rw-rw-r--  2.0 unx    33651 b- defN 23-May-26 18:40 scamp_extensions/pitch/scale.py
 -rw-rw-r--  2.0 unx     6756 b- defN 21-Jun-26 23:55 scamp_extensions/pitch/utilities.py
 -rw-rw-r--  2.0 unx     1798 b- defN 20-Nov-07 05:19 scamp_extensions/playback/__init__.py
--rw-rw-r--  2.0 unx    19099 b- defN 22-May-02 21:05 scamp_extensions/playback/multi_preset_instrument.py
+-rw-rw-r--  2.0 unx    19130 b- defN 23-May-26 18:40 scamp_extensions/playback/multi_preset_instrument.py
 -rw-rw-r--  2.0 unx     2051 b- defN 20-Aug-20 16:39 scamp_extensions/playback/supercollider/__init__.py
 -rw-rw-r--  2.0 unx      395 b- defN 19-Dec-31 22:47 scamp_extensions/playback/supercollider/scInit.scd
 -rw-rw-r--  2.0 unx     4457 b- defN 20-Aug-20 16:39 scamp_extensions/playback/supercollider/sc_lang.py
 -rw-rw-r--  2.0 unx     7008 b- defN 22-May-03 05:51 scamp_extensions/playback/supercollider/sc_playback_implementation.py
 -rw-rw-r--  2.0 unx       85 b- defN 19-Sep-30 06:58 scamp_extensions/playback/supercollider/scamp_sc_config.yaml
 -rw-rw-r--  2.0 unx     2540 b- defN 22-May-03 05:45 scamp_extensions/playback/supercollider/scampExtensions/ScampExtensions.sc
 -rw-rw-r--  2.0 unx     1737 b- defN 21-May-21 18:13 scamp_extensions/process/__init__.py
--rw-rw-r--  2.0 unx    46098 b- defN 21-Mar-17 18:49 scamp_extensions/process/_pykov.py
+-rw-rw-r--  2.0 unx    46062 b- defN 23-Apr-20 17:01 scamp_extensions/process/_pykov.py
 -rw-rw-r--  2.0 unx     3667 b- defN 21-May-23 17:23 scamp_extensions/process/generators.py
--rw-rw-r--  2.0 unx     4810 b- defN 22-May-04 05:41 scamp_extensions/process/l_systems.py
--rw-rw-r--  2.0 unx     9508 b- defN 21-Mar-17 18:36 scamp_extensions/process/markov.py
--rw-rw-r--  2.0 unx     1908 b- defN 20-Aug-20 16:39 scamp_extensions/rhythm/__init__.py
+-rw-rw-r--  2.0 unx     4810 b- defN 23-Jun-07 23:25 scamp_extensions/process/l_systems.py
+-rw-rw-r--  2.0 unx    10152 b- defN 23-Jun-10 23:33 scamp_extensions/process/markov.py
+-rw-rw-r--  2.0 unx     2105 b- defN 23-Jun-10 23:45 scamp_extensions/rhythm/__init__.py
+-rw-rw-r--  2.0 unx     6009 b- defN 23-Jun-10 23:46 scamp_extensions/rhythm/boolean_streamer.py
 -rw-rw-r--  2.0 unx     6671 b- defN 20-Aug-20 16:39 scamp_extensions/rhythm/indispensability.py
 -rw-rw-r--  2.0 unx     2170 b- defN 20-Aug-20 16:39 scamp_extensions/rhythm/metric_structure.py
--rw-rw-r--  2.0 unx     1965 b- defN 21-Mar-19 23:22 scamp_extensions/utilities/__init__.py
--rw-rw-r--  2.0 unx     5172 b- defN 21-Feb-26 18:08 scamp_extensions/utilities/math.py
+-rw-rw-r--  2.0 unx     2007 b- defN 23-Jun-01 19:29 scamp_extensions/utilities/__init__.py
+-rw-rw-r--  2.0 unx     7885 b- defN 23-Jun-10 22:56 scamp_extensions/utilities/math.py
 -rw-rw-r--  2.0 unx     7037 b- defN 22-Jan-16 17:47 scamp_extensions/utilities/sequences.py
 -rw-rw-r--  2.0 unx     9668 b- defN 22-Apr-21 18:41 scamp_extensions/utilities/time_varying_parameter.py
--rw-rw-r--  2.0 unx    35147 b- defN 22-May-05 03:01 scamp_extensions-0.3.3.dist-info/LICENSE
--rw-rw-r--  2.0 unx     1382 b- defN 22-May-05 03:01 scamp_extensions-0.3.3.dist-info/METADATA
--rw-rw-r--  2.0 unx       92 b- defN 22-May-05 03:01 scamp_extensions-0.3.3.dist-info/WHEEL
--rw-rw-r--  2.0 unx       17 b- defN 22-May-05 03:01 scamp_extensions-0.3.3.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     3414 b- defN 22-May-05 03:01 scamp_extensions-0.3.3.dist-info/RECORD
-35 files, 284621 bytes uncompressed, 79901 bytes compressed:  71.9%
+-rw-rw-r--  2.0 unx    35147 b- defN 23-Jun-10 23:55 scamp_extensions-0.3.5.post1.dist-info/LICENSE
+-rw-rw-r--  2.0 unx     1445 b- defN 23-Jun-10 23:55 scamp_extensions-0.3.5.post1.dist-info/METADATA
+-rw-rw-r--  2.0 unx       92 b- defN 23-Jun-10 23:55 scamp_extensions-0.3.5.post1.dist-info/WHEEL
+-rw-rw-r--  2.0 unx       17 b- defN 23-Jun-10 23:55 scamp_extensions-0.3.5.post1.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     3727 b- defN 23-Jun-10 23:55 scamp_extensions-0.3.5.post1.dist-info/RECORD
+38 files, 300295 bytes uncompressed, 85094 bytes compressed:  71.7%
```

## zipnote {}

```diff
@@ -15,14 +15,20 @@
 
 Filename: scamp_extensions/interaction/__init__.py
 Comment: 
 
 Filename: scamp_extensions/interaction/key_plane.py
 Comment: 
 
+Filename: scamp_extensions/parsing/__init__.py
+Comment: 
+
+Filename: scamp_extensions/parsing/midi.py
+Comment: 
+
 Filename: scamp_extensions/pitch/__init__.py
 Comment: 
 
 Filename: scamp_extensions/pitch/scale.py
 Comment: 
 
 Filename: scamp_extensions/pitch/utilities.py
@@ -66,14 +72,17 @@
 
 Filename: scamp_extensions/process/markov.py
 Comment: 
 
 Filename: scamp_extensions/rhythm/__init__.py
 Comment: 
 
+Filename: scamp_extensions/rhythm/boolean_streamer.py
+Comment: 
+
 Filename: scamp_extensions/rhythm/indispensability.py
 Comment: 
 
 Filename: scamp_extensions/rhythm/metric_structure.py
 Comment: 
 
 Filename: scamp_extensions/utilities/__init__.py
@@ -84,23 +93,23 @@
 
 Filename: scamp_extensions/utilities/sequences.py
 Comment: 
 
 Filename: scamp_extensions/utilities/time_varying_parameter.py
 Comment: 
 
-Filename: scamp_extensions-0.3.3.dist-info/LICENSE
+Filename: scamp_extensions-0.3.5.post1.dist-info/LICENSE
 Comment: 
 
-Filename: scamp_extensions-0.3.3.dist-info/METADATA
+Filename: scamp_extensions-0.3.5.post1.dist-info/METADATA
 Comment: 
 
-Filename: scamp_extensions-0.3.3.dist-info/WHEEL
+Filename: scamp_extensions-0.3.5.post1.dist-info/WHEEL
 Comment: 
 
-Filename: scamp_extensions-0.3.3.dist-info/top_level.txt
+Filename: scamp_extensions-0.3.5.post1.dist-info/top_level.txt
 Comment: 
 
-Filename: scamp_extensions-0.3.3.dist-info/RECORD
+Filename: scamp_extensions-0.3.5.post1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## scamp_extensions/__init__.py

```diff
@@ -21,8 +21,13 @@
 builds upon SCAMP but is outside of the scope of the main framework.
 
 The package is split into several subpackages according to the nature of the content: The pitch subpackage contains
 tools for manipulating pitches, such as scales and intervals; the rhythm subpackage contains tools for creating and
 interacting with rhythms and meters; the interaction subpackage contains utilities for human interface devices and
 other live interactions; the supercollider subpackage contains utilities for embedding supercollider code within
 SCAMP scripts; and the composers subpackage contains composer-specific tools and theoretical devices.
-"""
+"""
+
+import importlib.metadata
+
+__version__ = importlib.metadata.version('scamp_extensions')
+__author__ = importlib.metadata.metadata('scamp_extensions')['Author']
```

## scamp_extensions/engraving/note_graph.py

```diff
@@ -18,15 +18,15 @@
 #                                                                                                #
 #  You should have received a copy of the GNU General Public License along with this program.    #
 #  If not, see <http://www.gnu.org/licenses/>.                                                   #
 #  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  #
 from numbers import Real
 from typing import Tuple, Callable, Sequence
 from scamp import EnvelopeSegment, Performance, PerformancePart
-import drawSvg
+import drawsvg
 
 
 from scamp import Envelope
 
 # -------------------------------------------------- Color/gradients --------------------------------------------------
 
 _default_cm_envelope_red = Envelope.from_levels((0, 0, 78, 151, 211, 250, 255, 255, 255))
@@ -56,15 +56,15 @@
     while gaps_too_big:
         gaps_too_big = False
         for segment in envelope.segments:
             if abs(segment.end_level - segment.start_level) > 0.1:
                 envelope.insert_interpolated((segment.start_time + segment.end_time) / 2)
                 gaps_too_big = True
 
-    grad = drawSvg.LinearGradient(start_x, 0, end_x, 0)
+    grad = drawsvg.LinearGradient(start_x, 0, end_x, 0)
     for segment in envelope.segments:
         grad.addStop(segment.start_time, rgb_to_hex(color_map(segment.start_level)))
     grad.addStop(1, rgb_to_hex(color_map(envelope.end_level())))
     return grad
 
 
 def get_fill(parameter, start_x, end_x, color_map=default_color_map, value_range=None):
@@ -117,76 +117,76 @@
                  p3[1] - end_unit_normal_vector[1] * width_segment.value_at(width_segment.start_time + width_segment.duration * 2 / 3)
     end_a = p4[0] + end_unit_normal_vector[0] * width_segment.end_level,\
             p4[1] + end_unit_normal_vector[1] * width_segment.end_level
     end_b = p4[0] - end_unit_normal_vector[0] * width_segment.end_level,\
             p4[1] - end_unit_normal_vector[1] * width_segment.end_level
 
     return [
-        drawSvg.Path(fill=fill, close=True, stroke='none').
+        drawsvg.Path(fill=fill, close=True, stroke='none').
             M(*start_a).C(*control_1a, *control_2a, *end_a).L(*end_b).
             C(*control_2b, *control_1b, *start_b).L(*start_a),
-        drawSvg.Path(stroke=outline_color, stroke_width=outline_width, fill='none').
+        drawsvg.Path(stroke=outline_color, stroke_width=outline_width, fill='none').
             M(*start_a).C(*control_1a, *control_2a, *end_a),
-        drawSvg.Path(stroke=outline_color, stroke_width=outline_width, fill='none').
+        drawsvg.Path(stroke=outline_color, stroke_width=outline_width, fill='none').
             M(*start_b).C(*control_1b, *control_2b, *end_b),
     ]
 
 
-def _draw_note_raw(draw: drawSvg.Drawing, height_envelope: Envelope, width_envelope: Envelope, fill,
+def _draw_note_raw(draw: drawsvg.Drawing, height_envelope: Envelope, width_envelope: Envelope, fill,
                    outline_width, outline_color):
     """
     Draws a note shape, based on envelopes in drawing coordinates.
 
-    :param draw: the drawSvg.Drawing used
+    :param draw: the drawsvg.Drawing used
     :param height_envelope: an envelope representing the curve itself, normalized to drawing coordinates
     :param width_envelope:  an envelope representing the curve width, normalized to drawing coordinates
     :param fill: the color or gradient to use
     :param outline_width: width of the stroke outline of the note
     :param outline_color: color of the outline of the note
     """
     key_points = set(height_envelope.times).union(set(width_envelope.times))
     for t in key_points:
         height_envelope.insert_interpolated(t)
         width_envelope.insert_interpolated(t)
 
     outlines = []
     fill_chunks = []
 
-    fill_chunks.append(drawSvg.Circle(height_envelope.end_time(), height_envelope.end_level(),
+    fill_chunks.append(drawsvg.Circle(height_envelope.end_time(), height_envelope.end_level(),
                                       width_envelope.end_level(), fill=fill, stroke="none"))
-    outlines.append(drawSvg.Circle(height_envelope.end_time(), height_envelope.end_level(),
+    outlines.append(drawsvg.Circle(height_envelope.end_time(), height_envelope.end_level(),
                                    width_envelope.end_level(), fill="none", stroke=outline_color,
                                    stroke_width=outline_width))
     for height_segment, width_segment in zip(height_envelope.segments, width_envelope.segments):
-        fill_chunks.append(drawSvg.Circle(height_segment.start_time, height_segment.start_level,
+        fill_chunks.append(drawsvg.Circle(height_segment.start_time, height_segment.start_level,
                                           width_segment.start_level, fill=fill, stroke="none"))
-        outlines.append(drawSvg.Circle(height_segment.start_time, height_segment.start_level, width_segment.start_level,
+        outlines.append(drawsvg.Circle(height_segment.start_time, height_segment.start_level, width_segment.start_level,
                                        fill='none', stroke=outline_color, stroke_width=outline_width))
         fill_chunk, *segment_outlines = _get_segment_raw(height_segment, width_segment, fill,
                                                          outline_width, outline_color)
         fill_chunks.append(fill_chunk)
         outlines.extend(segment_outlines)
     draw.extend(outlines)
     draw.extend(fill_chunks)
 
 
-def _draw_note_attack_only(draw: drawSvg.Drawing, height_envelope: Envelope, width_envelope: Envelope, fill,
+def _draw_note_attack_only(draw: drawsvg.Drawing, height_envelope: Envelope, width_envelope: Envelope, fill,
                            outline_width, outline_color):
     """
     Draws just the attack of a note shape, based on envelopes in drawing coordinates.
 
-    :param draw: the drawSvg.Drawing used
+    :param draw: the drawsvg.Drawing used
     :param height_envelope: an envelope representing the curve itself, normalized to drawing coordinates
     :param width_envelope:  an envelope representing the curve width, normalized to drawing coordinates
     :param fill: the color or gradient to use
     :param outline_width: width of the stroke outline of the note
     :param outline_color: color of the outline of the note
     """
     draw.append(
-        drawSvg.Circle(height_envelope.start_time(), height_envelope.start_level(),
+        drawsvg.Circle(height_envelope.start_time(), height_envelope.start_level(),
                        width_envelope.start_level(), fill=fill, stroke=outline_color, stroke_width=outline_width)
     )
 
 
 class PartNoteGraph:
 
     """
@@ -248,15 +248,15 @@
 
     def _get_part_pitch_range(self):
         return min(note.pitch.min_level() if isinstance(note.pitch, Envelope) else note.pitch
                    for note in self.performance_part.get_note_iterator()),\
                max(note.pitch.max_level() if isinstance(note.pitch, Envelope) else note.pitch
                    for note in self.performance_part.get_note_iterator())
 
-    def render(self, drawing: drawSvg.Drawing, bottom_left: Tuple[Real, Real], dimensions: Tuple[Real, Real]):
+    def render(self, drawing: drawsvg.Drawing, bottom_left: Tuple[Real, Real], dimensions: Tuple[Real, Real]):
         for note in self.performance_part.get_note_iterator():
             height = note.pitch if self.height_parameter == "pitch" \
                 else note.volume if self.height_parameter == "volume" \
                 else note.properties["param_" + self.height_parameter] \
                 if ("param_" + self.height_parameter) in note.properties else 0
             height_envelope = height.duplicate() if isinstance(height, Envelope) else Envelope((height, height), (note.length_sum(),))
             height_envelope.remove_segments_after(note.length_sum())
@@ -294,27 +294,27 @@
                 _draw_note_attack_only(drawing, height_envelope, width_envelope, note_fill, self.outline_width,
                                        self.outline_color)
             else:
                 _draw_note_raw(drawing, height_envelope, width_envelope, note_fill, self.outline_width,
                                self.outline_color)
         self._render_guide_lines(drawing, bottom_left, dimensions)
 
-    def _render_guide_lines(self, drawing: drawSvg.Drawing, bottom_left: Tuple[Real, Real],
+    def _render_guide_lines(self, drawing: drawsvg.Drawing, bottom_left: Tuple[Real, Real],
                             dimensions: Tuple[Real, Real]):
         for value in self.guide_lines:
             line_height = bottom_left[1] + (value - self.height_parameter_range[0]) / \
                           (self.height_parameter_range[1] - self.height_parameter_range[0]) * dimensions[1]
             drawing.append(
-                drawSvg.Line(
+                drawsvg.Line(
                     bottom_left[0], line_height, bottom_left[0] + dimensions[0], line_height,
                     stroke_width=self.guide_line_width, stroke=self.guide_line_color
                 )
             )
 
     def render_to_file(self, file_path, dimensions, bg_color=None, h_padding=100, v_padding=100, pixel_scale=2):
         unpadded_dimensions = dimensions[0] - 2 * h_padding, dimensions[1] - 2 * v_padding
-        d = drawSvg.Drawing(*dimensions, displayInline=False)
+        d = drawsvg.Drawing(*dimensions, displayInline=False)
         if bg_color is not None:
-            d.append(drawSvg.Rectangle(0, 0, *dimensions, fill=bg_color))
+            d.append(drawsvg.Rectangle(0, 0, *dimensions, fill=bg_color))
         self.render(d, (h_padding, v_padding), unpadded_dimensions)
         d.setPixelScale(pixel_scale)
         d.saveSvg(file_path)
```

## scamp_extensions/pitch/scale.py

```diff
@@ -16,18 +16,19 @@
 #  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;     #
 #  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.     #
 #  See the GNU General Public License for more details.                                          #
 #                                                                                                #
 #  You should have received a copy of the GNU General Public License along with this program.    #
 #  If not, see <http://www.gnu.org/licenses/>.                                                   #
 #  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  #
+
+from __future__ import annotations
 import itertools
 from fractions import Fraction
 from typing import Sequence
-
 from expenvelope.envelope import Envelope, SavesToJSON
 from scamp_extensions.utilities.sequences import multi_option_method
 from .utilities import ratio_to_cents
 import math
 from numbers import Real
 import logging
 from copy import deepcopy
@@ -160,15 +161,15 @@
 
     def to_half_steps(self) -> Sequence[float]:
         """
         Returns a list of floats representing the number of half steps from the starting pitch for each scale degree.
         """
         return [interval.to_half_steps() for interval in self.intervals]
 
-    def rotate(self, steps: int, in_place: bool = True) -> 'ScaleType':
+    def rotate(self, steps: int, in_place: bool = True) -> ScaleType:
         """
         Rotates the step sizes of this scale type in the manner of a modal shift. E.g. going from ionian to lydian
         would be a rotation of 3.
 
         :param steps: the number of steps to shift the starting point of the scale up or down by. Can be negative.
         :param in_place: whether to modify this ScaleType in place, or to return a modified copy.
         :return: the modified ScaleType
@@ -192,123 +193,123 @@
 
     @classmethod
     def chromatic(cls):
         """Returns a 12-tone equal tempered chromatic ScaleType."""
         return cls(*ScaleType._standard_equal_tempered_patterns["chromatic"])
 
     @classmethod
-    def diatonic(cls, modal_shift: int = 0) -> 'ScaleType':
+    def diatonic(cls, modal_shift: int = 0) -> ScaleType:
         """
         Returns a diatonic ScaleType with the specified modal shift.
 
         :param modal_shift: how many steps up or down to shift the starting note of the scale. 0 returns ionian,
             1 returns dorian, 2 returns phrygian, etc. (There are also convenience methods for creating these
             modal scale types.)
         """
         return cls(*ScaleType._standard_equal_tempered_patterns["diatonic"]).rotate(modal_shift)
 
     @classmethod
-    def major(cls, modal_shift: int = 0) -> 'ScaleType':
+    def major(cls, modal_shift: int = 0) -> ScaleType:
         """Alias of :func:`ScaleType.diatonic`."""
         return cls.diatonic(modal_shift)
 
     @classmethod
-    def ionian(cls, modal_shift: int = 0) -> 'ScaleType':
+    def ionian(cls, modal_shift: int = 0) -> ScaleType:
         """Alias of :func:`ScaleType.diatonic`."""
         return cls.diatonic(modal_shift)
 
     @classmethod
-    def dorian(cls) -> 'ScaleType':
+    def dorian(cls) -> ScaleType:
         """Convenience method for creating a dorian ScaleType."""
         return cls.diatonic(1)
 
     @classmethod
-    def phrygian(cls) -> 'ScaleType':
+    def phrygian(cls) -> ScaleType:
         """Convenience method for creating a phrygian ScaleType."""
         return cls.diatonic(2)
 
     @classmethod
-    def lydian(cls) -> 'ScaleType':
+    def lydian(cls) -> ScaleType:
         """Convenience method for creating a lydian ScaleType."""
         return cls.diatonic(3)
 
     @classmethod
-    def mixolydian(cls) -> 'ScaleType':
+    def mixolydian(cls) -> ScaleType:
         """Convenience method for creating a myxolydian ScaleType."""
         return cls.diatonic(4)
 
     @classmethod
-    def aeolian(cls) -> 'ScaleType':
+    def aeolian(cls) -> ScaleType:
         """Convenience method for creating an aeolian ScaleType."""
         return cls.diatonic(5)
 
     @classmethod
-    def natural_minor(cls) -> 'ScaleType':
+    def natural_minor(cls) -> ScaleType:
         """Alias of :func:`ScaleType.aeolian`."""
         return cls.aeolian()
 
     @classmethod
-    def locrian(cls) -> 'ScaleType':
+    def locrian(cls) -> ScaleType:
         """Convenience method for creating an locrian ScaleType."""
         return cls.diatonic(6)
 
     @classmethod
-    def harmonic_minor(cls, modal_shift: int = 0) -> 'ScaleType':
+    def harmonic_minor(cls, modal_shift: int = 0) -> ScaleType:
         """
         Returns a harmonic minor ScaleType with the specified modal shift.
 
         :param modal_shift: How many steps up or down to shift the starting note of the scale. The default value of
             zero creates the standard harmonic minor scale.
         """
         return cls(*ScaleType._standard_equal_tempered_patterns["harmonic minor"]).rotate(modal_shift)
 
     @classmethod
-    def melodic_minor(cls, modal_shift: int = 0) -> 'ScaleType':
+    def melodic_minor(cls, modal_shift: int = 0) -> ScaleType:
         """
         Returns a melodic minor ScaleType with the specified modal shift.
 
         :param modal_shift: How many steps up or down to shift the starting note of the scale. The default value of
             zero creates the standard melodic minor scale.
         """
         return cls(*ScaleType._standard_equal_tempered_patterns["melodic minor"]).rotate(modal_shift)
 
     @classmethod
-    def whole_tone(cls) -> 'ScaleType':
+    def whole_tone(cls) -> ScaleType:
         """Convenience method for creating a whole tone ScaleType."""
         return cls(*ScaleType._standard_equal_tempered_patterns["whole tone"])
 
     @classmethod
-    def octatonic(cls, whole_step_first: bool = True) -> 'ScaleType':
+    def octatonic(cls, whole_step_first: bool = True) -> ScaleType:
         """
         Convenience method for creating an octatonic (alternating whole and half steps) ScaleType
 
         :param whole_step_first: whether to start with a whole step or a half step.
         """
         if whole_step_first:
             return cls(*ScaleType._standard_equal_tempered_patterns["octatonic"])
         else:
             return cls(*ScaleType._standard_equal_tempered_patterns["octatonic"]).rotate(1)
 
     @classmethod
-    def pentatonic(cls, modal_shift: int = 0) -> 'ScaleType':
+    def pentatonic(cls, modal_shift: int = 0) -> ScaleType:
         """
         Returns a pentatonic ScaleType with the specified modal shift.
 
         :param modal_shift: how many steps up or down to shift the starting note of the scale. A shift of 3 creates
             a minor pentatonic scale.
         """
         return cls(*ScaleType._standard_equal_tempered_patterns["pentatonic"]).rotate(modal_shift)
 
     @classmethod
-    def pentatonic_minor(cls) -> 'ScaleType':
+    def pentatonic_minor(cls) -> ScaleType:
         """Convenience method for creating a pentatonic minor ScaleType."""
         return cls.pentatonic(4)
 
     @classmethod
-    def blues(cls) -> 'ScaleType':
+    def blues(cls) -> ScaleType:
         """Convenience method for creating a blues ScaleType."""
         return cls(*ScaleType._standard_equal_tempered_patterns["blues"])
 
     # ------------------------------------- Loading / Saving ---------------------------------------
 
     def save_to_scala(self, file_path: str, description: str = "Mystery scale saved using SCAMP") -> None:
         """
@@ -325,15 +326,15 @@
                  str(len(self.intervals)),
                  "!"]
         lines.extend(interval.to_scala_string() for interval in self.intervals)
         with open(file_path, "w") as scala_file:
             scala_file.write("\n".join(lines))
 
     @classmethod
-    def load_from_scala(cls, file_path: str) -> 'ScaleType':
+    def load_from_scala(cls, file_path: str) -> ScaleType:
         """
         Loads a ScaleType from a scala file.
 
         :param file_path: file path of a correctly formatted scala file
         """
         pitch_entries = []
         with open(file_path, "r") as scala_file:
@@ -420,15 +421,15 @@
         self._seed_pitches = (self._start_pitch,) + tuple(self._start_pitch + x for x in self.scale_type.to_half_steps())
         self._envelope = Envelope.from_points(*zip(range(len(self._seed_pitches)), self._seed_pitches))
         self._inverse_envelope = Envelope.from_points(*zip(self._seed_pitches, range(len(self._seed_pitches))))
         self.num_steps = len(self._seed_pitches) - 1
         self.width = self._seed_pitches[-1] - self._seed_pitches[0] if self._cycle else None
 
     @classmethod
-    def from_pitches(cls, seed_pitches: Sequence[Real], cycle: bool = True) -> 'Scale':
+    def from_pitches(cls, seed_pitches: Sequence[Real], cycle: bool = True) -> Scale:
         """
         Constructs a Scale from a list of seed pitches, given as floating-point MIDI pitch values. For instance, a
         C major scale could be constructed by calling Scale.from_pitches([60, 62, 64, 65, 67, 69, 71, 72]). Note that
         the upper C needs to be specified, since it is not assumed that scales will be octave repeating, and the repeat
         interval is given by the distance between the first and last seed pitch. Also note that this particular C major
         scale would place scale degree 0 at middle C, whereas Scale.from_pitches([48, 50, 52, 53, 55, 57, 59, 60]) would
         place it an octave lower.
@@ -436,26 +437,26 @@
         :param seed_pitches: a list of floating-point MIDI pitch values.
         :param cycle: Whether or not to cycle the scale, creating multiple "octaves" (or perhaps not octaves if the
             scale repeats at a different interval.
         """
         return cls(ScaleType(*(100. * (x - seed_pitches[0]) for x in seed_pitches[1:])), seed_pitches[0], cycle=cycle)
 
     @classmethod
-    def from_scala_file(cls, file_path: str, start_pitch: Real, cycle: bool = True) -> 'Scale':
+    def from_scala_file(cls, file_path: str, start_pitch: Real, cycle: bool = True) -> Scale:
         """
         Constructs a Scale from a scala file located at the given file path, and a start pitch.
 
         :param file_path: path of the scala file to load
         :param start_pitch: the pitch to define as scale degree 0
         :param cycle: whether or not this scale is treated as cyclic
         """
         return cls(ScaleType.load_from_scala(file_path), start_pitch, cycle=cycle)
 
     @classmethod
-    def from_start_pitch_and_cent_or_ratio_intervals(cls, start_pitch: Real, intervals, cycle: bool = True) -> 'Scale':
+    def from_start_pitch_and_cent_or_ratio_intervals(cls, start_pitch: Real, intervals, cycle: bool = True) -> Scale:
         """
         Creates a scale from a start pitch and a sequence of intervals (either cents or frequency ratios).
 
         :param start_pitch: The pitch to start on
         :param intervals: a sequence of intervals above the start pitch. These can be either :class:`PitchInterval`
             objects or anything that can be interpreted by :func:`PitchInterval.parse`.
         :param cycle: whether or not this scale is treated as cyclic. See explanation in :func:`Scale.from_pitches`
@@ -507,191 +508,191 @@
     @multi_option_method
     def ceil(self, pitch: Real) -> float:
         """Returns the nearest note of the scale above or equal to the given pitch."""
         return self.degree_to_pitch(math.ceil(self.pitch_to_degree(pitch)))
 
     # ------------------------------------- Transformations ---------------------------------------
 
-    def transpose(self, half_steps: float) -> 'Scale':
+    def transpose(self, half_steps: float) -> Scale:
         """
         Transposes this scale (in place) by the given number of half steps.
 
         :param half_steps: number of half steps to transpose up or down by
         :return: self, for chaining purposes
         """
         self._start_pitch = self._start_pitch + half_steps
         self._initialize_instance_vars()
         return self
         
-    def transposed(self, half_steps: float) -> 'Scale':
+    def transposed(self, half_steps: float) -> Scale:
         """
         Same as :func:`Scale.transpose`, except that it returns a transposed copy, leaving this scale unaltered.
         """
         copy = self.duplicate()
         copy.transpose(half_steps)
         return copy
 
     # ------------------------------------- Class Methods ---------------------------------------
 
     @classmethod
-    def chromatic(cls, start_pitch: Real = 60, cycle: bool = True) -> 'Scale':
+    def chromatic(cls, start_pitch: Real = 60, cycle: bool = True) -> Scale:
         """
         Returns a 12-tone equal tempered chromatic scale starting on the specified pitch.
 
         :param start_pitch: the pitch this scale starts from (doesn't affect the scale in this case, but affects
             where we count scale degrees from).
         :param cycle: whether or not this scale repeats after an octave or is constrained to a single octave.
         """
         return cls(ScaleType.chromatic(), start_pitch, cycle=cycle)
 
     @classmethod
-    def diatonic(cls, start_pitch: Real, modal_shift: int = 0, cycle: bool = True) -> 'Scale':
+    def diatonic(cls, start_pitch: Real, modal_shift: int = 0, cycle: bool = True) -> Scale:
         """
         Returns a diatonic scale starting on the specified pitch, and with the specified modal shift.
 
         :param start_pitch: the pitch this scale starts from
         :param modal_shift: how many steps up or down to shift the scale's interval relationships. 0 is ionian, 1 is
             dorian, 2 is phrygian, etc. (There are also convenience methods for creating these modal scales.)
         :param cycle: whether or not this scale repeats after an octave or is constrained to a single octave.
         """
         return cls(ScaleType.diatonic(modal_shift), start_pitch, cycle=cycle)
 
     @classmethod
-    def major(cls, start_pitch: Real, modal_shift: int = 0, cycle: bool = True) -> 'Scale':
+    def major(cls, start_pitch: Real, modal_shift: int = 0, cycle: bool = True) -> Scale:
         """Alias of :func:`Scale.diatonic`."""
         return cls.diatonic(start_pitch, modal_shift, cycle)
 
     @classmethod
-    def ionian(cls, start_pitch: Real, modal_shift: int = 0, cycle: bool = True) -> 'Scale':
+    def ionian(cls, start_pitch: Real, modal_shift: int = 0, cycle: bool = True) -> Scale:
         """Alias of :func:`Scale.diatonic`."""
         return cls.diatonic(start_pitch, modal_shift, cycle)
 
     @classmethod
-    def dorian(cls, start_pitch: Real, cycle: bool = True) -> 'Scale':
+    def dorian(cls, start_pitch: Real, cycle: bool = True) -> Scale:
         """
         Convenience method for creating a dorian scale with the given start pitch. (Same as :func:`Scale.diatonic` with
         a modal shift of 1.)
         """
         return cls(ScaleType.dorian(), start_pitch, cycle=cycle)
 
     @classmethod
-    def phrygian(cls, start_pitch: Real, cycle: bool = True) -> 'Scale':
+    def phrygian(cls, start_pitch: Real, cycle: bool = True) -> Scale:
         """
         Convenience method for creating a phrygian scale with the given start pitch. (Same as :func:`Scale.diatonic`
         with a modal shift of 2.)
         """
         return cls(ScaleType.phrygian(), start_pitch, cycle=cycle)
 
     @classmethod
-    def lydian(cls, start_pitch: Real, cycle: bool = True) -> 'Scale':
+    def lydian(cls, start_pitch: Real, cycle: bool = True) -> Scale:
         """
         Convenience method for creating a lydian scale with the given start pitch. (Same as :func:`Scale.diatonic`
         with a modal shift of 3.)
         """
         return cls(ScaleType.lydian(), start_pitch, cycle=cycle)
 
     @classmethod
-    def mixolydian(cls, start_pitch: Real, cycle: bool = True) -> 'Scale':
+    def mixolydian(cls, start_pitch: Real, cycle: bool = True) -> Scale:
         """
         Convenience method for creating a mixolydian scale with the given start pitch. (Same as :func:`Scale.diatonic`
         with a modal shift of 4.)
         """
         return cls(ScaleType. mixolydian(), start_pitch, cycle=cycle)
 
     @classmethod
-    def aeolian(cls, start_pitch: Real, cycle: bool = True) -> 'Scale':
+    def aeolian(cls, start_pitch: Real, cycle: bool = True) -> Scale:
         """
         Convenience method for creating a aeolian scale with the given start pitch. (Same as :func:`Scale.diatonic`
         with a modal shift of 5.)
         """
         return cls(ScaleType.aeolian(), start_pitch, cycle=cycle)
 
     @classmethod
-    def natural_minor(cls, start_pitch: Real, cycle: bool = True) -> 'Scale':
+    def natural_minor(cls, start_pitch: Real, cycle: bool = True) -> Scale:
         """Alias of :func:`Scale.aeolian`."""
         return cls.aeolian(start_pitch, cycle)
 
     @classmethod
-    def locrian(cls, start_pitch: Real, cycle: bool = True) -> 'Scale':
+    def locrian(cls, start_pitch: Real, cycle: bool = True) -> Scale:
         """
         Convenience method for creating a locrian scale with the given start pitch. (Same as :func:`Scale.diatonic`
         with a modal shift of 6.)
         """
         return cls(ScaleType.locrian(), start_pitch, cycle=cycle)
 
     @classmethod
-    def harmonic_minor(cls, start_pitch: Real, modal_shift: int = 0, cycle: bool = True) -> 'Scale':
+    def harmonic_minor(cls, start_pitch: Real, modal_shift: int = 0, cycle: bool = True) -> Scale:
         """
         Returns a harmonic minor scale starting on the specified pitch, and with the specified modal shift.
 
         :param start_pitch: the pitch this scale starts from
         :param modal_shift: How many steps up or down to shift the scale's interval relationships. To get a regular
             harmonic minor scale, simply use the default modal shift of 0.
         :param cycle: whether or not this scale repeats after an octave or is constrained to a single octave.
         """
         return cls(ScaleType.harmonic_minor(modal_shift), start_pitch, cycle=cycle)
 
     @classmethod
-    def melodic_minor(cls, start_pitch: Real, modal_shift: int = 0, cycle: bool = True) -> 'Scale':
+    def melodic_minor(cls, start_pitch: Real, modal_shift: int = 0, cycle: bool = True) -> Scale:
         """
         Returns a melodic minor scale starting on the specified pitch, and with the specified modal shift.
 
         :param start_pitch: the pitch this scale starts from
         :param modal_shift: How many steps up or down to shift the scale's interval relationships. To get a regular
             melodic minor scale, simply use the default modal shift of 0. A so-called acoustic scale (major sharp-4,
             flat-7) can be produced with a modal shift of 4.
         :param cycle: whether or not this scale repeats after an octave or is constrained to a single octave.
         """
         return cls(ScaleType.melodic_minor(modal_shift), start_pitch, cycle=cycle)
 
     @classmethod
-    def whole_tone(cls, start_pitch: Real, cycle: bool = True) -> 'Scale':
+    def whole_tone(cls, start_pitch: Real, cycle: bool = True) -> Scale:
         """
         Returns a whole tone scale with the given start pitch.
 
         :param start_pitch: the pitch this scale starts from
         :param cycle: whether or not this scale repeats after an octave or is constrained to a single octave.
         """
         return cls(ScaleType.whole_tone(), start_pitch, cycle=cycle)
 
     @classmethod
-    def octatonic(cls, start_pitch: Real, cycle: bool = True, whole_step_first: bool = True) -> 'Scale':
+    def octatonic(cls, start_pitch: Real, cycle: bool = True, whole_step_first: bool = True) -> Scale:
         """
         Returns an octatonic scale with the given start pitch.
 
         :param start_pitch: the pitch this scale starts from
         :param cycle: whether or not this scale repeats after an octave or is constrained to a single octave.
         :param whole_step_first: whether this is a whole-half or half-whole octatonic scale.
         """
         return cls(ScaleType.octatonic(whole_step_first=whole_step_first), start_pitch, cycle=cycle)
 
     @classmethod
-    def pentatonic(cls, start_pitch: Real, modal_shift: int = 0, cycle: bool = True) -> 'Scale':
+    def pentatonic(cls, start_pitch: Real, modal_shift: int = 0, cycle: bool = True) -> Scale:
         """
         Returns a pentatonic scale starting on the specified pitch, and with the specified modal shift.
 
         :param start_pitch: the pitch this scale starts from
         :param modal_shift: How many steps up or down to shift the scale's interval relationships. To get a regular
             harmonic minor scale, simply use the default modal shift of 0.
         :param cycle: whether or not this scale repeats after an octave or is constrained to a single octave.
         """
         return cls(ScaleType.pentatonic(modal_shift), start_pitch, cycle=cycle)
 
     @classmethod
-    def pentatonic_minor(cls, start_pitch: Real, cycle: bool = True) -> 'Scale':
+    def pentatonic_minor(cls, start_pitch: Real, cycle: bool = True) -> Scale:
         """
         Returns a pentatonic minor scale starting on the specified pitch.
 
         :param start_pitch: the pitch this scale starts from
         :param cycle: whether or not this scale repeats after an octave or is constrained to a single octave.
         """
         return cls(ScaleType.pentatonic_minor(), start_pitch, cycle=cycle)
 
     @classmethod
-    def blues(cls, start_pitch: Real, cycle: bool = True) -> 'Scale':
+    def blues(cls, start_pitch: Real, cycle: bool = True) -> Scale:
         """
         Returns a 6-note blues scale starting on the specified pitch.
 
         :param start_pitch: the pitch this scale starts from
         :param cycle: whether or not this scale repeats after an octave or is constrained to a single octave.
         """
         return cls(ScaleType.blues(), start_pitch, cycle=cycle)
@@ -718,25 +719,31 @@
             start = 0 if item.start is None else item.start
             step = 1 if item.step is None else item.step
             if item.stop is None:
                 return (self.degree_to_pitch(x) for x in itertools.count(start, step))
             else:
                 return [self.degree_to_pitch(x)
                         for x in itertools.islice(itertools.count(start, step), int((item.stop - start) / step))]
-        elif isinstance(item, tuple):
+        elif isinstance(item, (list, tuple)):
             pieces = [[self.__getitem__(x)] if isinstance(x, Real) else self.__getitem__(x) for x in item]
 
             if all(isinstance(x, list) for x in pieces):
                 return sum(pieces, start=[])
             else:
                 return itertools.chain(*pieces)
 
     def __iter__(self):
         for step_num in range(self.num_steps + 1):
             yield self.degree_to_pitch(step_num)
 
+    def __contains__(self, item):
+        if not self._cycle:
+            return item in self._seed_pitches
+        else:
+            return (item - self.start_pitch) % self.width + self.start_pitch in self._seed_pitches
+
     def __repr__(self):
         return "Scale({}, {}{})".format(
             repr(self.scale_type),
             self._start_pitch,
             ", cycle={}".format(self._cycle) if not self._cycle else ""
         )
```

## scamp_extensions/playback/multi_preset_instrument.py

```diff
@@ -16,14 +16,15 @@
 #  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.     #
 #  See the GNU General Public License for more details.                                          #
 #                                                                                                #
 #  You should have received a copy of the GNU General Public License along with this program.    #
 #  If not, see <http://www.gnu.org/licenses/>.                                                   #
 #  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  #
 
+from __future__ import annotations
 import logging
 from collections import namedtuple
 from clockblocks import Clock
 from scamp import ScampInstrument, Session, SpellingPolicy, NoteProperties, NoteHandle, ChordHandle
 from scamp.utilities import NoteProperty
 from typing import Sequence, Optional, Union, Tuple
 
@@ -189,15 +190,15 @@
         else:
             logging.warning("MultiPresetInstrument {} does not have any presets. (Probably a mistake?)".
                             format(self.name))
 
         self.notation_part.play_chord(pitches, volume, length, properties=properties, blocking=blocking, clock=clock)
 
     def start_note(self, pitch: float, volume: float, properties: Union[str, dict, Sequence, NoteProperty] = None,
-                   preset: str = None, clock: Clock = None, max_volume: float = 1) -> 'MultiNoteHandle':
+                   preset: str = None, clock: Clock = None, max_volume: float = 1) -> MultiNoteHandle:
         """
         Start a note using this MultiPresetInstrument.
 
         :param pitch: see :func:`~scamp.instruments.ScampInstrument.start_note`
         :param volume: see :func:`~scamp.instruments.ScampInstrument.start_note`
         :param properties: see :func:`~scamp.instruments.ScampInstrument.start_note`
         :param preset: name of the preset to use for this note.
@@ -219,15 +220,15 @@
             logging.warning("MultiPresetInstrument {} does not have any presets. (Probably a mistake?)".
                             format(self.name))
         handles.append(self.notation_part.start_note(pitch, volume, properties, clock=clock, max_volume=max_volume))
         return MultiNoteHandle(handles)
 
     def start_chord(self, pitches: Sequence[float], volume: float,
                     properties: Union[str, dict, Sequence, NoteProperty] = None, preset: str = None,
-                    clock: Clock = None, max_volume: float = 1) -> 'MultiNoteHandle':
+                    clock: Clock = None, max_volume: float = 1) -> MultiNoteHandle:
         """
         Start a note using this MultiPresetInstrument.
 
         :param pitches: see :func:`~scamp.instruments.ScampInstrument.start_chord`
         :param volume: see :func:`~scamp.instruments.ScampInstrument.start_chord`
         :param properties: see :func:`~scamp.instruments.ScampInstrument.start_chord`
         :param preset: name of the preset to use for this note.
```

## scamp_extensions/process/_pykov.py

```diff
@@ -115,18 +115,18 @@
         >>> pykov.Vector(A=.3, B=.7)
         {'A':.3, 'B':.7}
         """
         OrderedDict.__init__(self)
 
         if data:
             self.update([item for item in six.iteritems(data)
-                         if abs(item[1]) > numpy.finfo(numpy.float).eps])
+                         if abs(item[1]) > numpy.finfo(float).eps])
         if len(kwargs):
             self.update([item for item in six.iteritems(kwargs)
-                         if abs(item[1]) > numpy.finfo(numpy.float).eps])
+                         if abs(item[1]) > numpy.finfo(float).eps])
 
     def __getitem__(self, key):
         """
         >>> q = pykov.Vector(C=.4, B=.6)
         >>> q['C']
         0.4
         >>> q['Z']
@@ -143,15 +143,15 @@
         >>> q['Z']=.2
         >>> q
         {'C': 0.4, 'B': 0.6, 'Z': 0.2}
         >>> q['Z']=0
         >>> q
         {'C': 0.4, 'B': 0.6}
         """
-        if abs(value) > numpy.finfo(numpy.float).eps:
+        if abs(value) > numpy.finfo(float).eps:
             OrderedDict.__setitem__(self, key, value)
         elif key in self:
             del (self[key])
 
     def __mul__(self, M):
         """
         >>> p = pykov.Vector(A=.3, B=.7)
@@ -406,15 +406,15 @@
         """
         >>> T = pykov.Matrix({('A','B'): .3, ('A','A'): .7, ('B','A'): 1.})
         """
         OrderedDict.__init__(self)
 
         if data:
             self.update([item for item in six.iteritems(data)
-                         if abs(item[1]) > numpy.finfo(numpy.float).eps])
+                         if abs(item[1]) > numpy.finfo(float).eps])
 
     def __getitem__(self, *args):
         """
         >>> T = pykov.Matrix({('A','B'): .3, ('A','A'): .7, ('B','A'): 1.})
         >>> T[('A','B')]
         0.3
         >>> T['A','B']
@@ -450,15 +450,15 @@
         >>> T['A','C']=1
         >>> T.states()
         {'A', 'B', 'C'}
         >>> T['A','C']=0
         >>> T.states()
         {'A', 'B'}
         """
-        if abs(value) > numpy.finfo(numpy.float).eps:
+        if abs(value) > numpy.finfo(float).eps:
             OrderedDict.__setitem__(self, key, value)
         elif key in self:
             del (self[key])
 
     @_del_cache
     def __delitem__(self, key):
         """
@@ -1540,14 +1540,14 @@
         if head not in tail_set:
             transitions_list.append((head, head))
     return None
 
 
 def _machineEpsilon(func=float):
     """
-    should be the same result of: numpy.finfo(numpy.float).eps
+    should be the same result of: numpy.finfo(float).eps
     """
     machine_epsilon = func(1)
     while func(1) + func(machine_epsilon) != func(1):
         machine_epsilon_last = machine_epsilon
         machine_epsilon = func(machine_epsilon) / func(2)
     return machine_epsilon_last
```

## scamp_extensions/process/markov.py

```diff
@@ -17,197 +17,210 @@
 #  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.     #
 #  See the GNU General Public License for more details.                                          #
 #                                                                                                #
 #  You should have received a copy of the GNU General Public License along with this program.    #
 #  If not, see <http://www.gnu.org/licenses/>.                                                   #
 #  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  #
 
+from __future__ import annotations
 import random
 import math
-from typing import Sequence, Iterator
+from typing import Sequence
 from ..utilities.sequences import cyclic_slice
 
 
 class MarkovModel:
 
     """
     A Markov analysis-synthesis tool that analyzes the given data, and can generate new data based on the
     same statistical patterns.
 
-    :param data: A sequence of states whose transition probabilities to analyze
+    :param data: A sequence of states whose transition probabilities to analyze (can train after instantiating too)
     :param max_order: The maximum order of Markov analysis to perform
     :param cyclic: Whether or not to treat the data as cyclic. (If not, resynthesis can reach a dead end.)
     """
 
-    def __init__(self, data: Sequence, max_order: int = 1, cyclic: bool = True):
-        self.data = data
+    def __init__(self, data: Sequence = None, max_order: int = 1, cyclic: bool = True):
         self.state_quantities = {}
-
-        # for generating zeroth-order
-        for datum in data:
-            if datum in self.state_quantities:
-                self.state_quantities[datum] += 1.0
-            else:
-                self.state_quantities[datum] = 1.0
+        self.num_states = 0
 
         self.max_order = max_order
-        self.cyclic = cyclic
 
         # we import this inside of MarkovModel so that a lack of dependencies does not break unrelated imports
         # in the scamp_extensions.process subpackage.
         from ._pykov import Chain
         self.chain = Chain()
-
-        self._train_the_chain()
+        
+        if data:
+            self.train(data, cyclic)
 
     def move_zeroth_order(self):
         """
         Returns a randomly selected state (weighted by frequency).
         """
         r = random.random()
         for key, value in self.state_quantities.items():
-            this_key_probability = value/len(self.data)
+            this_key_probability = value/self.num_states
             if r < this_key_probability:
                 return key
             else:
                 r -= this_key_probability
 
-    def generate(self, num_values: int, order: float, start_values: Sequence = None) -> Sequence:
+    def generate(self, num_values: int, order: float, initial_history: Sequence = None,
+                 keep_looping: bool = False) -> Sequence:
         """
         Generates a sequence of states following the Markov analysis performed on the input data.
 
         :param num_values: How many states to generate.
         :param order: The Markov order used in generating new states. Can be floating point, in which case the order for
             any given move is a weighted random choice between the adjacent integer orders.
-        :param start_values: Values with which to seed the state history. If none, simply starts at random state
+        :param initial_history: Values with which to seed the state history. If none, simply starts at random state
             from within the data set.
-        :return:
+        :param keep_looping: if True, then when we hit a dead end, keep reducing the order by one until we find a next
+            move (once it gets to order zero, it just chooses randomly)
         """
         if order > self.max_order:
             raise ValueError("Cannot generate values using order {}, as max order was set to {}.".
                              format(order, self.max_order))
 
-        if start_values is None:
-            start_values = (self.move_zeroth_order(), )
-        elif not hasattr(start_values, '__len__'):
-            start_values = (start_values, )
+        if initial_history is None:
+            initial_history = (self.move_zeroth_order(),)
+        elif not hasattr(initial_history, '__len__'):
+            initial_history = (initial_history,)
 
-        history = list(start_values)
+        history = list(initial_history)
         out = []
 
         try:
-            if order <= 0:
-                for i in range(num_values):
-                    out.append(self.move_zeroth_order())
-            elif order == int(order):
-                for i in range(num_values):
-                    if len(history) > order:
-                        this_key = tuple(history[len(history)-int(order):])
-                    else:
-                        this_key = tuple(history)
-
-                    next_state = self.move(this_key)
-                    history.append(next_state)
-                    out.append(next_state)
-            else:
-                # fractional order, so choose the higher or lower order with appropriate probability
-                lower_order = int(order)
-                higher_order = lower_order+1
-                fractional_part = order - lower_order
-
-                for i in range(num_values):
-                    this_step_order = higher_order if random.random() < fractional_part else lower_order
-                    if this_step_order <= 0:
-                        next_state = self.move_zeroth_order()
-                    else:
-                        if len(history) > this_step_order:
-                            this_key = tuple(history[len(history)-this_step_order:])
-                        else:
-                            this_key = tuple(history)
-                        next_state = self.move(this_key)
-                    history.append(next_state)
-                    out.append(next_state)
-        except KeyError:
-            pass
+            while len(out) < num_values:
+                if keep_looping:
+                    o = order
+                    while True:
+                        try:
+                            next_move = self._get_next(history, o)
+                            break
+                        except KeyError:
+                            # no data for this order; try reducing order
+                            o -= 1
+                else:
+                    next_move = self._get_next(history, order)
+                out.append(next_move)
+                history.append(next_move)
         finally:
             return out
 
+    def _get_next(self, history, order: float):
+        if order <= 0:
+            return self.move_zeroth_order()
+
+        if order != int(order):
+            # fractional order, so choose the higher or lower order with appropriate probability
+            lower_order = int(order)
+            higher_order = lower_order + 1
+            fractional_part = order - lower_order
+            order = higher_order if random.random() < fractional_part else lower_order
+
+        if len(history) > order:
+            this_key = tuple(history[len(history) - int(order):])
+        else:
+            this_key = tuple(history)
+        return self.move(this_key)
+
     def move(self, state, random_func=None):
         """
         Do one step from the indicated state, and return the final state.
         Optionally, a function that generates a random number can be supplied.
         """
         return self.chain.move(state, random_func)
 
-    def _train_the_chain(self):
+    def _count_states(self, data):
+        # for generating zeroth-order
+        for datum in data:
+            if datum in self.state_quantities:
+                self.state_quantities[datum] += 1.0
+            else:
+                self.state_quantities[datum] = 1.0
+            self.num_states += 1
+
+    def train(self, data, cyclic=True):
+        self._count_states(data)
+
         order = int(math.ceil(self.max_order)) if not isinstance(self.max_order, int) else self.max_order
 
-        if order >= len(self.data):
-            order = len(self.data)
+        if order >= len(data):
+            order = len(data)
 
         for o in range(1, order+1):
-            if self.cyclic:
-                start_indices = range(len(self.data))
+            if cyclic:
+                start_indices = range(len(data))
             else:
-                start_indices = range(len(self.data) - o)
+                start_indices = range(len(data) - o)
 
             for i in start_indices:
-                this_key = (tuple(cyclic_slice(self.data, i, i+o)), self.data[(i+o) % len(self.data)])
+                this_key = (tuple(cyclic_slice(data, i, i+o)), data[(i+o) % len(data)])
                 if this_key in self.chain.keys():
                     self.chain[this_key] += 1
                 else:
                     self.chain[this_key] = 1
 
-        # this part is necessary to normalize the probabilities
+        self._normalize_probabilities()
+
+    def _normalize_probabilities(self):
         antecedent_total_prob_values = {}
         for (antecedent, consequent) in self.chain:
             if antecedent in antecedent_total_prob_values:
                 antecedent_total_prob_values[antecedent] += self.chain[(antecedent, consequent)]
             else:
                 antecedent_total_prob_values[antecedent] = float(self.chain[(antecedent, consequent)])
 
         for (antecedent, consequent) in self.chain:
             self.chain[(antecedent, consequent)] = \
                 self.chain[(antecedent, consequent)] / antecedent_total_prob_values[antecedent]
 
-    def get_iterator(self, order: float, start_values: Sequence = None) -> 'MarkovIterator':
+    def get_iterator(self, order: float, start_values: Sequence = None, keep_looping: bool = False) -> MarkovIterator:
         """
         Returns a :class:`MarkovIterator` based on this model.
 
         :param order: the Markov order to use in generating new states. Can be floating point (see
             :class:`MarkovIterator`), and can be altered during iteration.
         :param start_values: Values with which to seed the iterator's history. If none, simply starts at random state
             from within the data set.
+        :param keep_looping: if True, then when we hit a dead end, keep reducing the order by one until we find a next
+            move (once it gets to order zero, it just chooses randomly)
         """
-        return MarkovIterator(self, order, start_values)
+        return MarkovIterator(self, order, start_values, keep_looping)
 
 
 class MarkovIterator:
 
     """
     Iterator that returns generated values from the given MarkovModel. Order can be fractional and can change
     during iteration.
 
     :param markov_model: the MarkovModel used for resynthesis.
     :param order: the Markov order used in generating new states. Can be floating point, in which case the order for
         any given move is a weighted random choice between the adjacent integer orders.
     :param start_values: Values with which to seed this iterator's history. If none, simply starts at random state
         from within the data set.
+    :param keep_looping: if True, then when we hit a dead end, keep reducing the order by one until we find a next
+            move (once it gets to order zero, it just chooses randomly)
     """
 
-    def __init__(self, markov_model: MarkovModel, order: float, start_values: Sequence = None):
+    def __init__(self, markov_model: MarkovModel, order: float, start_values: Sequence = None,
+                 keep_looping: bool = False):
         if start_values is None:
             self.history = [markov_model.move_zeroth_order()]
         else:
             self.history = list(start_values)
 
         self.model = markov_model
         self.order = order
+        self.keep_looping = keep_looping
 
     def __iter__(self):
         return self
 
     def __next__(self):
-        self.history.extend(self.model.generate(1, self.order, self.history))
+        self.history.extend(self.model.generate(1, self.order, self.history, self.keep_looping))
         if len(self.history) > self.model.max_order:
             self.history.pop(0)
         return self.history[-1]
```

## scamp_extensions/rhythm/__init__.py

```diff
@@ -1,10 +1,11 @@
 """
-Subpackage containing rhythm-related extensions. These include abstractions for representing metric structures and a
-more flexible implementation of Clarence Barlow's concept of indispensability.
+Subpackage containing rhythm-related extensions. These include abstractions for representing metric structures, a
+more flexible implementation of Clarence Barlow's concept of indispensability, and a boolean streamer module that
+implements, among other things, a Xenakian sieve rhythms.
 """
 
 #  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  #
 #  This file is part of SCAMP (Suite for Computer-Assisted Music in Python)                      #
 #  Copyright © 2020 Marc Evanstein <marc@marcevanstein.com>.                                     #
 #                                                                                                #
 #  This program is free software: you can redistribute it and/or modify it under the terms of    #
@@ -18,7 +19,8 @@
 #  You should have received a copy of the GNU General Public License along with this program.    #
 #  If not, see <http://www.gnu.org/licenses/>.                                                   #
 #  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  #
 
 from .indispensability import indispensability_array_from_strata, indispensability_array_from_expression, \
     barlow_style_indispensability_array
 from .metric_structure import MetricStructure, MeterArithmeticGroup
+from .boolean_streamer import boolean_streamer, BooleanStreamer, SieveStreamer, RandStreamer, FreqStreamer
```

## scamp_extensions/utilities/__init__.py

```diff
@@ -16,9 +16,10 @@
 #                                                                                                #
 #  You should have received a copy of the GNU General Public License along with this program.    #
 #  If not, see <http://www.gnu.org/licenses/>.                                                   #
 #  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  #
 
 from .sequences import make_flat_list, sum_nested_list, rotate_sequence, sequence_depth, cyclic_slice
 from .math import gcd, lcm, is_x_pow_of_y, floor_x_to_pow_of_y, ceil_x_to_pow_of_y, round_x_to_pow_of_y, \
-    floor_to_multiple, ceil_to_multiple, round_to_multiple, is_multiple, prime_factor, is_prime, remap
+    floor_to_multiple, ceil_to_multiple, round_to_multiple, is_multiple, prime_factor, is_prime, remap, \
+    AtanWarp, atan_warp, wrap_to_range
 from .time_varying_parameter import TimeVaryingParameter
```

## scamp_extensions/utilities/math.py

```diff
@@ -81,13 +81,79 @@
         warp_envelope = EnvelopeSegment(0, 1, out_min, out_max, output_warp)
         return [warp_envelope.value_at(x) for x in normalized_data]
     else:
         out_range = out_max - out_min
         return [out_min + out_range * x for x in normalized_data]
 
 
+def wrap_to_range(x, range_min, range_max, mirror=False):
+    """
+    Wraps the input x into the given range, either jumping back to the other side of the range at the boundaries,
+    or if the mirror parameter is set, reflecting at the boundaries.
+
+    :param x: the input
+    :param range_min: minimum of wrapping range
+    :param range_max: maximum of wrapping range
+    :param mirror: whether to mirror at the boundaries
+    """
+    width = (range_max - range_min)
+    if mirror:
+        mod_double_range = (x - range_min) % (2 * width)
+        if mod_double_range > width:
+            return 2 * width - mod_double_range + range_min
+        else:
+            return mod_double_range + range_min
+    else:
+        return (x - range_min) % width + range_min
+
+
 floor_x_to_pow_of_y = multi_option_function(floor_x_to_pow_of_y)
 ceil_x_to_pow_of_y = multi_option_function(ceil_x_to_pow_of_y)
 round_x_to_pow_of_y = multi_option_function(round_x_to_pow_of_y)
 floor_to_multiple = multi_option_function(floor_to_multiple)
 ceil_to_multiple = multi_option_function(ceil_to_multiple)
 round_to_multiple = multi_option_function(round_to_multiple)
+
+
+class AtanWarp:
+    """
+    A warping function that uses an appropriately scaled arctan to warp values from the input range to the output range.
+    See :func:`atan_warp` for details. This callable object version is callable allows you to define the warp on
+    instantiation and then call it like a function. E.g:
+
+    .. code-block:: python
+
+       warper = AtanWarp(-10, 10, 100, 200)
+       print(warper(0), warper(-5), warper(20))
+
+    :param in_lo: soft input minimum
+    :param in_hi: soft input maximum
+    :param out_min: hard input minimum
+    :param out_max: hard input maximum
+    """
+
+    def __init__(self, in_lo: float, in_hi: float, out_min: float, out_max: float):
+        self.in_center = (in_hi + in_lo) / 2
+        self.out_center = (out_max + out_min) / 2
+        self.out_width = (out_max - out_min) / 2
+        self.slope = (out_max - out_min) / (in_hi - in_lo)
+
+    def __call__(self, val):
+        return math.atan((val - self.in_center) * (math.pi / 2) / self.out_width * self.slope) * self.out_width / (
+                    math.pi / 2) + self.out_center
+
+
+def atan_warp(value, in_lo, in_hi, out_min, out_max) -> float:
+    """
+    Uses an appropriately scaled arctan function to warp values from the input range to the output range. The input
+    range is a soft boundary for the inputs expected, whereas the output range is a hard limit, to which extreme
+    high and low input values asymptote. At the exact center of the input range there is no warping, and the slope
+    of the transformation is the same as if it were linear; as input values approach or exceed the boundaries
+    of the input range, the output approaches, but never exceeds the output range.
+
+    :param value: the value to warp
+    :param in_lo: soft input minimum
+    :param in_hi: soft input maximum
+    :param out_min: hard input minimum
+    :param out_max: hard input maximum
+    """
+    return AtanWarp(in_lo, in_hi, out_min, out_max)(value)
```

## Comparing `scamp_extensions-0.3.3.dist-info/LICENSE` & `scamp_extensions-0.3.5.post1.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `scamp_extensions-0.3.3.dist-info/METADATA` & `scamp_extensions-0.3.5.post1.dist-info/METADATA`

 * *Files 5% similar despite different names*

```diff
@@ -1,21 +1,23 @@
 Metadata-Version: 2.1
 Name: scamp-extensions
-Version: 0.3.3
+Version: 0.3.5.post1
 Summary: Extensions to SCAMP (Suite for Computer-Assisted Music in Python)
 Home-page: https://git.sr.ht/~marcevanstein/scamp_extensions
 Author: Marc Evanstein
 Author-email: marc@marcevanstein.com
-License: UNKNOWN
+License: GNU GPL Version 3
 Platform: UNKNOWN
-Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: Python :: 3.10
 Classifier: License :: OSI Approved :: GNU General Public License v3 (GPLv3)
 Classifier: Operating System :: OS Independent
+Requires-Python: >=3.10
 Description-Content-Type: text/markdown
-Requires-Dist: scamp (>=0.8.9.5)
+License-File: LICENSE
+Requires-Dist: scamp (>=0.9.2)
 
 # scamp_extensions
 
 _scamp_extensions_ contains various extensions to the [SCAMP framework](https://pypi.org/project/scamp/) for computer-assisted music composition.
 
 This package is the place for models of music-theoretical concepts (e.g. scales, pitch-class sets), conveniences for interacting with various types of input and output, and in general anything that builds upon SCAMP but is outside of the scope of the main framework.
```

## Comparing `scamp_extensions-0.3.3.dist-info/RECORD` & `scamp_extensions-0.3.5.post1.dist-info/RECORD`

 * *Files 17% similar despite different names*

```diff
@@ -1,35 +1,38 @@
-scamp_extensions/__init__.py,sha256=uVbpuEEIGN7UPavLcqaJr0Gy5aVugZNV40v9UyjogGI,2474
+scamp_extensions/__init__.py,sha256=nA4biMe_aqDV2NAPMVUQqlo6n0BHVjTp0CZ9I6iLugo,2635
 scamp_extensions/composers/__init__.py,sha256=faw_r1SKIRTqiySv94JfE4VUSYvVl0kDrxAZTUPiGi0,1565
 scamp_extensions/composers/barlicity.py,sha256=NdMYOW7LhUFnAOfg80ayIWWFJdnoCdHf_MLUEVO0_04,31336
 scamp_extensions/engraving/__init__.py,sha256=D9mt8ssgT8f-YeCqH_zlDh9MpcvsyebYbxrBW0zTtHY,1586
-scamp_extensions/engraving/note_graph.py,sha256=yECZs3QD2iD0T3b6V3tdiSANKXY9v_KPTXfi_v_v1ng,19781
+scamp_extensions/engraving/note_graph.py,sha256=QoPh0CNFAjd5TALuAISVGWg7Cpl55oI4FGJepb7HXVo,19781
 scamp_extensions/interaction/__init__.py,sha256=wYs5xXheHIWwMtZ7pHZN7jdUf1Ky-4rzuFKjaP9uwyQ,1617
 scamp_extensions/interaction/key_plane.py,sha256=xMAWMB3x2iyF3qr7CTW3JgAi1MfD3bOtivuP3kYtTqc,6295
+scamp_extensions/parsing/__init__.py,sha256=pp3Wdei1TDcZnP6ek0EwLoJ6_Z67EOMK56EX-oTG9j0,1553
+scamp_extensions/parsing/midi.py,sha256=q05ZbZont-GPaDLkX2KgLrrLhoYRhRKf9s-MMKfMI2U,3803
 scamp_extensions/pitch/__init__.py,sha256=7JItp9Au1R_Vz2wmKrzs8UMZ4dR8e5M1KgL3mgdmZ-g,1845
-scamp_extensions/pitch/scale.py,sha256=6V9d7GynO8rs5eweDrw7WsLa3smlqmxblOGbzzz7EXY,33470
+scamp_extensions/pitch/scale.py,sha256=7cp6hjyeWPpgFHAv65rDdKVX12d8gXbQKUolLlC8AWs,33651
 scamp_extensions/pitch/utilities.py,sha256=ufDrsH9W9nWZYo7SoL62Fr73WB7TfGftuVaRyBW1DeA,6756
 scamp_extensions/playback/__init__.py,sha256=Clg5KLvSy0Y8qsuakfbJOeks6dR38jlslpL9xoP5iSs,1798
-scamp_extensions/playback/multi_preset_instrument.py,sha256=WhJykeDiOjEqNL0YUDm6JmMth7jQO-c5oODGjBe9irU,19099
+scamp_extensions/playback/multi_preset_instrument.py,sha256=TWZeKIPQgUKX6BLEBZhFvqU0lnqNTMmoIdWMR9Mu2no,19130
 scamp_extensions/playback/supercollider/__init__.py,sha256=OW0Q6ZAmIDOJFUhE46z3Pgd_xi3-jXWbUz4dW6MbV78,2051
 scamp_extensions/playback/supercollider/scInit.scd,sha256=vI5uMRsbpsjuz-kQ-czyku5X0BB87DmxZ8Xg5gdolnY,395
 scamp_extensions/playback/supercollider/sc_lang.py,sha256=4wyH1etUGNyHufemXVZEl1JrAbc7HPAQJnz7FC641oI,4457
 scamp_extensions/playback/supercollider/sc_playback_implementation.py,sha256=5ieZ0FDeFBW5W2K-PqbpZQGpG7G2hdW2bKSkr5Ufl-A,7008
 scamp_extensions/playback/supercollider/scamp_sc_config.yaml,sha256=Ts-BKUhvpN5DgbZtUz_Z8fNRcMBQLJvYXSt9IzCbM8Y,85
 scamp_extensions/playback/supercollider/scampExtensions/ScampExtensions.sc,sha256=HsGE_eHqjq7EWipEziU1T24hufH_vQ3Z53gfbeqzRUw,2540
 scamp_extensions/process/__init__.py,sha256=eKIFfhlYLCttN72KWRh4w2GsoF7ktWv15pspKEgzLNc,1737
-scamp_extensions/process/_pykov.py,sha256=AuWifB7qaBS6NEftfWvl-iTcFJwzKlKUMCZvVbza72M,46098
+scamp_extensions/process/_pykov.py,sha256=ZHhe-ol-muIysZcRStQgDyn4XzYfNqu6K819VbJsS28,46062
 scamp_extensions/process/generators.py,sha256=adThme2BIdCifENtA5yh_v4CCEzbWqaqKEhcyAeEN48,3667
 scamp_extensions/process/l_systems.py,sha256=BXuwwbuPkdkJf4AU2vjoro7Ncc8yY3cYkOmNd1Fxce0,4810
-scamp_extensions/process/markov.py,sha256=2knuVGg3ZEQGkhq8kvFTe5H2nQg0acchpROTD7nXye8,9508
-scamp_extensions/rhythm/__init__.py,sha256=iGaVx21d8hlUeciz-KVUNZunwXAZGL2YOS0mnhf5Mgk,1908
+scamp_extensions/process/markov.py,sha256=4wZIFmBvKZdClAcgogKPKfRmXOjVrBtmAKirlUjPGXY,10152
+scamp_extensions/rhythm/__init__.py,sha256=NVFeB-Cp2KVMueFt-P5YEWMkQqvgxHBBNDjowokmQ8Y,2105
+scamp_extensions/rhythm/boolean_streamer.py,sha256=5js2yaaeKjmlFm-XoiGu_zfBqNp5FM4U7By7iS1pGBk,6009
 scamp_extensions/rhythm/indispensability.py,sha256=Ml9V4alk8akZ61-4rnoZYNl_mtlpPlEhJUxfyuWvKbE,6671
 scamp_extensions/rhythm/metric_structure.py,sha256=7Q3UF4egaGRuUT99ltGI1PtTSIdYRCQCjZmb8Q3IHco,2170
-scamp_extensions/utilities/__init__.py,sha256=tgly8cQzVGQtBka902JUqfmzTsiLfKJf0xxXY-c34jQ,1965
-scamp_extensions/utilities/math.py,sha256=lWul3gk8ndnVUZ0TYGht0bTzZH2vE5jCIcFA8CrYYKs,5172
+scamp_extensions/utilities/__init__.py,sha256=gVgHmtzSTi3m4EmgBLNgOU915lknz2xKhMMe8p9nSSE,2007
+scamp_extensions/utilities/math.py,sha256=nkG9aBkGBLWJGKcQ671q1OKpx45DQAIEmzjDQJz6nrM,7885
 scamp_extensions/utilities/sequences.py,sha256=qsn7mG_28J4rL5PHQODK4fkksCzcGBovb5H_JD1q9QI,7037
 scamp_extensions/utilities/time_varying_parameter.py,sha256=S5Q0L-RLT3LZDpGLoPtqvsjK4dx5f1T4y_TG59saooc,9668
-scamp_extensions-0.3.3.dist-info/LICENSE,sha256=jOtLnuWt7d5Hsx6XXB2QxzrSe2sWWh3NgMfFRetluQM,35147
-scamp_extensions-0.3.3.dist-info/METADATA,sha256=CbUAtlau4QY_LJsaGRgFlKgDY8KMt3cJfoEFj7VXvSA,1382
-scamp_extensions-0.3.3.dist-info/WHEEL,sha256=g4nMs7d-Xl9-xC9XovUrsDHGXt-FT0E17Yqo92DEfvY,92
-scamp_extensions-0.3.3.dist-info/top_level.txt,sha256=bo349zumE55saHzcU-QyVi6k1a-eA6KBfSzw4U4p7c8,17
-scamp_extensions-0.3.3.dist-info/RECORD,,
+scamp_extensions-0.3.5.post1.dist-info/LICENSE,sha256=jOtLnuWt7d5Hsx6XXB2QxzrSe2sWWh3NgMfFRetluQM,35147
+scamp_extensions-0.3.5.post1.dist-info/METADATA,sha256=-kSrIRXA1-BO7hRTUoJtYlxRp76NupEoc_u33LHA_e0,1445
+scamp_extensions-0.3.5.post1.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
+scamp_extensions-0.3.5.post1.dist-info/top_level.txt,sha256=bo349zumE55saHzcU-QyVi6k1a-eA6KBfSzw4U4p7c8,17
+scamp_extensions-0.3.5.post1.dist-info/RECORD,,
```

