# Comparing `tmp/archcraftsman-4.0.1-py3-none-any.whl.zip` & `tmp/archcraftsman-4.1.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,66 +1,65 @@
-Zip file size: 98940 bytes, number of entries: 64
+Zip file size: 97606 bytes, number of entries: 63
 -rw-r--r--  2.0 unx      732 b- defN 23-Apr-20 21:57 archcraftsman/__init__.py
--rw-r--r--  2.0 unx      828 b- defN 23-May-03 18:09 archcraftsman/__main__.py
--rw-r--r--  2.0 unx     1904 b- defN 23-May-03 18:09 archcraftsman/arguments.py
--rw-r--r--  2.0 unx    11383 b- defN 23-May-05 19:14 archcraftsman/autopart.py
--rw-r--r--  2.0 unx     6720 b- defN 23-May-03 18:09 archcraftsman/base.py
--rw-r--r--  2.0 unx    12635 b- defN 23-May-05 19:14 archcraftsman/basesetup.py
--rw-r--r--  2.0 unx     5314 b- defN 23-May-03 18:09 archcraftsman/config.py
--rw-r--r--  2.0 unx     4444 b- defN 23-May-03 18:09 archcraftsman/disk.py
--rw-r--r--  2.0 unx     1449 b- defN 23-May-03 18:09 archcraftsman/i18n.py
--rw-r--r--  2.0 unx     1281 b- defN 23-May-03 18:09 archcraftsman/info.py
--rw-r--r--  2.0 unx    11235 b- defN 23-May-05 19:14 archcraftsman/installer.py
--rw-r--r--  2.0 unx     7320 b- defN 23-May-05 19:14 archcraftsman/manualpart.py
--rw-r--r--  2.0 unx     3984 b- defN 23-May-03 18:09 archcraftsman/options.py
--rw-r--r--  2.0 unx     3335 b- defN 23-May-03 18:09 archcraftsman/packages.py
--rw-r--r--  2.0 unx    10496 b- defN 23-May-05 19:14 archcraftsman/partition.py
--rw-r--r--  2.0 unx     4299 b- defN 23-May-03 18:09 archcraftsman/partitioninginfo.py
--rw-r--r--  2.0 unx     3638 b- defN 23-May-03 18:09 archcraftsman/prelaunchinfo.py
--rw-r--r--  2.0 unx     6180 b- defN 23-May-05 19:14 archcraftsman/shell.py
--rw-r--r--  2.0 unx     3116 b- defN 23-May-03 18:09 archcraftsman/systeminfo.py
--rw-r--r--  2.0 unx     8407 b- defN 23-May-05 19:14 archcraftsman/utils.py
--rw-r--r--  2.0 unx      732 b- defN 23-Mar-24 22:08 archcraftsman/bundles/__init__.py
--rw-r--r--  2.0 unx     2342 b- defN 23-May-03 18:09 archcraftsman/bundles/budgie.py
--rw-r--r--  2.0 unx     1424 b- defN 23-May-03 18:09 archcraftsman/bundles/bundle.py
--rw-r--r--  2.0 unx     2491 b- defN 23-May-03 18:09 archcraftsman/bundles/cinnamon.py
--rw-r--r--  2.0 unx     1701 b- defN 23-May-03 18:09 archcraftsman/bundles/copyacm.py
--rw-r--r--  2.0 unx     1653 b- defN 23-May-03 18:09 archcraftsman/bundles/cups.py
--rw-r--r--  2.0 unx     2013 b- defN 23-May-03 18:09 archcraftsman/bundles/cutefish.py
--rw-r--r--  2.0 unx     2250 b- defN 23-May-03 18:09 archcraftsman/bundles/deepin.py
--rw-r--r--  2.0 unx     1684 b- defN 23-May-03 18:09 archcraftsman/bundles/enlightenment.py
--rw-r--r--  2.0 unx     1066 b- defN 23-May-03 18:09 archcraftsman/bundles/generateconfig.py
--rw-r--r--  2.0 unx     2020 b- defN 23-May-03 18:09 archcraftsman/bundles/gnome.py
--rw-r--r--  2.0 unx     1415 b- defN 23-May-03 18:09 archcraftsman/bundles/grmlzsh.py
--rw-r--r--  2.0 unx     4149 b- defN 23-May-03 18:09 archcraftsman/bundles/grub.py
--rw-r--r--  2.0 unx     1758 b- defN 23-May-03 18:09 archcraftsman/bundles/i3.py
--rw-r--r--  2.0 unx     1380 b- defN 23-May-03 18:09 archcraftsman/bundles/iwd.py
--rw-r--r--  2.0 unx     1985 b- defN 23-May-03 18:09 archcraftsman/bundles/linux.py
--rw-r--r--  2.0 unx     2271 b- defN 23-May-03 18:09 archcraftsman/bundles/lxqt.py
--rw-r--r--  2.0 unx     1543 b- defN 23-May-03 18:09 archcraftsman/bundles/mainfilesystems.py
--rw-r--r--  2.0 unx     1826 b- defN 23-May-05 20:20 archcraftsman/bundles/mainfonts.py
--rw-r--r--  2.0 unx     2728 b- defN 23-May-03 18:09 archcraftsman/bundles/mate.py
--rw-r--r--  2.0 unx     2126 b- defN 23-May-03 18:09 archcraftsman/bundles/microcodes.py
--rw-r--r--  2.0 unx     1661 b- defN 23-May-03 18:09 archcraftsman/bundles/networkmanager.py
--rw-r--r--  2.0 unx     1381 b- defN 23-May-03 18:09 archcraftsman/bundles/nvidia.py
--rw-r--r--  2.0 unx     1377 b- defN 23-May-03 18:09 archcraftsman/bundles/pipewire.py
--rw-r--r--  2.0 unx     2807 b- defN 23-May-03 18:09 archcraftsman/bundles/plasma.py
--rw-r--r--  2.0 unx     2332 b- defN 23-May-03 18:09 archcraftsman/bundles/sway.py
--rw-r--r--  2.0 unx     1482 b- defN 23-May-03 18:09 archcraftsman/bundles/systemdnet.py
--rw-r--r--  2.0 unx     1341 b- defN 23-May-03 18:09 archcraftsman/bundles/terminus.py
--rw-r--r--  2.0 unx     5493 b- defN 23-May-05 19:14 archcraftsman/bundles/utils.py
--rw-r--r--  2.0 unx     2700 b- defN 23-May-03 18:09 archcraftsman/bundles/xfce.py
--rw-r--r--  2.0 unx     1427 b- defN 23-May-03 18:09 archcraftsman/bundles/yay.py
--rw-r--r--  2.0 unx     1484 b- defN 23-May-03 18:09 archcraftsman/bundles/zram.py
+-rw-r--r--  2.0 unx      837 b- defN 23-Jun-11 11:10 archcraftsman/__main__.py
+-rw-r--r--  2.0 unx     1900 b- defN 23-Jun-11 11:10 archcraftsman/arguments.py
+-rw-r--r--  2.0 unx    13374 b- defN 23-Jun-11 11:10 archcraftsman/autopart.py
+-rw-r--r--  2.0 unx     6964 b- defN 23-Jun-11 11:10 archcraftsman/base.py
+-rw-r--r--  2.0 unx    13886 b- defN 23-Jun-11 11:10 archcraftsman/basesetup.py
+-rw-r--r--  2.0 unx     5917 b- defN 23-Jun-11 11:10 archcraftsman/config.py
+-rw-r--r--  2.0 unx     4772 b- defN 23-Jun-11 11:10 archcraftsman/disk.py
+-rw-r--r--  2.0 unx     1464 b- defN 23-Jun-11 11:10 archcraftsman/i18n.py
+-rw-r--r--  2.0 unx     1415 b- defN 23-Jun-11 11:10 archcraftsman/imessages.py
+-rw-r--r--  2.0 unx     1464 b- defN 23-Jun-11 11:10 archcraftsman/info.py
+-rw-r--r--  2.0 unx    13327 b- defN 23-Jun-11 11:10 archcraftsman/installer.py
+-rw-r--r--  2.0 unx     9011 b- defN 23-Jun-11 11:10 archcraftsman/manualpart.py
+-rw-r--r--  2.0 unx     4178 b- defN 23-Jun-11 11:10 archcraftsman/options.py
+-rw-r--r--  2.0 unx     3458 b- defN 23-Jun-11 11:10 archcraftsman/packages.py
+-rw-r--r--  2.0 unx    11555 b- defN 23-Jun-11 11:10 archcraftsman/partition.py
+-rw-r--r--  2.0 unx     4573 b- defN 23-Jun-11 11:10 archcraftsman/partitioninginfo.py
+-rw-r--r--  2.0 unx     3953 b- defN 23-Jun-11 11:10 archcraftsman/prelaunchinfo.py
+-rw-r--r--  2.0 unx     7108 b- defN 23-Jun-11 11:10 archcraftsman/shell.py
+-rw-r--r--  2.0 unx     3607 b- defN 23-Jun-11 11:10 archcraftsman/systeminfo.py
+-rw-r--r--  2.0 unx     9030 b- defN 23-Jun-11 11:10 archcraftsman/utils.py
+-rw-r--r--  2.0 unx      732 b- defN 23-May-07 14:13 archcraftsman/bundles/__init__.py
+-rw-r--r--  2.0 unx     2538 b- defN 23-Jun-11 11:10 archcraftsman/bundles/budgie.py
+-rw-r--r--  2.0 unx     1663 b- defN 23-Jun-11 11:10 archcraftsman/bundles/bundle.py
+-rw-r--r--  2.0 unx     2708 b- defN 23-Jun-11 11:10 archcraftsman/bundles/cinnamon.py
+-rw-r--r--  2.0 unx     1959 b- defN 23-Jun-11 11:10 archcraftsman/bundles/copyacm.py
+-rw-r--r--  2.0 unx     2211 b- defN 23-Jun-11 11:10 archcraftsman/bundles/cutefish.py
+-rw-r--r--  2.0 unx     2484 b- defN 23-Jun-11 11:10 archcraftsman/bundles/deepin.py
+-rw-r--r--  2.0 unx     1876 b- defN 23-Jun-11 11:10 archcraftsman/bundles/enlightenment.py
+-rw-r--r--  2.0 unx     1240 b- defN 23-Jun-11 11:10 archcraftsman/bundles/generateconfig.py
+-rw-r--r--  2.0 unx     2695 b- defN 23-Jun-11 11:10 archcraftsman/bundles/genericbundle.py
+-rw-r--r--  2.0 unx     2250 b- defN 23-Jun-11 11:10 archcraftsman/bundles/gnome.py
+-rw-r--r--  2.0 unx     1668 b- defN 23-Jun-11 11:10 archcraftsman/bundles/grmlzsh.py
+-rw-r--r--  2.0 unx     4552 b- defN 23-Jun-11 11:10 archcraftsman/bundles/grub.py
+-rw-r--r--  2.0 unx     1939 b- defN 23-Jun-11 11:10 archcraftsman/bundles/i3.py
+-rw-r--r--  2.0 unx     1560 b- defN 23-Jun-11 11:10 archcraftsman/bundles/iwd.py
+-rw-r--r--  2.0 unx     2488 b- defN 23-Jun-11 11:10 archcraftsman/bundles/linux.py
+-rw-r--r--  2.0 unx     2465 b- defN 23-Jun-11 11:10 archcraftsman/bundles/lxqt.py
+-rw-r--r--  2.0 unx     2989 b- defN 23-Jun-11 11:10 archcraftsman/bundles/mate.py
+-rw-r--r--  2.0 unx     2268 b- defN 23-Jun-11 11:10 archcraftsman/bundles/microcodes.py
+-rw-r--r--  2.0 unx     1946 b- defN 23-Jun-11 11:10 archcraftsman/bundles/networkmanager.py
+-rw-r--r--  2.0 unx     1556 b- defN 23-Jun-11 11:10 archcraftsman/bundles/nvidia.py
+-rw-r--r--  2.0 unx     3180 b- defN 23-Jun-11 11:10 archcraftsman/bundles/plasma.py
+-rw-r--r--  2.0 unx     2578 b- defN 23-Jun-11 11:10 archcraftsman/bundles/sway.py
+-rw-r--r--  2.0 unx     1704 b- defN 23-Jun-11 11:10 archcraftsman/bundles/systemdnet.py
+-rw-r--r--  2.0 unx     1522 b- defN 23-Jun-11 11:10 archcraftsman/bundles/terminus.py
+-rw-r--r--  2.0 unx     3191 b- defN 23-Jun-11 11:10 archcraftsman/bundles/utils.py
+-rw-r--r--  2.0 unx     2961 b- defN 23-Jun-11 11:10 archcraftsman/bundles/xfce.py
+-rw-r--r--  2.0 unx     1664 b- defN 23-Jun-11 11:10 archcraftsman/bundles/yay.py
+-rw-r--r--  2.0 unx     1656 b- defN 23-Jun-11 11:10 archcraftsman/bundles/zram.py
+-rw-r--r--  2.0 unx      732 b- defN 23-Jun-11 11:10 archcraftsman/bundles/configs/__init__.py
 -rw-r--r--  2.0 unx      732 b- defN 23-Mar-25 00:46 archcraftsman/locales/__init__.py
--rw-r--r--  2.0 unx    29220 b- defN 23-May-03 18:09 archcraftsman/locales/french.po
+-rw-r--r--  2.0 unx    24293 b- defN 23-Jun-11 11:10 archcraftsman/locales/french.po
 -rw-r--r--  2.0 unx      732 b- defN 23-May-03 18:09 archcraftsman/test/__init__.py
--rw-r--r--  2.0 unx    10466 b- defN 23-May-05 19:14 archcraftsman/test/test_base.py
--rw-r--r--  2.0 unx     2858 b- defN 23-May-05 19:14 archcraftsman/test/test_utils.py
--rw-r--r--  2.0 unx    35149 b- defN 23-May-06 19:17 archcraftsman-4.0.1.dist-info/LICENSE.txt
--rw-r--r--  2.0 unx    10484 b- defN 23-May-06 19:17 archcraftsman-4.0.1.dist-info/METADATA
--rw-r--r--  2.0 unx      704 b- defN 23-May-06 19:17 archcraftsman-4.0.1.dist-info/NOTICES
--rw-r--r--  2.0 unx       92 b- defN 23-May-06 19:17 archcraftsman-4.0.1.dist-info/WHEEL
--rw-r--r--  2.0 unx       63 b- defN 23-May-06 19:17 archcraftsman-4.0.1.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       14 b- defN 23-May-06 19:17 archcraftsman-4.0.1.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     5539 b- defN 23-May-06 19:17 archcraftsman-4.0.1.dist-info/RECORD
-64 files, 268795 bytes uncompressed, 90156 bytes compressed:  66.5%
+-rw-r--r--  2.0 unx    12720 b- defN 23-Jun-11 11:10 archcraftsman/test/test_base.py
+-rw-r--r--  2.0 unx     3064 b- defN 23-Jun-11 11:10 archcraftsman/test/test_utils.py
+-rw-r--r--  2.0 unx    35149 b- defN 23-Jun-11 11:17 archcraftsman-4.1.0.dist-info/LICENSE.txt
+-rw-r--r--  2.0 unx    10484 b- defN 23-Jun-11 11:17 archcraftsman-4.1.0.dist-info/METADATA
+-rw-r--r--  2.0 unx      704 b- defN 23-Jun-11 11:17 archcraftsman-4.1.0.dist-info/NOTICES
+-rw-r--r--  2.0 unx       92 b- defN 23-Jun-11 11:17 archcraftsman-4.1.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       63 b- defN 23-Jun-11 11:17 archcraftsman-4.1.0.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       14 b- defN 23-Jun-11 11:17 archcraftsman-4.1.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     5450 b- defN 23-Jun-11 11:17 archcraftsman-4.1.0.dist-info/RECORD
+63 files, 280997 bytes uncompressed, 88960 bytes compressed:  68.3%
```

## zipnote {}

```diff
@@ -21,14 +21,17 @@
 
 Filename: archcraftsman/disk.py
 Comment: 
 
 Filename: archcraftsman/i18n.py
 Comment: 
 
+Filename: archcraftsman/imessages.py
+Comment: 
+
 Filename: archcraftsman/info.py
 Comment: 
 
 Filename: archcraftsman/installer.py
 Comment: 
 
 Filename: archcraftsman/manualpart.py
@@ -69,29 +72,29 @@
 
 Filename: archcraftsman/bundles/cinnamon.py
 Comment: 
 
 Filename: archcraftsman/bundles/copyacm.py
 Comment: 
 
-Filename: archcraftsman/bundles/cups.py
-Comment: 
-
 Filename: archcraftsman/bundles/cutefish.py
 Comment: 
 
 Filename: archcraftsman/bundles/deepin.py
 Comment: 
 
 Filename: archcraftsman/bundles/enlightenment.py
 Comment: 
 
 Filename: archcraftsman/bundles/generateconfig.py
 Comment: 
 
+Filename: archcraftsman/bundles/genericbundle.py
+Comment: 
+
 Filename: archcraftsman/bundles/gnome.py
 Comment: 
 
 Filename: archcraftsman/bundles/grmlzsh.py
 Comment: 
 
 Filename: archcraftsman/bundles/grub.py
@@ -105,35 +108,26 @@
 
 Filename: archcraftsman/bundles/linux.py
 Comment: 
 
 Filename: archcraftsman/bundles/lxqt.py
 Comment: 
 
-Filename: archcraftsman/bundles/mainfilesystems.py
-Comment: 
-
-Filename: archcraftsman/bundles/mainfonts.py
-Comment: 
-
 Filename: archcraftsman/bundles/mate.py
 Comment: 
 
 Filename: archcraftsman/bundles/microcodes.py
 Comment: 
 
 Filename: archcraftsman/bundles/networkmanager.py
 Comment: 
 
 Filename: archcraftsman/bundles/nvidia.py
 Comment: 
 
-Filename: archcraftsman/bundles/pipewire.py
-Comment: 
-
 Filename: archcraftsman/bundles/plasma.py
 Comment: 
 
 Filename: archcraftsman/bundles/sway.py
 Comment: 
 
 Filename: archcraftsman/bundles/systemdnet.py
@@ -150,14 +144,17 @@
 
 Filename: archcraftsman/bundles/yay.py
 Comment: 
 
 Filename: archcraftsman/bundles/zram.py
 Comment: 
 
+Filename: archcraftsman/bundles/configs/__init__.py
+Comment: 
+
 Filename: archcraftsman/locales/__init__.py
 Comment: 
 
 Filename: archcraftsman/locales/french.po
 Comment: 
 
 Filename: archcraftsman/test/__init__.py
@@ -165,29 +162,29 @@
 
 Filename: archcraftsman/test/test_base.py
 Comment: 
 
 Filename: archcraftsman/test/test_utils.py
 Comment: 
 
-Filename: archcraftsman-4.0.1.dist-info/LICENSE.txt
+Filename: archcraftsman-4.1.0.dist-info/LICENSE.txt
 Comment: 
 
-Filename: archcraftsman-4.0.1.dist-info/METADATA
+Filename: archcraftsman-4.1.0.dist-info/METADATA
 Comment: 
 
-Filename: archcraftsman-4.0.1.dist-info/NOTICES
+Filename: archcraftsman-4.1.0.dist-info/NOTICES
 Comment: 
 
-Filename: archcraftsman-4.0.1.dist-info/WHEEL
+Filename: archcraftsman-4.1.0.dist-info/WHEEL
 Comment: 
 
-Filename: archcraftsman-4.0.1.dist-info/entry_points.txt
+Filename: archcraftsman-4.1.0.dist-info/entry_points.txt
 Comment: 
 
-Filename: archcraftsman-4.0.1.dist-info/top_level.txt
+Filename: archcraftsman-4.1.0.dist-info/top_level.txt
 Comment: 
 
-Filename: archcraftsman-4.0.1.dist-info/RECORD
+Filename: archcraftsman-4.1.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## archcraftsman/__main__.py

```diff
@@ -13,10 +13,10 @@
 #
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 Archcraftsman's main entrypoint.
 """
-from archcraftsman import installer
+import archcraftsman.installer
 
-installer.main()
+archcraftsman.installer.main()
```

## archcraftsman/arguments.py

```diff
@@ -13,21 +13,21 @@
 #
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The I18n management singleton module
 """
-from argparse import Namespace
-from typing import Optional
+import argparse
+import typing
 
-_ARGS = Namespace()
+_ARGS = argparse.Namespace()
 
 
-def init(args: Optional[Namespace] = None) -> None:
+def init(args: typing.Optional[argparse.Namespace] = None) -> None:
     """
     Initialize the global arguments.
     """
     if args:
         global _ARGS
         _ARGS = args
     if not hasattr(_ARGS, "install"):
```

## archcraftsman/autopart.py

```diff
@@ -13,258 +13,286 @@
 #
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The automatic partitioning system module
 """
-from archcraftsman import info
-from archcraftsman.base import execute, is_bios, print_step, print_sub_step
-from archcraftsman.disk import Disk
-from archcraftsman.i18n import _
-from archcraftsman.options import FSFormats, PartTypes, SwapTypes
-from archcraftsman.partition import Partition
-from archcraftsman.utils import (
-    ask_drive,
-    ask_format_type,
-    from_iec,
-    prompt_bool,
-    prompt_option,
-    to_iec,
-)
+import archcraftsman.base
+import archcraftsman.disk
+import archcraftsman.i18n
+import archcraftsman.info
+import archcraftsman.options
+import archcraftsman.partition
+import archcraftsman.utils
+
+_ = archcraftsman.i18n.translate
 
 
 def auto_partitioning() -> bool:
     """
     The method to proceed to the automatic partitioning.
     """
     user_answer = False
     while not user_answer:
-        print_step(_("Automatic partitioning :"))
-        execute("fdisk -l", force=True, sudo=True)
-        target_disk = ask_drive()
-        info.ai.partitioning_info.main_disk = target_disk
-        disk = Disk(target_disk)
+        archcraftsman.base.print_step(_("Automatic partitioning :"))
+        archcraftsman.base.execute("fdisk -l", force=True, sudo=True)
+        target_disk = archcraftsman.utils.ask_drive()
+        archcraftsman.info.ai.partitioning_info.main_disk = target_disk
+        disk = archcraftsman.disk.Disk(target_disk)
         efi_partition = disk.get_efi_partition()
         if (
-            not is_bios()
+            not archcraftsman.base.is_bios()
             and len(disk.partitions) > 0
             and efi_partition.path
             and efi_partition.fs_type() == "vfat"
-            and disk.free_space > from_iec("32G")
+            and disk.free_space > archcraftsman.utils.from_iec("32G")
         ):
-            want_dual_boot = prompt_bool(
+            want_dual_boot = archcraftsman.utils.prompt_bool(
                 _("Do you want to install Arch Linux next to other systems ?")
             )
         else:
             want_dual_boot = False
 
-        swap_type = prompt_option(
+        swap_type = archcraftsman.utils.prompt_option(
             _("What type of Swap do you want ? (%s) : "),
             _("Swap type '%s' is not supported."),
-            SwapTypes,
+            archcraftsman.options.SwapTypes,
             supported_msg=_("Supported Swap types : "),
-            default=SwapTypes.FILE,
+            default=archcraftsman.options.SwapTypes.FILE,
         )
 
-        want_home = prompt_bool(_("Do you want a separated Home ?"))
-        part_format_type = ask_format_type()
+        want_home = archcraftsman.utils.prompt_bool(_("Do you want a separated Home ?"))
+        part_format_type = archcraftsman.utils.ask_format_type()
         root_block_name = None
-        if prompt_bool(
+        if archcraftsman.utils.prompt_bool(
             _("Do you want to encrypt the %s partition ?") % "Root", default=False
         ):
             root_block_name = "root"
         home_block_name = None
         if want_home:
-            if prompt_bool(
+            if archcraftsman.utils.prompt_bool(
                 _("Do you want to encrypt the %s partition ?") % "Home", default=False
             ):
                 home_block_name = "home"
 
         if want_dual_boot:
-            root_size = to_iec(int(disk.free_space / 4))
-            swap_size = to_iec(int(disk.free_space / 32))
+            root_size = archcraftsman.utils.to_iec(int(disk.free_space / 4))
+            swap_size = archcraftsman.utils.to_iec(int(disk.free_space / 32))
         else:
-            root_size = to_iec(int(disk.total / 4))
-            swap_size = to_iec(int(disk.total / 32))
-        if swap_type == SwapTypes.NONE:
+            root_size = archcraftsman.utils.to_iec(int(disk.total / 4))
+            swap_size = archcraftsman.utils.to_iec(int(disk.total / 32))
+        if swap_type == archcraftsman.options.SwapTypes.NONE:
             swap_size = ""
-        info.ai.partitioning_info.swapfile_size = swap_size
+        archcraftsman.info.ai.partitioning_info.swapfile_size = swap_size
         auto_part_str = ""
         index = 0
-        if is_bios():
+        if archcraftsman.base.is_bios():
             # DOS LABEL
             auto_part_str += "o\n"  # Create a new empty DOS partition table
             # BOOT
             auto_part_str += "n\n"  # Add a new partition
-            auto_part_str += "p\n"  # Partition primary (Accept default: primary)
-            auto_part_str += " \n"  # Partition number (Accept default: auto)
+            auto_part_str += (
+                "p\n"  # archcraftsman.disk.Partition primary (Accept default: primary)
+            )
+            auto_part_str += (
+                " \n"  # archcraftsman.disk.Partition number (Accept default: auto)
+            )
             auto_part_str += " \n"  # First sector (Accept default: 1)
             auto_part_str += "+2G\n"  # Last sector (Accept default: varies)
             auto_part_str += "a\n"  # Toggle bootable flag
-            info.ai.partitioning_info.partitions.append(
-                Partition(
+            archcraftsman.info.ai.partitioning_info.partitions.append(
+                archcraftsman.partition.Partition(
                     index=index,
-                    part_type=PartTypes.BOOT,
+                    part_type=archcraftsman.options.PartTypes.BOOT,
                     part_mount_point="/boot",
                     part_format=True,
                     part_format_type=part_format_type,
                 )
             )
             index += 1
         else:
             if not want_dual_boot:
                 # GPT LABEL
                 auto_part_str += "g\n"  # Create a new empty GPT partition table
                 # EFI
                 auto_part_str += "n\n"  # Add a new partition
-                auto_part_str += " \n"  # Partition number (Accept default: auto)
+                auto_part_str += (
+                    " \n"  # archcraftsman.disk.Partition number (Accept default: auto)
+                )
                 auto_part_str += " \n"  # First sector (Accept default: 1)
                 auto_part_str += "+512M\n"  # Last sector (Accept default: varies)
                 auto_part_str += "t\n"  # Change partition type
-                auto_part_str += " \n"  # Partition number (Accept default: auto)
+                auto_part_str += (
+                    " \n"  # archcraftsman.disk.Partition number (Accept default: auto)
+                )
                 auto_part_str += "1\n"  # Type EFI System
-                info.ai.partitioning_info.partitions.append(
-                    Partition(
+                archcraftsman.info.ai.partitioning_info.partitions.append(
+                    archcraftsman.partition.Partition(
                         index=index,
-                        part_type=PartTypes.EFI,
+                        part_type=archcraftsman.options.PartTypes.EFI,
                         part_mount_point="/boot/efi",
                         part_format=True,
-                        part_format_type=FSFormats.VFAT,
+                        part_format_type=archcraftsman.options.FSFormats.VFAT,
                     )
                 )
                 index += 1
             else:
-                info.ai.partitioning_info.partitions.append(
-                    Partition(
+                archcraftsman.info.ai.partitioning_info.partitions.append(
+                    archcraftsman.partition.Partition(
                         index=index,
-                        part_type=PartTypes.EFI,
+                        part_type=archcraftsman.options.PartTypes.EFI,
                         part_mount_point="/boot/efi",
                         part_format=False,
                     )
                 )
                 index += len(disk.partitions)
-        if swap_type == SwapTypes.PARTITION:
+        if swap_type == archcraftsman.options.SwapTypes.PARTITION:
             # SWAP
             auto_part_str += "n\n"  # Add a new partition
-            if is_bios():
-                auto_part_str += "p\n"  # Partition primary (Accept default: primary)
-            auto_part_str += " \n"  # Partition number (Accept default: auto)
+            if archcraftsman.base.is_bios():
+                auto_part_str += "p\n"  # archcraftsman.disk.Partition primary (Accept default: primary)
+            auto_part_str += (
+                " \n"  # archcraftsman.disk.Partition number (Accept default: auto)
+            )
             auto_part_str += " \n"  # First sector (Accept default: 1)
             auto_part_str += f"+{swap_size}\n"  # Last sector (Accept default: varies)
             auto_part_str += "t\n"  # Change partition type
-            auto_part_str += " \n"  # Partition number (Accept default: auto)
-            if is_bios():
+            auto_part_str += (
+                " \n"  # archcraftsman.disk.Partition number (Accept default: auto)
+            )
+            if archcraftsman.base.is_bios():
                 auto_part_str += "82\n"  # Type Linux Swap
             else:
                 auto_part_str += "19\n"  # Type Linux Swap
-            info.ai.partitioning_info.partitions.append(
-                Partition(index=index, part_type=PartTypes.SWAP)
+            archcraftsman.info.ai.partitioning_info.partitions.append(
+                archcraftsman.partition.Partition(
+                    index=index, part_type=archcraftsman.options.PartTypes.SWAP
+                )
             )
             index += 1
         if root_block_name and not any(
-            p.part_type == PartTypes.BOOT for p in info.ai.partitioning_info.partitions
+            p.part_type == archcraftsman.options.PartTypes.BOOT
+            for p in archcraftsman.info.ai.partitioning_info.partitions
         ):
             # BOOT
             auto_part_str += "n\n"  # Add a new partition
-            if is_bios():
-                auto_part_str += "p\n"  # Partition primary (Accept default: primary)
-            auto_part_str += " \n"  # Partition number (Accept default: auto)
+            if archcraftsman.base.is_bios():
+                auto_part_str += "p\n"  # archcraftsman.disk.Partition primary (Accept default: primary)
+            auto_part_str += (
+                " \n"  # archcraftsman.disk.Partition number (Accept default: auto)
+            )
             auto_part_str += " \n"  # First sector (Accept default: 1)
             auto_part_str += "+2G\n"  # Last sector (Accept default: varies)
-            info.ai.partitioning_info.partitions.append(
-                Partition(
+            archcraftsman.info.ai.partitioning_info.partitions.append(
+                archcraftsman.partition.Partition(
                     index=index,
-                    part_type=PartTypes.BOOT,
+                    part_type=archcraftsman.options.PartTypes.BOOT,
                     part_mount_point="/boot",
                     part_format=True,
                     part_format_type=part_format_type,
                 )
             )
             index += 1
         if want_home:
             # ROOT
             auto_part_str += "n\n"  # Add a new partition
-            if is_bios():
-                auto_part_str += "p\n"  # Partition primary (Accept default: primary)
-            auto_part_str += " \n"  # Partition number (Accept default: auto)
+            if archcraftsman.base.is_bios():
+                auto_part_str += "p\n"  # archcraftsman.disk.Partition primary (Accept default: primary)
+            auto_part_str += (
+                " \n"  # archcraftsman.disk.Partition number (Accept default: auto)
+            )
             auto_part_str += " \n"  # First sector (Accept default: 1)
             auto_part_str += f"+{root_size}\n"  # Last sector (Accept default: varies)
-            info.ai.partitioning_info.partitions.append(
-                Partition(
+            archcraftsman.info.ai.partitioning_info.partitions.append(
+                archcraftsman.partition.Partition(
                     index=index,
-                    part_type=PartTypes.ROOT,
+                    part_type=archcraftsman.options.PartTypes.ROOT,
                     part_mount_point="/",
                     part_format=True,
                     part_format_type=part_format_type,
                 )
             )
             index += 1
             # HOME
             auto_part_str += "n\n"  # Add a new partition
-            if is_bios():
-                auto_part_str += "p\n"  # Partition primary (Accept default: primary)
-            auto_part_str += " \n"  # Partition number (Accept default: auto)
+            if archcraftsman.base.is_bios():
+                auto_part_str += "p\n"  # archcraftsman.disk.Partition primary (Accept default: primary)
+            auto_part_str += (
+                " \n"  # archcraftsman.disk.Partition number (Accept default: auto)
+            )
             auto_part_str += " \n"  # First sector (Accept default: 1)
             auto_part_str += " \n"  # Last sector (Accept default: varies)
-            info.ai.partitioning_info.partitions.append(
-                Partition(
+            archcraftsman.info.ai.partitioning_info.partitions.append(
+                archcraftsman.partition.Partition(
                     index=index,
-                    part_type=PartTypes.HOME,
+                    part_type=archcraftsman.options.PartTypes.HOME,
                     part_mount_point="/home",
                     part_format=True,
                     part_format_type=part_format_type,
                 )
             )
             index += 1
         else:
             # ROOT
             auto_part_str += "n\n"  # Add a new partition
-            if is_bios():
-                auto_part_str += "p\n"  # Partition primary (Accept default: primary)
-            auto_part_str += " \n"  # Partition number (Accept default: auto)
+            if archcraftsman.base.is_bios():
+                auto_part_str += "p\n"  # archcraftsman.disk.Partition primary (Accept default: primary)
+            auto_part_str += (
+                " \n"  # archcraftsman.disk.Partition number (Accept default: auto)
+            )
             auto_part_str += " \n"  # First sector (Accept default: 1)
             auto_part_str += " \n"  # Last sector (Accept default: varies)
-            info.ai.partitioning_info.partitions.append(
-                Partition(
+            archcraftsman.info.ai.partitioning_info.partitions.append(
+                archcraftsman.partition.Partition(
                     index=index,
-                    part_type=PartTypes.ROOT,
+                    part_type=archcraftsman.options.PartTypes.ROOT,
                     part_mount_point="/",
                     part_format=True,
                     part_format_type=part_format_type,
                 )
             )
             index += 1
         # WRITE
         auto_part_str += "w\n"
 
-        for partition in info.ai.partitioning_info.partitions:
-            if partition.part_type == PartTypes.ROOT and root_block_name is not None:
+        for partition in archcraftsman.info.ai.partitioning_info.partitions:
+            if (
+                partition.part_type == archcraftsman.options.PartTypes.ROOT
+                and root_block_name is not None
+            ):
                 partition.encrypted = True
                 partition.block_name = root_block_name
-            if partition.part_type == PartTypes.HOME and home_block_name is not None:
+            if (
+                partition.part_type == archcraftsman.options.PartTypes.HOME
+                and home_block_name is not None
+            ):
                 partition.encrypted = True
                 partition.block_name = home_block_name
 
-        print_step(_("Summary of choices :"))
-        for partition in info.ai.partitioning_info.partitions:
-            print_sub_step(partition.summary())
-        if swap_type == SwapTypes.FILE and swap_size is not None:
-            print_sub_step(_("Swapfile size : %s") % swap_size)
-        user_answer = prompt_bool(_("Is the information correct ?"), default=False)
+        archcraftsman.base.print_step(_("Summary of choices :"))
+        for partition in archcraftsman.info.ai.partitioning_info.partitions:
+            archcraftsman.base.print_sub_step(partition.summary())
+        if swap_type == archcraftsman.options.SwapTypes.FILE and swap_size is not None:
+            archcraftsman.base.print_sub_step(_("Swapfile size : %s") % swap_size)
+        user_answer = archcraftsman.utils.prompt_bool(
+            _("Is the information correct ?"), default=False
+        )
         if not user_answer:
-            want_to_change = prompt_bool(
+            want_to_change = archcraftsman.utils.prompt_bool(
                 _("Do you want to change the partitioning mode ?"), default=False
             )
             if want_to_change:
                 return False
-            info.ai.partitioning_info.partitions.clear()
+            archcraftsman.info.ai.partitioning_info.partitions.clear()
         else:
-            execute(f'echo -e "{auto_part_str}" | fdisk "{target_disk}" &>/dev/null')
+            archcraftsman.base.execute(
+                f'echo -e "{auto_part_str}" | fdisk "{target_disk}" &>/dev/null'
+            )
 
-            for partition in info.ai.partitioning_info.partitions:
+            for partition in archcraftsman.info.ai.partitioning_info.partitions:
                 partition.build_partition_name(target_disk)
 
-                if partition not in info.ai.partitioning_info.partitions:
-                    info.ai.partitioning_info.partitions.append(partition)
+                if partition not in archcraftsman.info.ai.partitioning_info.partitions:
+                    archcraftsman.info.ai.partitioning_info.partitions.append(partition)
 
     return True
```

## archcraftsman/base.py

```diff
@@ -18,18 +18,20 @@
 The base utility module.
 """
 import encodings
 import getpass
 import glob
 import os
 import subprocess
-from typing import Optional
+import typing
 
-from archcraftsman import arguments
-from archcraftsman.i18n import _
+import archcraftsman.arguments
+import archcraftsman.i18n
+
+_ = archcraftsman.i18n.translate
 
 RED = "\033[0;31m"
 GREEN = "\033[0;32m"
 CYAN = "\033[0;36m"
 ORANGE = "\033[0;33m"
 GRAY = "\033[0;37m"
 NOCOLOR = "\033[0m"
@@ -120,32 +122,40 @@
 
 
 def execute(
     command: str,
     check: bool = True,
     capture_output: bool = False,
     force: bool = False,
+    chroot: bool = False,
     sudo: bool = False,
 ) -> ExecutionResult:
     """
     A method to exec a command.
     """
-    if force or not arguments.test():
-        log(f"Real execution of: {command}")
+    if force or not archcraftsman.arguments.test():
         if sudo and not sudo_exist() and not is_root():
             raise PermissionError("This script must be run as root.")
         if sudo and sudo_exist() and not is_root():
             command = f"sudo {command}"
+
+        if chroot:
+            command = f"arch-chroot /mnt /bin/bash <<END\n{command.strip()}\nEND"
+
         return ExecutionResult(
             command,
             subprocess.run(
                 command, shell=True, check=check, capture_output=capture_output
             ),
         )
-    log(f"Fake execution of: {command}")
+    log(
+        f"{'(chroot) ' if chroot else ''}"
+        f"{'(sudo) ' if sudo else ''}"
+        f"Fake execution of: {command}"
+    )
     return ExecutionResult(
         command, subprocess.CompletedProcess(args=command, returncode=0, stdout=b"")
     )
 
 
 def pause(start_newline: bool = False, end_newline: bool = False):
     """
@@ -185,15 +195,15 @@
     print(f"{CYAN}  * {message}{NOCOLOR}")
 
 
 def log(message: str):
     """
     A method to print a log message.
     """
-    if arguments.test():
+    if archcraftsman.arguments.test():
         print(f"{GRAY}> {message}{NOCOLOR}")
 
 
 def print_help(message: str, do_pause: bool = False):
     """
     A method to print an help message.
     """
@@ -210,16 +220,16 @@
     if password:
         return getpass.getpass(prompt=f"{ORANGE}{message}{NOCOLOR}")
     return input(f"{ORANGE}{message}{NOCOLOR}")
 
 
 def prompt(
     message: str,
-    default: Optional[str] = None,
-    help_msg: Optional[str] = None,
+    default: typing.Optional[str] = None,
+    help_msg: typing.Optional[str] = None,
     required: bool = False,
     password: bool = False,
 ) -> str:
     """
     A method to prompt for a user input.
     """
     user_input_ok = False
@@ -236,16 +246,16 @@
             continue
         user_input_ok = True
     return user_input
 
 
 def prompt_ln(
     message: str,
-    default: Optional[str] = None,
-    help_msg: Optional[str] = None,
+    default: typing.Optional[str] = None,
+    help_msg: typing.Optional[str] = None,
     required: bool = False,
 ) -> str:
     """
     A method to prompt for a user input with a new line for the user input.
     """
     return prompt(
         f"{message}\n> ", default=default, help_msg=help_msg, required=required
```

## archcraftsman/basesetup.py

```diff
@@ -15,153 +15,145 @@
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The system setup module
 """
 import json
 import re
+import subprocess
 import sys
-from subprocess import CalledProcessError
-from urllib.request import urlopen
+import urllib.request
 
-from archcraftsman import arguments, info
-from archcraftsman.base import (
-    elevate,
-    execute,
-    is_bios,
-    print_error,
-    print_step,
-    print_sub_step,
-    prompt_ln,
-)
-from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.bundles.copyacm import CopyACM
-from archcraftsman.bundles.cups import Cups
-from archcraftsman.bundles.grmlzsh import GrmlZsh
-from archcraftsman.bundles.grub import Grub
-from archcraftsman.bundles.mainfilesystems import MainFileSystems, get_main_file_systems
-from archcraftsman.bundles.mainfonts import MainFonts, get_main_fonts
-from archcraftsman.bundles.microcodes import Microcodes
-from archcraftsman.bundles.nvidia import NvidiaDriver
-from archcraftsman.bundles.pipewire import PipeWire
-from archcraftsman.bundles.terminus import TerminusFont
-from archcraftsman.bundles.utils import prompt_bundle
-from archcraftsman.bundles.zram import Zram
-from archcraftsman.config import deserialize
-from archcraftsman.i18n import _
-from archcraftsman.options import (
-    BootLoaders,
-    Bundles,
-    Desktops,
-    Kernels,
-    Languages,
-    Network,
-)
-from archcraftsman.packages import Packages
-from archcraftsman.prelaunchinfo import parse_detected_language
-from archcraftsman.utils import (
-    ask_keymap,
-    ask_password,
-    generate_translations,
-    prompt_bool,
-    prompt_option,
-)
+import archcraftsman.arguments
+import archcraftsman.base
+import archcraftsman.bundles.bundle
+import archcraftsman.bundles.copyacm
+import archcraftsman.bundles.genericbundle
+import archcraftsman.bundles.grmlzsh
+import archcraftsman.bundles.grub
+import archcraftsman.bundles.microcodes
+import archcraftsman.bundles.nvidia
+import archcraftsman.bundles.terminus
+import archcraftsman.bundles.utils
+import archcraftsman.bundles.zram
+import archcraftsman.config
+import archcraftsman.i18n
+import archcraftsman.info
+import archcraftsman.options
+import archcraftsman.packages
+import archcraftsman.prelaunchinfo
+import archcraftsman.utils
+
+_ = archcraftsman.i18n.translate
 
 
 def initial_setup(shell_mode: bool = False):
     """
     The method to get environment configurations from the user.
     """
-    print_sub_step(_("Querying IP geolocation information..."))
-    with urlopen("https://ipapi.co/json") as response:
+    archcraftsman.base.print_sub_step(_("Querying IP geolocation information..."))
+    with urllib.request.urlopen("https://ipapi.co/json") as response:
         geoip_info = json.loads(response.read())
     detected_language = str(geoip_info["languages"]).split(",", maxsplit=1)[0]
     detected_timezone = geoip_info["timezone"]
 
-    default_language = parse_detected_language(detected_language)
+    default_language = archcraftsman.prelaunchinfo.parse_detected_language(
+        detected_language
+    )
 
     if detected_language == "fr-FR":
         default_keymap = "fr-latin9"
     else:
         default_keymap = "de-latin1"
 
-    if not arguments.config():
-        info.ai.pre_launch_info.detected_timezone = detected_timezone
-        info.ai.pre_launch_info.global_language = default_language
-        info.ai.pre_launch_info.keymap = default_keymap
+    if not archcraftsman.arguments.config():
+        archcraftsman.info.ai.pre_launch_info.detected_timezone = detected_timezone
+        archcraftsman.info.ai.pre_launch_info.global_language = default_language
+        archcraftsman.info.ai.pre_launch_info.keymap = default_keymap
 
-    user_answer = shell_mode or arguments.config()
+    user_answer = shell_mode or archcraftsman.arguments.config()
     while not user_answer:
-        print_step(_("Welcome to ArchCraftsman !"))
-        if is_bios():
-            print_error(
+        archcraftsman.base.print_step(_("Welcome to ArchCraftsman !"))
+        if archcraftsman.base.is_bios():
+            archcraftsman.base.print_error(
                 _(
                     "BIOS detected ! The script will act accordingly. Don't forget to select a DOS label type before "
                     "partitioning."
                 )
             )
 
-        print_step(_("Environment configuration : "), clear=False)
+        archcraftsman.base.print_step(_("Environment configuration : "), clear=False)
 
-        global_language = prompt_option(
+        global_language = archcraftsman.utils.prompt_option(
             _("Choose your installation's language (%s) : "),
             _("Global language '%s' is not supported."),
-            Languages,
+            archcraftsman.options.Languages,
             supported_msg=_("Supported languages : "),
             default=default_language,
         )
         if global_language:
-            info.ai.pre_launch_info.global_language = global_language
+            archcraftsman.info.ai.pre_launch_info.global_language = global_language
 
-        info.ai.pre_launch_info.keymap = ask_keymap(default_keymap)
+        archcraftsman.info.ai.pre_launch_info.keymap = archcraftsman.utils.ask_keymap(
+            default_keymap
+        )
 
-        print_step(_("Summary of choices :"), clear=False)
-        print_sub_step(
+        archcraftsman.base.print_step(_("Summary of choices :"), clear=False)
+        archcraftsman.base.print_sub_step(
             _("Your installation's language : %s")
-            % info.ai.pre_launch_info.global_language
-        )
-        print_sub_step(
-            _("Your installation's keymap : %s") % info.ai.pre_launch_info.keymap
+            % archcraftsman.info.ai.pre_launch_info.global_language
         )
-        user_answer = prompt_bool(_("Is the information correct ?"), default=False)
-    generate_translations(info.ai.pre_launch_info.global_language)
+        archcraftsman.base.print_sub_step(
+            _("Your installation's keymap : %s")
+            % archcraftsman.info.ai.pre_launch_info.keymap
+        )
+        user_answer = archcraftsman.utils.prompt_bool(
+            _("Is the information correct ?"), default=False
+        )
+    archcraftsman.utils.generate_translations(
+        archcraftsman.info.ai.pre_launch_info.global_language
+    )
     if not shell_mode:
-        info.ai.pre_launch_info.setup_locale()
+        archcraftsman.info.ai.pre_launch_info.setup_locale()
 
 
 def pre_launch(shell_mode: bool = False):
     """
     A pre-launch steps method.
     """
     try:
-        if not elevate():
-            print_error(_("This script must be run as root."), do_pause=False)
+        if not archcraftsman.base.elevate():
+            archcraftsman.base.print_error(
+                _("This script must be run as root."), do_pause=False
+            )
             sys.exit(1)
 
-        if arguments.config():
-            deserialize(arguments.config())
+        if archcraftsman.arguments.config():
+            archcraftsman.config.deserialize(archcraftsman.arguments.config())
 
-        print_step(_("Running pre-launch steps : "), clear=False)
+        archcraftsman.base.print_step(_("Running pre-launch steps : "), clear=False)
 
         if not shell_mode:
-            execute('sed -i "s|#Color|Color|g" /etc/pacman.conf')
-            execute(
+            archcraftsman.base.execute('sed -i "s|#Color|Color|g" /etc/pacman.conf')
+            archcraftsman.base.execute(
                 'sed -i "s|#ParallelDownloads = 5|ParallelDownloads = 5\\nDisableDownloadTimeout|g" /etc/pacman.conf'
             )
 
-            print_sub_step(_("Synchronising repositories..."))
-            execute("pacman -Sy &>/dev/null")
-            Packages()
+            archcraftsman.base.print_sub_step(_("Synchronising repositories..."))
+            archcraftsman.base.execute("pacman -Sy &>/dev/null")
+            archcraftsman.packages.Packages()
 
         initial_setup(shell_mode)
     except KeyboardInterrupt:
-        print_error(_("Script execution interrupted by the user !"), do_pause=False)
+        archcraftsman.base.print_error(
+            _("Script execution interrupted by the user !"), do_pause=False
+        )
         sys.exit(1)
-    except CalledProcessError as exception:
-        print_error(
+    except subprocess.CalledProcessError as exception:
+        archcraftsman.base.print_error(
             _("A subprocess execution failed ! See the following error: %s")
             % exception,
             do_pause=False,
         )
         sys.exit(1)
     except EOFError:
         sys.exit(1)
@@ -169,174 +161,189 @@
 
 def setup_system():
     """
     The method to get system configurations from the user.
     """
     user_answer = False
     while not user_answer:
-        print_step(_("System configuration : "))
-        info.ai.system_info.hostname = prompt_ln(
+        archcraftsman.base.print_step(_("System configuration : "))
+        archcraftsman.info.ai.system_info.hostname = archcraftsman.base.prompt_ln(
             _("What will be your hostname (archlinux) : "), default="archlinux"
         )
-        info.ai.system_info.bundles = []
+        archcraftsman.info.ai.system_info.bundles = []
 
-        info.ai.system_info.bundles.append(
-            prompt_bundle(
+        archcraftsman.info.ai.system_info.bundles.append(
+            archcraftsman.bundles.utils.prompt_bundle(
                 _("Choose your kernel (%s) : "),
                 _("Kernel '%s' is not supported."),
-                Kernels,
+                archcraftsman.options.Kernels,
                 _("Supported kernels : "),
-                Kernels.CURRENT,
+                archcraftsman.options.Kernels.CURRENT,
             )
         )
 
-        info.ai.system_info.bundles.append(
-            prompt_bundle(
+        archcraftsman.info.ai.system_info.bundles.append(
+            archcraftsman.bundles.utils.prompt_bundle(
                 _("Install a desktop environment ? (%s) : "),
                 _("Desktop environment '%s' is not supported."),
-                Desktops,
+                archcraftsman.options.Desktops,
                 _("Supported desktop environments : "),
-                Desktops.NONE,
+                archcraftsman.options.Desktops.NONE,
             )
         )
 
-        info.ai.system_info.bundles.append(
-            prompt_bundle(
+        archcraftsman.info.ai.system_info.bundles.append(
+            archcraftsman.bundles.utils.prompt_bundle(
                 _("Choose your network stack (%s) : "),
                 _("Network stack '%s' is not supported."),
-                Network,
+                archcraftsman.options.Network,
                 _("Supported network stacks : "),
-                Network.NETWORK_MANAGER,
+                archcraftsman.options.Network.NETWORK_MANAGER,
             )
         )
 
-        if prompt_bool(_("Install proprietary Nvidia driver ?"), default=False):
-            info.ai.system_info.bundles.append(NvidiaDriver(Bundles.NVIDIA))
-
-        if prompt_bool(_("Install terminus console font ?"), default=False):
-            info.ai.system_info.bundles.append(TerminusFont(Bundles.TERMINUS))
+        if archcraftsman.utils.prompt_bool(
+            _("Install proprietary Nvidia driver ?"), default=False
+        ):
+            archcraftsman.info.ai.system_info.bundles.append(
+                archcraftsman.bundles.nvidia.NvidiaDriver()
+            )
 
-        if prompt_bool(_("Install Cups ?"), default=False):
-            info.ai.system_info.bundles.append(Cups(Bundles.CUPS))
+        if archcraftsman.utils.prompt_bool(
+            _("Install terminus console font ?"), default=False
+        ):
+            archcraftsman.info.ai.system_info.bundles.append(
+                archcraftsman.bundles.terminus.TerminusFont()
+            )
 
-        if prompt_bool(
+        if archcraftsman.utils.prompt_bool(
             _("Install ZSH with GRML configuration ?"),
             default=False,
             help_msg=_(
                 "If yes, the script will install the ZSH shell with GRML "
                 "configuration. GRML is a ZSH pre-configuration used by Archlinux's "
                 "live environment."
             ),
         ):
-            info.ai.system_info.bundles.append(GrmlZsh(Bundles.GRML))
-
-        if prompt_bool(
-            _("Install a set of main fonts ?"),
-            default=False,
-            help_msg=_("If yes, the following packages will be installed :\n%s")
-            % " ".join(get_main_fonts()),
-        ):
-            info.ai.system_info.bundles.append(MainFonts(Bundles.MAIN_FONTS))
-
-        if prompt_bool(
-            _("Install main file systems support ?"),
-            default=False,
-            help_msg=_("If yes, the following packages will be installed :\n%s")
-            % " ".join(get_main_file_systems()),
-        ):
-            info.ai.system_info.bundles.append(
-                MainFileSystems(Bundles.MAIN_FILE_SYSTEMS)
+            archcraftsman.info.ai.system_info.bundles.append(
+                archcraftsman.bundles.grmlzsh.GrmlZsh()
             )
 
-        if prompt_bool(
+        if archcraftsman.utils.prompt_bool(
             _("Install and enable ZRAM ?"),
             default=False,
             help_msg=_(
                 "ZRAM is a process to compress datas directly in the RAM instead of moving them in a swap. "
                 "Enabled ZRAM will allow you to compress up to half of your RAM before having to swap. "
                 "This method is more efficient than the swap and do not use your disk but is more CPU demanding. "
                 "ZRAM is fully compatible with a swap, it just has a higher priority."
             ),
         ):
-            info.ai.system_info.bundles.append(Zram(Bundles.ZRAM))
+            archcraftsman.info.ai.system_info.bundles.append(
+                archcraftsman.bundles.zram.Zram()
+            )
 
-        if prompt_bool(
-            _("Install PipeWire ?"),
-            default=False,
-            help_msg=_(
-                "If yes, the PipeWire multimedia framework will be installed "
-                "to manage audio and video capture."
-            ),
+        if archcraftsman.utils.prompt_bool(
+            _("Copy ArchCraftsman to the new system ?"), default=False
         ):
-            info.ai.system_info.bundles.append(PipeWire(Bundles.PIPEWIRE))
+            archcraftsman.info.ai.system_info.bundles.append(
+                archcraftsman.bundles.copyacm.CopyACM()
+            )
 
-        if prompt_bool(_("Copy ArchCraftsman to the new system ?"), default=False):
-            info.ai.system_info.bundles.append(CopyACM(Bundles.COPY_ACM))
+        for generic_bundle_name in archcraftsman.bundles.utils.list_generic_bundles():
+            generic_bundle = archcraftsman.bundles.genericbundle.GenericBundle(
+                generic_bundle_name
+            )
+            if archcraftsman.utils.prompt_bool(
+                generic_bundle.prompt(), default=False, help_msg=generic_bundle.help()
+            ):
+                archcraftsman.info.ai.system_info.bundles.append(generic_bundle)
 
-        default_timezone_file = (
-            f"/usr/share/zoneinfo/{info.ai.pre_launch_info.detected_timezone}"
-        )
-        info.ai.system_info.timezone = prompt_ln(
+        default_timezone_file = f"/usr/share/zoneinfo/{archcraftsman.info.ai.pre_launch_info.detected_timezone}"
+        archcraftsman.info.ai.system_info.timezone = archcraftsman.base.prompt_ln(
             _("Your timezone (%s) : ") % default_timezone_file,
             default=default_timezone_file,
         )
         user_name_pattern = re.compile("^[a-z][-a-z\\d_]*$")
         user_name_ok = False
         while not user_name_ok:
-            info.ai.system_info.user_name = prompt_ln(
+            archcraftsman.info.ai.system_info.user_name = archcraftsman.base.prompt_ln(
                 _(
                     "Would you like to add a user? (type username, leave blank if "
                     "none) : "
                 )
             )
-            if info.ai.system_info.user_name and not user_name_pattern.match(
-                info.ai.system_info.user_name
+            if (
+                archcraftsman.info.ai.system_info.user_name
+                and not user_name_pattern.match(
+                    archcraftsman.info.ai.system_info.user_name
+                )
             ):
-                print_error(_("Invalid user name."))
+                archcraftsman.base.print_error(_("Invalid user name."))
                 continue
             user_name_ok = True
-        info.ai.system_info.user_full_name = ""
-        if info.ai.system_info.user_name:
-            info.ai.system_info.user_full_name = prompt_ln(
+        archcraftsman.info.ai.system_info.user_full_name = ""
+        if archcraftsman.info.ai.system_info.user_name:
+            archcraftsman.info.ai.system_info.user_full_name = archcraftsman.base.prompt_ln(
                 _(
                     "What is the %s's full name (type the entire full name, leave blank if none) : "
                 )
-                % info.ai.system_info.user_name
+                % archcraftsman.info.ai.system_info.user_name
             )
 
-        info.ai.system_info.more_pkgs = Packages().ask_packages()
+        archcraftsman.info.ai.system_info.more_pkgs = (
+            archcraftsman.packages.Packages().ask_packages()
+        )
 
-        print_sub_step(_("%s password configuration : ") % "root")
-        info.ai.system_info.root_password = ask_password(
-            _("Enter the %s password : ") % "root"
+        archcraftsman.base.print_sub_step(_("%s password configuration : ") % "root")
+        archcraftsman.info.ai.system_info.root_password = (
+            archcraftsman.utils.ask_password(_("Enter the %s password : ") % "root")
         )
-        if info.ai.system_info.user_name:
-            print_sub_step(
-                _("%s password configuration : ") % info.ai.system_info.user_name
+        if archcraftsman.info.ai.system_info.user_name:
+            archcraftsman.base.print_sub_step(
+                _("%s password configuration : ")
+                % archcraftsman.info.ai.system_info.user_name
             )
-            info.ai.system_info.user_password = ask_password(
-                _("Enter the %s password : ") % info.ai.system_info.user_name
+            archcraftsman.info.ai.system_info.user_password = (
+                archcraftsman.utils.ask_password(
+                    _("Enter the %s password : ")
+                    % archcraftsman.info.ai.system_info.user_name
+                )
             )
 
-        info.ai.system_info.bundles.append(Grub(BootLoaders.GRUB))
-        info.ai.system_info.bundles.append(Microcodes(Bundles.MICROCODES))
+        archcraftsman.info.ai.system_info.bundles.append(
+            archcraftsman.bundles.grub.Grub()
+        )
+        archcraftsman.info.ai.system_info.bundles.append(
+            archcraftsman.bundles.microcodes.Microcodes()
+        )
 
-        print_step(_("Summary of choices :"))
-        print_sub_step(_("Your hostname : %s") % info.ai.system_info.hostname)
-        for bundle in info.ai.system_info.bundles:
-            if bundle is not None and isinstance(bundle, Bundle):
+        archcraftsman.base.print_step(_("Summary of choices :"))
+        archcraftsman.base.print_sub_step(
+            _("Your hostname : %s") % archcraftsman.info.ai.system_info.hostname
+        )
+        for bundle in archcraftsman.info.ai.system_info.bundles:
+            if bundle is not None and isinstance(
+                bundle, archcraftsman.bundles.bundle.Bundle
+            ):
                 bundle.print_resume()
-        print_sub_step(_("Your timezone : %s") % info.ai.system_info.timezone)
-        if info.ai.system_info.user_name:
-            print_sub_step(
-                _("Additional user name : %s") % info.ai.system_info.user_name
-            )
-            if info.ai.system_info.user_full_name:
-                print_sub_step(
-                    _("User's full name : %s") % info.ai.system_info.user_full_name
+        archcraftsman.base.print_sub_step(
+            _("Your timezone : %s") % archcraftsman.info.ai.system_info.timezone
+        )
+        if archcraftsman.info.ai.system_info.user_name:
+            archcraftsman.base.print_sub_step(
+                _("Additional user name : %s")
+                % archcraftsman.info.ai.system_info.user_name
+            )
+            if archcraftsman.info.ai.system_info.user_full_name:
+                archcraftsman.base.print_sub_step(
+                    _("User's full name : %s")
+                    % archcraftsman.info.ai.system_info.user_full_name
                 )
-        if info.ai.system_info.more_pkgs:
-            print_sub_step(
+        if archcraftsman.info.ai.system_info.more_pkgs:
+            archcraftsman.base.print_sub_step(
                 _("More packages to install : %s")
-                % " ".join(info.ai.system_info.more_pkgs)
+                % " ".join(archcraftsman.info.ai.system_info.more_pkgs)
             )
-        user_answer = prompt_bool(_("Is the information correct ?"), default=False)
+        user_answer = archcraftsman.utils.prompt_bool(
+            _("Is the information correct ?"), default=False
+        )
```

## archcraftsman/config.py

```diff
@@ -19,41 +19,46 @@
 """
 
 
 import json
 import os
 import sys
 
-from archcraftsman import info
-from archcraftsman.arguments import shell, test
-from archcraftsman.base import print_error, print_step, print_sub_step
-from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.bundles.utils import get_bundle_type_by_name
-from archcraftsman.partition import Partition
-from archcraftsman.partitioninginfo import PartitioningInfo
-from archcraftsman.prelaunchinfo import PreLaunchInfo
-from archcraftsman.systeminfo import SystemInfo
+import archcraftsman.arguments
+import archcraftsman.base
+import archcraftsman.bundles.bundle
+import archcraftsman.bundles.utils
+import archcraftsman.info
+import archcraftsman.partition
+import archcraftsman.partitioninginfo
+import archcraftsman.prelaunchinfo
+import archcraftsman.systeminfo
 
 
 def serialize():
     """
     Serialize the GlobalInfo object to a json file.
     """
     json_str = json.dumps(
-        info.ai, default=lambda o: o.__dict__, sort_keys=True, indent=2
+        archcraftsman.info.ai,
+        default=lambda o: {
+            k: v for (k, v) in o.__dict__.items() if not k.startswith("_")
+        },
+        sort_keys=True,
+        indent=2,
     )
     file_path = (
-        f"/mnt/home/{info.ai.system_info.user_name}/{info.ai.system_info.hostname}.json"
-        if info.ai.system_info.user_name
-        else f"/mnt/root/{info.ai.system_info.hostname}.json"
+        f"/mnt/home/{archcraftsman.info.ai.system_info.user_name}/{archcraftsman.info.ai.system_info.hostname}.json"
+        if archcraftsman.info.ai.system_info.user_name
+        else f"/mnt/root/{archcraftsman.info.ai.system_info.hostname}.json"
     )
     file_path = (
         file_path
-        if not test() and not shell()
-        else f"{info.ai.system_info.hostname}.json"
+        if not archcraftsman.arguments.test() and not archcraftsman.arguments.shell()
+        else f"{archcraftsman.info.ai.system_info.hostname}.json"
     )
     if os.path.exists(file_path):
         with open(file_path, "w", encoding="UTF-8") as file:
             file.write(json_str)
 
 
 def dict_to_obj(dict_obj, class_type):
@@ -65,91 +70,99 @@
         if isinstance(value, dict):
             value = dict_to_obj(value, class_type)
         if hasattr(obj, key):
             setattr(obj, key, value)
     return obj
 
 
-def dict_to_bundle(dict_obj) -> Bundle:
+def dict_to_bundle(dict_obj) -> archcraftsman.bundles.bundle.Bundle:
     """
     Convert a dict to a bundle object.
     """
-    bundle = get_bundle_type_by_name(dict_obj["name"])(dict_obj["name"])
+    bundle = archcraftsman.bundles.utils.get_bundle_type_by_name(dict_obj["name"])(
+        dict_obj["name"]
+    )
     for key, value in dict_obj.items():
         if hasattr(bundle, key):
             setattr(bundle, key, value)
     return bundle
 
 
-def dict_to_partition(dict_obj) -> Partition:
+def dict_to_partition(dict_obj) -> archcraftsman.partition.Partition:
     """
     Convert a dict to a partition object.
     """
-    partition = Partition()
+    partition = archcraftsman.partition.Partition()
     for key, value in dict_obj.items():
         if hasattr(partition, key):
             setattr(partition, key, value)
     return partition
 
 
 def validate(data: dict, model_object):
     """
     Validate a config file.
     """
     for key, value in data.items():
-        print_sub_step(f"Validating {key}...")
+        archcraftsman.base.print_sub_step(f"Validating {key}...")
         if not hasattr(model_object, key):
-            print_error(f"{key} is not a valid key.", do_pause=False)
+            archcraftsman.base.print_error(f"{key} is not a valid key.", do_pause=False)
             sys.exit(1)
         model_value = getattr(model_object, key)
         if isinstance(value, dict):
             validate(value, model_value)
             continue
         if isinstance(value, list) and len(model_value) > 0:
             for i, item in enumerate(value):
                 if isinstance(item, dict):
                     validate(item, model_value[i])
             continue
         model_value_type = type(model_value)
         if not isinstance(value, model_value_type) and not issubclass(
             model_value_type, type(value)
         ):
-            print_error(
+            archcraftsman.base.print_error(
                 f"{key} is not a valid key. {key} should be {model_value_type}",
                 do_pause=False,
             )
             sys.exit(1)
 
 
 def deserialize(file_path: str):
     """
     Deserialize a json config file.
     """
     if not file_path:
-        print_error("Config file path is empty.")
+        archcraftsman.base.print_error("Config file path is empty.")
         sys.exit(1)
     if not file_path.endswith(".json"):
-        print_error(f"{file_path} is not a json file.")
+        archcraftsman.base.print_error(f"{file_path} is not a json file.")
         sys.exit(1)
-    print_step("Deserializing config file...", clear=False)
+    archcraftsman.base.print_step("Deserializing config file...", clear=False)
     with open(file_path, "r", encoding="UTF-8") as file:
         data = json.loads(file.read())
-        info.ai.pre_launch_info = dict_to_obj(data["pre_launch_info"], PreLaunchInfo)
+        archcraftsman.info.ai.pre_launch_info = dict_to_obj(
+            data["pre_launch_info"], archcraftsman.prelaunchinfo.PreLaunchInfo
+        )
 
-        info.ai.partitioning_info = dict_to_obj(
-            data["partitioning_info"], PartitioningInfo
+        archcraftsman.info.ai.partitioning_info = dict_to_obj(
+            data["partitioning_info"], archcraftsman.partitioninginfo.PartitioningInfo
         )
-        info.ai.partitioning_info.partitions = []
+        archcraftsman.info.ai.partitioning_info.partitions = []
         for bundle in data["partitioning_info"]["partitions"]:
-            info.ai.partitioning_info.partitions.append(dict_to_partition(bundle))
+            archcraftsman.info.ai.partitioning_info.partitions.append(
+                dict_to_partition(bundle)
+            )
 
-        info.ai.system_info = dict_to_obj(data["system_info"], SystemInfo)
-        info.ai.system_info.bundles = []
+        archcraftsman.info.ai.system_info = dict_to_obj(
+            data["system_info"], archcraftsman.systeminfo.SystemInfo
+        )
+        archcraftsman.info.ai.system_info.bundles = []
         for bundle in data["system_info"]["bundles"]:
-            info.ai.system_info.bundles.append(dict_to_bundle(bundle))
-    print_step("Validating config file...", clear=False)
-    fake = info.AllInfo()
-    for partition in info.ai.partitioning_info.partitions:
+            archcraftsman.info.ai.system_info.bundles.append(dict_to_bundle(bundle))
+    archcraftsman.base.print_step("Validating config file...", clear=False)
+    fake = archcraftsman.info.AllInfo()
+    for partition in archcraftsman.info.ai.partitioning_info.partitions:
         fake.partitioning_info.partitions.append(type(partition)())
-    for bundle in info.ai.system_info.bundles:
+    for bundle in archcraftsman.info.ai.system_info.bundles:
         fake.system_info.bundles.append(type(bundle)())
     validate(data, fake)
```

## archcraftsman/disk.py

```diff
@@ -15,118 +15,126 @@
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The disk class module
 """
 import re
 
-from archcraftsman.base import execute, print_error, prompt
-from archcraftsman.i18n import _
-from archcraftsman.options import FSFormats, PartTypes
-from archcraftsman.partition import Partition
-from archcraftsman.utils import to_iec
+import archcraftsman.base
+import archcraftsman.i18n
+import archcraftsman.options
+import archcraftsman.partition
+import archcraftsman.utils
+
+_ = archcraftsman.i18n.translate
 
 
 class Disk:
     """
     A class to represent a disk.
     """
 
     path: str
-    partitions: list[Partition]
+    partitions: list[archcraftsman.partition.Partition]
     total: int
     free_space: int
 
     def __init__(self, path: str):
         """
         Disk initialisation.
         """
         self.path = path
-        detected_partitions = execute(
+        detected_partitions = archcraftsman.base.execute(
             f'lsblk -nl "{path}" -o PATH,TYPE,PARTTYPENAME | grep part | grep -iE "linux|efi|swap"',
             force=True,
             check=False,
             capture_output=True,
         ).output
         self.partitions = []
         index = 0
         for partition_info in detected_partitions.splitlines():
-            self.partitions.append(Partition(index, partition_info.split(" ")[0]))
+            self.partitions.append(
+                archcraftsman.partition.Partition(index, partition_info.split(" ")[0])
+            )
             index += 1
         self.total = int(
-            execute(
+            archcraftsman.base.execute(
                 f'lsblk -b --output SIZE -n -d "{self.path}"',
                 force=True,
                 capture_output=True,
             ).output
         )
         if len(self.partitions) > 0:
             sector_size = int(
                 re.sub(
                     "\\s",
                     "",
-                    execute(
+                    archcraftsman.base.execute(
                         f"lsblk {path} -o PATH,TYPE,PHY-SEC | grep disk | awk '{{print $3}}'",
                         force=True,
                         capture_output=True,
                     ).output,
                 )
             )
             last_partition_path = [p.path for p in self.partitions][
                 len(self.partitions) - 1
             ]
             last_sector = int(
                 re.sub(
                     "\\s",
                     "",
-                    execute(
+                    archcraftsman.base.execute(
                         f"fdisk -l | grep {last_partition_path} | awk '{{print $3}}'",
                         force=True,
                         capture_output=True,
                         sudo=True,
                     ).output,
                 )
             )
             self.free_space = self.total - (last_sector * sector_size)
         else:
             self.free_space = self.total
 
-    def get_efi_partition(self) -> Partition:
+    def get_efi_partition(self) -> archcraftsman.partition.Partition:
         """
         The Disk method to get the EFI partition if it exist. Else return an empty partition object.
         """
         try:
-            return [p for p in self.partitions if p.part_type == PartTypes.EFI].pop()
+            return [
+                p
+                for p in self.partitions
+                if p.part_type == archcraftsman.options.PartTypes.EFI
+            ].pop()
         except IndexError:
-            return Partition(
-                part_type=PartTypes.EFI,
-                part_format_type=FSFormats.VFAT,
+            return archcraftsman.partition.Partition(
+                part_type=archcraftsman.options.PartTypes.EFI,
+                part_format_type=archcraftsman.options.FSFormats.VFAT,
                 part_mount_point="/boot/efi",
             )
 
     def ask_swapfile_size(self) -> str:
         """
         The method to ask the user for the swapfile size.
         """
         swapfile_ok = False
         swapfile_size = ""
         swapfile_size_pattern = re.compile("^(\\d*[.,]\\d+|\\d+)([GMk])$")
-        default_swapfile_size = to_iec(int(self.total / 32))
+        default_swapfile_size = archcraftsman.utils.to_iec(int(self.total / 32))
         while not swapfile_ok:
-            swapfile_size = prompt(
+            swapfile_size = archcraftsman.base.prompt(
                 _("Swapfile size ? (%s, type '0' for none) : ") % default_swapfile_size,
                 default=default_swapfile_size,
             )
             if swapfile_size == "0":
                 swapfile_size = ""
                 swapfile_ok = True
             elif swapfile_size_pattern.match(swapfile_size):
                 swapfile_ok = True
             else:
-                print_error("Invalid swapfile size.")
+                archcraftsman.base.print_error("Invalid swapfile size.")
         return swapfile_size
 
     def __str__(self) -> str:
         """
         Disk str formatting
         """
         return "\n".join([str(p) for p in self.partitions])
```

## archcraftsman/i18n.py

```diff
@@ -15,33 +15,33 @@
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The I18n management singleton module
 """
 import gettext
 
-from archcraftsman.options import Languages
+import archcraftsman.options
 
 _I18N_METHOD = gettext.gettext
 
 
 def update_method(global_language: str):
     """
     Update the translation method to use according to the global language.
     """
 
-    if global_language != Languages.ENGLISH:
+    if global_language != archcraftsman.options.Languages.ENGLISH:
         translation = gettext.translation(
             "archcraftsman",
             localedir="/usr/share/locale",
             languages=[global_language],
         )
         translation.install()
         global _I18N_METHOD
         _I18N_METHOD = translation.gettext
 
 
-def _(message) -> str:
+def translate(message) -> str:
     """
     Translate the given text with the translation method.
     """
     return _I18N_METHOD(message)
```

## archcraftsman/info.py

```diff
@@ -15,24 +15,30 @@
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The config related methods module
 """
 
 
-from archcraftsman.partitioninginfo import PartitioningInfo
-from archcraftsman.prelaunchinfo import PreLaunchInfo
-from archcraftsman.systeminfo import SystemInfo
+import archcraftsman.partitioninginfo
+import archcraftsman.prelaunchinfo
+import archcraftsman.systeminfo
 
 
 class AllInfo:
     """
     The singleton implementation containing the translation method to use.
     """
 
     def __init__(self) -> None:
-        self.pre_launch_info: PreLaunchInfo = PreLaunchInfo()
-        self.partitioning_info: PartitioningInfo = PartitioningInfo()
-        self.system_info: SystemInfo = SystemInfo()
+        self.pre_launch_info: archcraftsman.prelaunchinfo.PreLaunchInfo = (
+            archcraftsman.prelaunchinfo.PreLaunchInfo()
+        )
+        self.partitioning_info: archcraftsman.partitioninginfo.PartitioningInfo = (
+            archcraftsman.partitioninginfo.PartitioningInfo()
+        )
+        self.system_info: archcraftsman.systeminfo.SystemInfo = (
+            archcraftsman.systeminfo.SystemInfo()
+        )
 
 
 ai = AllInfo()
```

## archcraftsman/installer.py

```diff
@@ -15,64 +15,62 @@
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The ArchCraftsman installer.
 """
 import argparse
 import readline
+import subprocess
 import sys
-from subprocess import CalledProcessError
 
-from archcraftsman import arguments, config, i18n, info
-from archcraftsman.autopart import auto_partitioning
-from archcraftsman.base import (
-    execute,
-    glob_completer,
-    print_error,
-    print_step,
-    print_sub_step,
-)
-from archcraftsman.basesetup import pre_launch, setup_system
-from archcraftsman.i18n import _
-from archcraftsman.manualpart import manual_partitioning
-from archcraftsman.options import Desktops, FSFormats, Languages, PartTypes
-from archcraftsman.shell import shell
-from archcraftsman.utils import prompt_bool
+import archcraftsman.arguments
+import archcraftsman.autopart
+import archcraftsman.base
+import archcraftsman.basesetup
+import archcraftsman.config
+import archcraftsman.i18n
+import archcraftsman.info
+import archcraftsman.manualpart
+import archcraftsman.options
+import archcraftsman.shell
+import archcraftsman.utils
+
+_ = archcraftsman.i18n.translate
 
 
 def install():
     """
     The main installation method.
     """
     try:
-        if not arguments.config():
-            setup_system()
+        if not archcraftsman.arguments.config():
+            archcraftsman.basesetup.setup_system()
 
-        partitioning_info_ok: bool = bool(arguments.config())
+        partitioning_info_ok: bool = bool(archcraftsman.arguments.config())
         while not partitioning_info_ok:
-            print_step(_("Partitioning :"))
-            want_auto_part = prompt_bool(
+            archcraftsman.base.print_step(_("Partitioning :"))
+            want_auto_part = archcraftsman.utils.prompt_bool(
                 _("Do you want an automatic partitioning ?"), default=False
             )
             if want_auto_part:
-                partitioning_info_ok = auto_partitioning()
+                partitioning_info_ok = archcraftsman.autopart.auto_partitioning()
             else:
-                partitioning_info_ok = manual_partitioning()
+                partitioning_info_ok = archcraftsman.manualpart.manual_partitioning()
 
-        info.ai.partitioning_info.format_and_mount_partitions()
+        archcraftsman.info.ai.partitioning_info.format_and_mount_partitions()
 
-        print_step(_("Updating mirrors..."), clear=False)
-        execute(
+        archcraftsman.base.print_step(_("Updating mirrors..."), clear=False)
+        archcraftsman.base.execute(
             "reflector --verbose -phttps -f10 -l10 --sort rate -a2 --save /etc/pacman.d/mirrorlist"
         )
 
         base_pkgs = set()
         base_pkgs.update(["base", "base-devel", "linux-firmware"])
 
-        base_pkgs.update(info.ai.system_info.kernel().packages())
+        base_pkgs.update(archcraftsman.info.ai.system_info.kernel().packages())
 
         pkgs = set()
         pkgs.update(
             [
                 "man-db",
                 "man-pages",
                 "texinfo",
@@ -87,169 +85,207 @@
                 "numlockx",
                 "net-tools",
                 "polkit",
                 "pacman-contrib",
             ]
         )
 
-        if info.ai.pre_launch_info.global_language.lower() != "en" and execute(
-            f"pacman -Si man-pages-{info.ai.pre_launch_info.global_language.lower()} &>/dev/null",
+        if archcraftsman.info.ai.pre_launch_info.global_language.lower() != "en" and archcraftsman.base.execute(
+            f"pacman -Si man-pages-{archcraftsman.info.ai.pre_launch_info.global_language.lower()} &>/dev/null",
             check=False,
         ):
-            pkgs.add(f"man-pages-{info.ai.pre_launch_info.global_language.lower()}")
+            pkgs.add(
+                f"man-pages-{archcraftsman.info.ai.pre_launch_info.global_language.lower()}"
+            )
 
-        if info.ai.partitioning_info.btrfs_in_use:
+        if archcraftsman.info.ai.partitioning_info.btrfs_in_use:
             pkgs.add("btrfs-progs")
 
-        for bundle in info.ai.system_info.bundles:
+        for bundle in archcraftsman.info.ai.system_info.bundles:
             pkgs.update(bundle.packages())
 
-        if len(info.ai.system_info.more_pkgs) > 0:
-            pkgs.update(info.ai.system_info.more_pkgs)
+        if len(archcraftsman.info.ai.system_info.more_pkgs) > 0:
+            pkgs.update(archcraftsman.info.ai.system_info.more_pkgs)
 
-        print_step(_("Installation of the base..."), clear=False)
-        execute(f'pacstrap -K /mnt {" ".join(base_pkgs)}')
+        archcraftsman.base.print_step(_("Installation of the base..."), clear=False)
+        archcraftsman.base.execute(f'pacstrap -K /mnt {" ".join(base_pkgs)}')
 
-        print_step(_("System configuration..."), clear=False)
-        execute('sed -i "s|#en_US.UTF-8 UTF-8|en_US.UTF-8 UTF-8|g" /mnt/etc/locale.gen')
-        execute('sed -i "s|#en_US ISO-8859-1|en_US ISO-8859-1|g" /mnt/etc/locale.gen')
-        if info.ai.pre_launch_info.global_language == Languages.FRENCH:
-            execute(
+        archcraftsman.base.print_step(_("System configuration..."), clear=False)
+        archcraftsman.base.execute(
+            'sed -i "s|#en_US.UTF-8 UTF-8|en_US.UTF-8 UTF-8|g" /mnt/etc/locale.gen'
+        )
+        archcraftsman.base.execute(
+            'sed -i "s|#en_US ISO-8859-1|en_US ISO-8859-1|g" /mnt/etc/locale.gen'
+        )
+        if (
+            archcraftsman.info.ai.pre_launch_info.global_language
+            == archcraftsman.options.Languages.FRENCH
+        ):
+            archcraftsman.base.execute(
                 'sed -i "s|#fr_FR.UTF-8 UTF-8|fr_FR.UTF-8 UTF-8|g" /mnt/etc/locale.gen'
             )
-            execute(
+            archcraftsman.base.execute(
                 'sed -i "s|#fr_FR ISO-8859-1|fr_FR ISO-8859-1|g" /mnt/etc/locale.gen'
             )
-            execute('echo "LANG=fr_FR.UTF-8" >/mnt/etc/locale.conf')
+            archcraftsman.base.execute('echo "LANG=fr_FR.UTF-8" >/mnt/etc/locale.conf')
         else:
-            execute('echo "LANG=en_US.UTF-8" >/mnt/etc/locale.conf')
-        execute(
-            f'echo "KEYMAP={info.ai.pre_launch_info.keymap}" >/mnt/etc/vconsole.conf'
+            archcraftsman.base.execute('echo "LANG=en_US.UTF-8" >/mnt/etc/locale.conf')
+        archcraftsman.base.execute(
+            f'echo "KEYMAP={archcraftsman.info.ai.pre_launch_info.keymap}" >/mnt/etc/vconsole.conf'
         )
-        execute(f'echo "{info.ai.system_info.hostname}" >/mnt/etc/hostname')
-        execute(
+        _hostname = archcraftsman.info.ai.system_info.hostname
+        archcraftsman.base.execute(f'echo "{_hostname}" >/mnt/etc/hostname')
+        archcraftsman.base.execute(
             f"""
             {{
                 echo "127.0.0.1 localhost"
                 echo "::1 localhost"
-                echo "127.0.1.1 {info.ai.system_info.hostname}.localdomain {info.ai.system_info.hostname}"
+                echo "127.0.1.1 {_hostname}.localdomain {_hostname}"
             }} >>/mnt/etc/hosts
-        """
+            """
+        )
+        archcraftsman.base.execute(
+            "cp /etc/pacman.d/mirrorlist /mnt/etc/pacman.d/mirrorlist"
         )
-        execute("cp /etc/pacman.d/mirrorlist /mnt/etc/pacman.d/mirrorlist")
 
-        print_step(_("Locales configuration..."), clear=False)
-        execute(
-            f'arch-chroot /mnt bash -c "ln -sf {info.ai.system_info.timezone} /etc/localtime"'
+        archcraftsman.base.print_step(_("Locales configuration..."), clear=False)
+        archcraftsman.base.execute(
+            f"ln -sf {archcraftsman.info.ai.system_info.timezone} /etc/localtime",
+            chroot=True,
         )
-        execute('arch-chroot /mnt bash -c "locale-gen"')
+        archcraftsman.base.execute("locale-gen", chroot=True)
 
-        print_step(_("Installation of the remaining packages..."), clear=False)
-        execute('sed -i "s|#Color|Color|g" /mnt/etc/pacman.conf')
-        execute(
+        archcraftsman.base.print_step(
+            _("Installation of the remaining packages..."), clear=False
+        )
+        archcraftsman.base.execute('sed -i "s|#Color|Color|g" /mnt/etc/pacman.conf')
+        archcraftsman.base.execute(
             'sed -i "s|#ParallelDownloads = 5|ParallelDownloads = 5\\nDisableDownloadTimeout|g" /mnt/etc/pacman.conf'
         )
-        execute('arch-chroot /mnt bash -c "pacman --noconfirm -Sy archlinux-keyring"')
-        execute('arch-chroot /mnt bash -c "pacman --noconfirm -Su"')
-        execute(f'arch-chroot /mnt bash -c "pacman --noconfirm -S {" ".join(pkgs)}"')
+        archcraftsman.base.execute(
+            "pacman --noconfirm -Sy archlinux-keyring", chroot=True
+        )
+        archcraftsman.base.execute("pacman --noconfirm -Su", chroot=True)
+        archcraftsman.base.execute(
+            f'pacman --noconfirm -S {" ".join(pkgs)}', chroot=True
+        )
 
         if (
-            PartTypes.SWAP
-            not in [part.part_type for part in info.ai.partitioning_info.partitions]
-            and info.ai.partitioning_info.swapfile_size
+            archcraftsman.options.PartTypes.SWAP
+            not in [
+                part.part_type
+                for part in archcraftsman.info.ai.partitioning_info.partitions
+            ]
+            and archcraftsman.info.ai.partitioning_info.swapfile_size
         ):
-            print_step(_("Creation and activation of the swapfile..."), clear=False)
+            archcraftsman.base.print_step(
+                _("Creation and activation of the swapfile..."), clear=False
+            )
             if (
-                info.ai.partitioning_info.root_partition().part_format_type
-                == FSFormats.BTRFS
+                archcraftsman.info.ai.partitioning_info.root_partition().part_format_type
+                == archcraftsman.options.FSFormats.BTRFS
             ):
-                execute(
+                archcraftsman.base.execute(
                     "btrfs subvolume create /mnt/swap && "
                     "cd /mnt/swap && "
                     "truncate -s 0 ./swapfile && "
                     "chattr +C ./swapfile && "
                     "btrfs property set ./swapfile compression none && "
                     "cd -"
                 )
             else:
-                execute("mkdir -p /mnt/swap")
-            execute(
-                f'fallocate -l "{info.ai.partitioning_info.swapfile_size}" /mnt/swap/swapfile'
+                archcraftsman.base.execute("mkdir -p /mnt/swap")
+            archcraftsman.base.execute(
+                f'fallocate -l "{archcraftsman.info.ai.partitioning_info.swapfile_size}" /mnt/swap/swapfile'
             )
-            execute("chmod 600 /mnt/swap/swapfile")
-            execute("mkswap /mnt/swap/swapfile")
-            execute("swapon /mnt/swap/swapfile")
-
-        print_step(_("Generating fstab..."), clear=False)
-        execute("genfstab -U /mnt >>/mnt/etc/fstab")
-
-        if info.ai.system_info.desktop().name != Desktops.NONE:
-            print_step(_("Desktop configuration..."), clear=False)
-            info.ai.system_info.desktop().configure()
-
-        print_step(_("Network configuration..."), clear=False)
-        info.ai.system_info.network().configure()
-
-        execute('arch-chroot /mnt bash -c "systemctl enable systemd-timesyncd"')
-
-        print_step(_("Installation and configuration of the grub..."), clear=False)
-        info.ai.system_info.bootloader().configure()
-
-        print_step(_("Users configuration..."), clear=False)
-        print_sub_step(_("Root account configuration..."))
-        if info.ai.system_info.root_password:
-            execute(
-                f"arch-chroot /mnt bash -c \"echo 'root:{info.ai.system_info.root_password}' | chpasswd\""
+            archcraftsman.base.execute("chmod 600 /mnt/swap/swapfile")
+            archcraftsman.base.execute("mkswap /mnt/swap/swapfile")
+            archcraftsman.base.execute("swapon /mnt/swap/swapfile")
+
+        archcraftsman.base.print_step(_("Generating fstab..."), clear=False)
+        archcraftsman.base.execute("genfstab -U /mnt >>/mnt/etc/fstab")
+
+        if (
+            archcraftsman.info.ai.system_info.desktop().name
+            != archcraftsman.options.Desktops.NONE
+        ):
+            archcraftsman.base.print_step(_("Desktop configuration..."), clear=False)
+            archcraftsman.info.ai.system_info.desktop().configure()
+
+        archcraftsman.base.print_step(_("Network configuration..."), clear=False)
+        archcraftsman.info.ai.system_info.network().configure()
+
+        archcraftsman.base.execute("systemctl enable systemd-timesyncd", chroot=True)
+
+        archcraftsman.base.print_step(
+            _("Installation and configuration of the grub..."), clear=False
+        )
+        archcraftsman.info.ai.system_info.bootloader().configure()
+
+        archcraftsman.base.print_step(_("Users configuration..."), clear=False)
+        archcraftsman.base.print_sub_step(_("Root account configuration..."))
+        if archcraftsman.info.ai.system_info.root_password:
+            archcraftsman.base.execute(
+                f"echo 'root:{archcraftsman.info.ai.system_info.root_password}' | chpasswd",
+                chroot=True,
             )
-        if info.ai.system_info.user_name:
-            print_sub_step(
-                _("%s account configuration...") % info.ai.system_info.user_name
+        if archcraftsman.info.ai.system_info.user_name:
+            archcraftsman.base.print_sub_step(
+                _("%s account configuration...")
+                % archcraftsman.info.ai.system_info.user_name
             )
-            execute(
+            archcraftsman.base.execute(
                 'sed -i "s|# %wheel ALL=(ALL:ALL) ALL|%wheel ALL=(ALL:ALL) ALL|g" /mnt/etc/sudoers'
             )
-            execute(
-                f'arch-chroot /mnt bash -c "useradd --shell=/bin/bash --groups=wheel '
-                f'--create-home {info.ai.system_info.user_name}"'
+            archcraftsman.base.execute(
+                f"useradd --shell=/bin/bash --groups=wheel "
+                f"--create-home {archcraftsman.info.ai.system_info.user_name}",
+                chroot=True,
             )
-            if info.ai.system_info.user_full_name:
-                execute(
-                    f"arch-chroot /mnt bash -c "
-                    f"\"chfn -f '{info.ai.system_info.user_full_name}' {info.ai.system_info.user_name}\""
+            if archcraftsman.info.ai.system_info.user_full_name:
+                archcraftsman.base.execute(
+                    f"chfn -f '{archcraftsman.info.ai.system_info.user_full_name}' "
+                    f"{archcraftsman.info.ai.system_info.user_name}",
+                    chroot=True,
                 )
-            if info.ai.system_info.user_password:
-                execute(
-                    f"arch-chroot /mnt bash -c \"echo '{info.ai.system_info.user_name}:"
-                    f"{info.ai.system_info.user_password}' | chpasswd\""
+            if archcraftsman.info.ai.system_info.user_password:
+                archcraftsman.base.execute(
+                    f"echo '{archcraftsman.info.ai.system_info.user_name}:"
+                    f"{archcraftsman.info.ai.system_info.user_password}' | chpasswd",
+                    chroot=True,
                 )
 
-        print_step(_("Extra packages configuration if needed..."), clear=False)
-        for bundle in info.ai.system_info.others():
+        archcraftsman.base.print_step(
+            _("Extra packages configuration if needed..."), clear=False
+        )
+        for bundle in archcraftsman.info.ai.system_info.others():
             bundle.configure()
 
-        config.serialize()
-        info.ai.partitioning_info.umount_partitions()
+        archcraftsman.config.serialize()
+        archcraftsman.info.ai.partitioning_info.umount_partitions()
 
-        print_step(
+        archcraftsman.base.print_step(
             _("Installation complete ! You can reboot your system."), clear=False
         )
 
     except KeyboardInterrupt:
-        print_error(_("Script execution interrupted by the user !"), do_pause=False)
-        config.serialize()
-        info.ai.partitioning_info.umount_partitions()
+        archcraftsman.base.print_error(
+            _("Script execution interrupted by the user !"), do_pause=False
+        )
+        archcraftsman.config.serialize()
+        archcraftsman.info.ai.partitioning_info.umount_partitions()
         sys.exit(1)
-    except CalledProcessError as exception:
-        print_error(
+    except subprocess.CalledProcessError as exception:
+        archcraftsman.base.print_error(
             _("A subprocess execution failed ! See the following error: %s")
             % exception,
             do_pause=False,
         )
-        config.serialize()
-        info.ai.partitioning_info.umount_partitions()
+        archcraftsman.config.serialize()
+        archcraftsman.info.ai.partitioning_info.umount_partitions()
         sys.exit(1)
     except EOFError:
         sys.exit(1)
 
 
 def main():
     """
@@ -282,32 +318,36 @@
         "-t",
         "--test",
         action="store_const",
         const=True,
         default=False,
         help="Used to test the installer. No destructive commands will be executed.",
     )
-    arguments.init(parser.parse_args())
+    archcraftsman.arguments.init(parser.parse_args())
 
     readline.set_completer_delims(" \t\n;")
     readline.parse_and_bind("tab: complete")
-    readline.set_completer(glob_completer)
+    readline.set_completer(archcraftsman.base.glob_completer)
 
-    if not arguments.is_call_ok():
+    if not archcraftsman.arguments.is_call_ok():
         parser.print_help()
         sys.exit(1)
 
-    if arguments.install():
-        pre_launch()
-        i18n.update_method(info.ai.pre_launch_info.global_language)
+    if archcraftsman.arguments.install():
+        archcraftsman.basesetup.pre_launch()
+        archcraftsman.i18n.update_method(
+            archcraftsman.info.ai.pre_launch_info.global_language
+        )
         install()
         sys.exit(0)
 
-    if arguments.shell():
-        pre_launch(shell_mode=True)
-        i18n.update_method(info.ai.pre_launch_info.global_language)
-        shell()
+    if archcraftsman.arguments.shell():
+        archcraftsman.basesetup.pre_launch(shell_mode=True)
+        archcraftsman.i18n.update_method(
+            archcraftsman.info.ai.pre_launch_info.global_language
+        )
+        archcraftsman.shell.shell()
         sys.exit(0)
 
 
 if __name__ == "__main__":
     main()
```

## archcraftsman/manualpart.py

```diff
@@ -13,166 +13,189 @@
 #
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The manual partitioning system module
 """
-from archcraftsman import info
-from archcraftsman.base import (
-    execute,
-    is_bios,
-    log,
-    print_error,
-    print_step,
-    print_sub_step,
-    prompt,
-)
-from archcraftsman.disk import Disk
-from archcraftsman.i18n import _
-from archcraftsman.options import PartTypes
-from archcraftsman.partition import Partition
-from archcraftsman.utils import ask_drive, prompt_bool, prompt_option
+import archcraftsman.base
+import archcraftsman.disk
+import archcraftsman.i18n
+import archcraftsman.info
+import archcraftsman.options
+import archcraftsman.partition
+import archcraftsman.utils
+
+_ = archcraftsman.i18n.translate
 
 
 def manual_partitioning(change_disks: bool = True) -> bool:
     """
     The method to proceed to the manual partitioning.
     """
     user_answer = False
     partitioned_disks = []
     while not user_answer:
-        print_step(_("Manual partitioning :"))
-        print_sub_step(
+        archcraftsman.base.print_step(_("Manual partitioning :"))
+        archcraftsman.base.print_sub_step(
             _("Partitioned drives so far : %s") % " ".join(partitioned_disks)
         )
-        execute("fdisk -l", force=True, sudo=True)
-        target_disk = ask_drive()
+        archcraftsman.base.execute("fdisk -l", force=True, sudo=True)
+        target_disk = archcraftsman.utils.ask_drive()
         if target_disk not in partitioned_disks:
             partitioned_disks.append(target_disk)
         if change_disks:
-            execute(f'cfdisk "{target_disk}"')
-        print_step(_("Manual partitioning :"))
-        print_sub_step(
+            archcraftsman.base.execute(f'cfdisk "{target_disk}"')
+        archcraftsman.base.print_step(_("Manual partitioning :"))
+        archcraftsman.base.print_sub_step(
             _("Partitioned drives so far : %s") % " ".join(partitioned_disks)
         )
-        execute("fdisk -l", force=True, sudo=True)
-        other_drive = prompt_bool(
+        archcraftsman.base.execute("fdisk -l", force=True, sudo=True)
+        other_drive = archcraftsman.utils.prompt_bool(
             _("Do you want to partition an other drive ?"), default=False
         )
         if other_drive:
             continue
         for disk_path in partitioned_disks:
-            log(f"Detected disk: {disk_path}")
-            disk = Disk(disk_path)
+            archcraftsman.base.log(f"Detected disk: {disk_path}")
+            disk = archcraftsman.disk.Disk(disk_path)
             partitions = [partition.path for partition in disk.partitions]
-            log(f"Partitions: {partitions}")
+            archcraftsman.base.log(f"Partitions: {partitions}")
             for partition in partitions:
-                log(f"Partition : {partition}")
-                info.ai.partitioning_info.partitions.append(Partition(path=partition))
-        print_step(
+                archcraftsman.base.log(f"Partition : {partition}")
+                archcraftsman.info.ai.partitioning_info.partitions.append(
+                    archcraftsman.partition.Partition(path=partition)
+                )
+        archcraftsman.base.print_step(
             _("Detected target drive partitions : %s")
             % " ".join(
                 [
                     part.path
-                    for part in info.ai.partitioning_info.partitions
+                    for part in archcraftsman.info.ai.partitioning_info.partitions
                     if part.path
                 ]
             )
         )
-        for partition in info.ai.partitioning_info.partitions:
-            print_step(_("Partition :"), clear=False)
-            print_sub_step(str(partition))
-            if is_bios():
-                partition_type = prompt_option(
+        for partition in archcraftsman.info.ai.partitioning_info.partitions:
+            archcraftsman.base.print_step(_("Partition :"), clear=False)
+            archcraftsman.base.print_sub_step(str(partition))
+            if archcraftsman.base.is_bios():
+                partition_type = archcraftsman.utils.prompt_option(
                     _("What is the role of this partition ? (%s) : "),
                     _("Partition type '%s' is not supported."),
-                    PartTypes,
+                    archcraftsman.options.PartTypes,
                     _("Supported partition types : "),
-                    PartTypes.OTHER,
-                    PartTypes.EFI,
+                    archcraftsman.options.PartTypes.OTHER,
+                    archcraftsman.options.PartTypes.EFI,
                 )
             else:
-                partition_type = prompt_option(
+                partition_type = archcraftsman.utils.prompt_option(
                     _("What is the role of this partition ? (%s) : "),
                     _("Partition type '%s' is not supported."),
-                    PartTypes,
+                    archcraftsman.options.PartTypes,
                     _("Supported partition types : "),
-                    PartTypes.OTHER,
+                    archcraftsman.options.PartTypes.OTHER,
                 )
-            if not is_bios() and partition_type == PartTypes.EFI:
-                partition.part_type = PartTypes.EFI
+            if (
+                not archcraftsman.base.is_bios()
+                and partition_type == archcraftsman.options.PartTypes.EFI
+            ):
+                partition.part_type = archcraftsman.options.PartTypes.EFI
                 partition.part_mount_point = "/boot/efi"
-            elif partition_type == PartTypes.ROOT:
-                partition.part_type = PartTypes.ROOT
+            elif partition_type == archcraftsman.options.PartTypes.ROOT:
+                partition.part_type = archcraftsman.options.PartTypes.ROOT
                 partition.part_mount_point = "/"
-                info.ai.partitioning_info.main_disk = f"/dev/{partition.disk_name()}"
-            elif partition_type == PartTypes.BOOT:
-                partition.part_type = PartTypes.BOOT
+                archcraftsman.info.ai.partitioning_info.main_disk = (
+                    f"/dev/{partition.disk_name()}"
+                )
+            elif partition_type == archcraftsman.options.PartTypes.BOOT:
+                partition.part_type = archcraftsman.options.PartTypes.BOOT
                 partition.part_mount_point = "/boot"
-            elif partition_type == PartTypes.HOME:
-                partition.part_type = PartTypes.HOME
+            elif partition_type == archcraftsman.options.PartTypes.HOME:
+                partition.part_type = archcraftsman.options.PartTypes.HOME
                 partition.part_mount_point = "/home"
-            elif partition_type == PartTypes.SWAP:
-                partition.part_type = PartTypes.SWAP
-            elif partition_type == PartTypes.NOT_USED:
+            elif partition_type == archcraftsman.options.PartTypes.SWAP:
+                partition.part_type = archcraftsman.options.PartTypes.SWAP
+            elif partition_type == archcraftsman.options.PartTypes.NOT_USED:
                 continue
-            elif partition_type == PartTypes.OTHER:
-                partition.part_type = PartTypes.OTHER
-                partition.part_mount_point = prompt(
+            elif partition_type == archcraftsman.options.PartTypes.OTHER:
+                partition.part_type = archcraftsman.options.PartTypes.OTHER
+                partition.part_mount_point = archcraftsman.base.prompt(
                     _("What is the mounting point of this partition ? : ")
                 )
             partition.ask_for_format()
             partition.ask_for_encryption()
 
-        if not is_bios() and PartTypes.EFI not in [
-            part.part_type for part in info.ai.partitioning_info.partitions
-        ]:
-            print_error(_("The EFI partition is required for system installation."))
-            info.ai.partitioning_info.partitions.clear()
+        if (
+            not archcraftsman.base.is_bios()
+            and archcraftsman.options.PartTypes.EFI
+            not in [
+                part.part_type
+                for part in archcraftsman.info.ai.partitioning_info.partitions
+            ]
+        ):
+            archcraftsman.base.print_error(
+                _("The EFI partition is required for system installation.")
+            )
+            archcraftsman.info.ai.partitioning_info.partitions.clear()
             partitioned_disks.clear()
             continue
-        if PartTypes.ROOT not in [
-            part.part_type for part in info.ai.partitioning_info.partitions
+        if archcraftsman.options.PartTypes.ROOT not in [
+            part.part_type
+            for part in archcraftsman.info.ai.partitioning_info.partitions
         ]:
-            print_error(_("The Root partition is required for system installation."))
-            info.ai.partitioning_info.partitions.clear()
+            archcraftsman.base.print_error(
+                _("The Root partition is required for system installation.")
+            )
+            archcraftsman.info.ai.partitioning_info.partitions.clear()
             partitioned_disks.clear()
             continue
         if True in [
-            part.encrypted and part.part_type == PartTypes.ROOT
-            for part in info.ai.partitioning_info.partitions
-        ] and PartTypes.BOOT not in [
-            part.part_type for part in info.ai.partitioning_info.partitions
+            part.encrypted and part.part_type == archcraftsman.options.PartTypes.ROOT
+            for part in archcraftsman.info.ai.partitioning_info.partitions
+        ] and archcraftsman.options.PartTypes.BOOT not in [
+            part.part_type
+            for part in archcraftsman.info.ai.partitioning_info.partitions
         ]:
-            print_error(_("The Boot partition is required for system installation."))
-            info.ai.partitioning_info.partitions.clear()
+            archcraftsman.base.print_error(
+                _("The Boot partition is required for system installation.")
+            )
+            archcraftsman.info.ai.partitioning_info.partitions.clear()
             partitioned_disks.clear()
             continue
-        if PartTypes.SWAP not in [
-            part.part_type for part in info.ai.partitioning_info.partitions
+        if archcraftsman.options.PartTypes.SWAP not in [
+            part.part_type
+            for part in archcraftsman.info.ai.partitioning_info.partitions
         ]:
-            info.ai.partitioning_info.swapfile_size = Disk(
-                info.ai.partitioning_info.main_disk
-            ).ask_swapfile_size()
-
-        print_step(_("Summary of choices :"))
-        for partition in info.ai.partitioning_info.partitions:
-            print_sub_step(partition.summary())
+            archcraftsman.info.ai.partitioning_info.swapfile_size = (
+                archcraftsman.disk.Disk(
+                    archcraftsman.info.ai.partitioning_info.main_disk
+                ).ask_swapfile_size()
+            )
+
+        archcraftsman.base.print_step(_("Summary of choices :"))
+        for partition in archcraftsman.info.ai.partitioning_info.partitions:
+            archcraftsman.base.print_sub_step(partition.summary())
         if (
-            PartTypes.SWAP
-            not in [part.part_type for part in info.ai.partitioning_info.partitions]
-            and info.ai.partitioning_info.swapfile_size
+            archcraftsman.options.PartTypes.SWAP
+            not in [
+                part.part_type
+                for part in archcraftsman.info.ai.partitioning_info.partitions
+            ]
+            and archcraftsman.info.ai.partitioning_info.swapfile_size
         ):
-            print_sub_step(
-                _("Swapfile size : %s") % info.ai.partitioning_info.swapfile_size
+            archcraftsman.base.print_sub_step(
+                _("Swapfile size : %s")
+                % archcraftsman.info.ai.partitioning_info.swapfile_size
             )
-        user_answer = prompt_bool(_("Is the information correct ?"), default=False)
+        user_answer = archcraftsman.utils.prompt_bool(
+            _("Is the information correct ?"), default=False
+        )
         if not user_answer:
-            want_to_change = prompt_bool(
+            want_to_change = archcraftsman.utils.prompt_bool(
                 _("Do you want to change the partitioning mode ?"), default=False
             )
             if want_to_change:
                 return False
-            info.ai.partitioning_info.partitions.clear()
+            archcraftsman.info.ai.partitioning_info.partitions.clear()
             partitioned_disks.clear()
     return True
```

## archcraftsman/options.py

```diff
@@ -13,18 +13,18 @@
 #
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The all available options module.
 """
-from enum import Enum, auto
+import enum
 
 
-class OptionEnum(str, Enum):
+class OptionEnum(str, enum.Enum):
     """
     The Enum base method for options.
     """
 
     @staticmethod
     def _generate_next_value_(
         name: str, start: int, count: int, last_values: list
@@ -36,162 +36,158 @@
 
 
 class Languages(OptionEnum):
     """
     All available languages.
     """
 
-    ENGLISH = auto()
-    FRENCH = auto()
+    ENGLISH = enum.auto()
+    FRENCH = enum.auto()
 
 
 class Commands(OptionEnum):
     """
     All available commands.
     """
 
-    KERNEL = auto()
-    DESKTOP = auto()
-    BUNDLE = auto()
-    SHELL_BUNDLE = auto()
-    HELP = auto()
-    EXIT = auto()
+    KERNEL = enum.auto()
+    DESKTOP = enum.auto()
+    BUNDLE = enum.auto()
+    SHELL_BUNDLE = enum.auto()
+    HELP = enum.auto()
+    EXIT = enum.auto()
 
 
 class SubCommands(OptionEnum):
     """
     All available sub-commands.
     """
 
-    INSTALL = auto()
-    UNINSTALL = auto()
-    CANCEL = auto()
+    INSTALL = enum.auto()
+    UNINSTALL = enum.auto()
+    CANCEL = enum.auto()
 
 
 class Kernels(OptionEnum):
     """
     All kernel options.
     """
 
-    CURRENT = auto()
-    LTS = auto()
-    ZEN = auto()
-    HARDENED = auto()
+    CURRENT = enum.auto()
+    LTS = enum.auto()
+    ZEN = enum.auto()
+    HARDENED = enum.auto()
 
 
 class Desktops(OptionEnum):
     """
     All desktop environment options.
     """
 
-    GNOME = auto()
-    PLASMA = auto()
-    XFCE = auto()
-    BUDGIE = auto()
-    CINNAMON = auto()
-    CUTEFISH = auto()
-    DEEPIN = auto()
-    LXQT = auto()
-    MATE = auto()
-    ENLIGHTENMENT = auto()
-    I3 = auto()
-    SWAY = auto()
-    NONE = auto()
+    GNOME = enum.auto()
+    PLASMA = enum.auto()
+    XFCE = enum.auto()
+    BUDGIE = enum.auto()
+    CINNAMON = enum.auto()
+    CUTEFISH = enum.auto()
+    DEEPIN = enum.auto()
+    LXQT = enum.auto()
+    MATE = enum.auto()
+    ENLIGHTENMENT = enum.auto()
+    I3 = enum.auto()
+    SWAY = enum.auto()
+    NONE = enum.auto()
 
 
 class Network(OptionEnum):
     """
     All network options.
     """
 
-    NETWORK_MANAGER = auto()
-    IWD = auto()
-    SYSTEMD = auto()
-    NONE = auto()
+    NETWORK_MANAGER = enum.auto()
+    IWD = enum.auto()
+    SYSTEMD = enum.auto()
+    NONE = enum.auto()
 
 
 class BootLoaders(OptionEnum):
     """
     All bootloader options.
     """
 
-    GRUB = auto()
+    GRUB = enum.auto()
 
 
 class Bundles(OptionEnum):
     """
     All other options.
     """
 
-    CUPS = auto()
-    GRML = auto()
-    MAIN_FILE_SYSTEMS = auto()
-    MAIN_FONTS = auto()
-    MICROCODES = auto()
-    NVIDIA = auto()
-    PIPEWIRE = auto()
-    TERMINUS = auto()
-    ZRAM = auto()
-    COPY_ACM = auto()
+    GRML = enum.auto()
+    MICROCODES = enum.auto()
+    NVIDIA = enum.auto()
+    TERMINUS = enum.auto()
+    ZRAM = enum.auto()
+    COPY_ACM = enum.auto()
 
 
 class ShellBundles(OptionEnum):
     """
     All shell options.
     """
 
-    YAY = auto()
-    GENERATE_CONFIG = auto()
+    YAY = enum.auto()
+    GENERATE_CONFIG = enum.auto()
 
 
 class FSFormats(OptionEnum):
     """
     All file system format options.
     """
 
-    VFAT = auto()
-    EXT4 = auto()
-    BTRFS = auto()
+    VFAT = enum.auto()
+    EXT4 = enum.auto()
+    BTRFS = enum.auto()
 
 
 class SwapTypes(OptionEnum):
     """
     All sway type options.
     """
 
-    PARTITION = auto()
-    FILE = auto()
-    NONE = auto()
+    PARTITION = enum.auto()
+    FILE = enum.auto()
+    NONE = enum.auto()
 
 
 class PartTypes(OptionEnum):
     """
     All partition type options.
     """
 
-    EFI = auto()
-    ROOT = auto()
-    BOOT = auto()
-    HOME = auto()
-    SWAP = auto()
-    NOT_USED = auto()
-    OTHER = auto()
+    EFI = enum.auto()
+    ROOT = enum.auto()
+    BOOT = enum.auto()
+    HOME = enum.auto()
+    SWAP = enum.auto()
+    NOT_USED = enum.auto()
+    OTHER = enum.auto()
 
 
 class BundleTypes(OptionEnum):
     """
     All bundle type options.
     """
 
-    BOOTLOADER = auto()
-    DESKTOP = auto()
-    KERNEL = auto()
-    MICRO_CODES = auto()
-    NETWORK = auto()
-    OTHER = auto()
+    BOOTLOADER = enum.auto()
+    DESKTOP = enum.auto()
+    KERNEL = enum.auto()
+    MICRO_CODES = enum.auto()
+    NETWORK = enum.auto()
+    OTHER = enum.auto()
 
 
 def get_btype_by_name(name: str) -> BundleTypes:
     """
     Get the bundle type by name.
     """
     if name == Bundles.MICROCODES.value:
```

## archcraftsman/packages.py

```diff
@@ -14,28 +14,30 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The packages management singleton module
 """
 import readline
-from threading import Lock
+import threading
 
-from archcraftsman import arguments
-from archcraftsman.base import execute, glob_completer, print_error, prompt_ln
-from archcraftsman.i18n import _
+import archcraftsman.arguments
+import archcraftsman.base
+import archcraftsman.i18n
+
+_ = archcraftsman.i18n.translate
 
 
 class PackagesMeta(type):
     """
     Thread-safe implementation of Singleton to store all archlinux packages.
     """
 
     _instances = {}
-    _lock: Lock = Lock()
+    _lock: threading.Lock = threading.Lock()
 
     def __call__(cls, *args, **kwargs):
         """
         Possible changes to the value of the `__init__` argument do not affect
         the returned instance.
         """
         with cls._lock:
@@ -50,28 +52,28 @@
     The singleton implementation containing all archlinux packages and autocompleted prompt method.
     """
 
     packages: list[str]
 
     def __init__(self) -> None:
         self.packages = (
-            execute(
+            archcraftsman.base.execute(
                 "pacman -Sl | awk '{print $2}'",
                 check=False,
                 capture_output=True,
             )
             .output.strip()
             .split("\n")
         )
 
     def exist(self, package: str) -> bool:
         """
         A method to check if a package exist.
         """
-        return arguments.test() or package in self.packages
+        return archcraftsman.arguments.test() or package in self.packages
 
     def ask_packages(self) -> list[str]:
         """
         A method to ask the user for more packages to install.
         """
         readline.set_completer(
             lambda text, state: (
@@ -83,24 +85,26 @@
             )[state]
         )
 
         pkgs_select_ok = False
         more_pkgs = []
         while not pkgs_select_ok:
             more_pkgs = []
-            more_pkgs_str = prompt_ln(
+            more_pkgs_str = archcraftsman.base.prompt_ln(
                 _(
                     "Install more packages ? (type extra packages full names, example : 'htop neofetch', "
                     "leave blank if none) : "
                 )
             )
             pkgs_select_ok = True
             if more_pkgs_str:
                 for pkg in more_pkgs_str.split():
                     if not self.exist(pkg):
                         pkgs_select_ok = False
-                        print_error(_("Package %s doesn't exist.") % pkg)
+                        archcraftsman.base.print_error(
+                            _("Package %s doesn't exist.") % pkg
+                        )
                         break
                     more_pkgs.append(pkg)
 
-        readline.set_completer(glob_completer)
+        readline.set_completer(archcraftsman.base.glob_completer)
         return more_pkgs
```

## archcraftsman/partition.py

```diff
@@ -15,41 +15,37 @@
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The partition class module
 """
 import json
 import os
-from subprocess import CalledProcessError
-from typing import Optional
+import subprocess
+import typing
 
-from archcraftsman.base import execute, print_sub_step
-from archcraftsman.i18n import _
-from archcraftsman.options import FSFormats, PartTypes
-from archcraftsman.utils import (
-    ask_encryption_block_name,
-    ask_format_type,
-    from_iec,
-    prompt_bool,
-    to_iec,
-)
+import archcraftsman.base
+import archcraftsman.i18n
+import archcraftsman.options
+import archcraftsman.utils
+
+_ = archcraftsman.i18n.translate
 
 
 class Partition:
     """
     A class to represent a partition.
     """
 
     def __init__(
         self,
         index: int = 0,
         path: str = "",
-        part_type: PartTypes = PartTypes.OTHER,
+        part_type: archcraftsman.options.PartTypes = archcraftsman.options.PartTypes.OTHER,
         part_mount_point: str = "",
-        part_format_type: FSFormats = FSFormats.EXT4,
+        part_format_type: archcraftsman.options.FSFormats = archcraftsman.options.FSFormats.EXT4,
         part_format: bool = True,
         encrypted: bool = False,
         block_name: str = "",
     ):
         """
         Partition initialisation.
         """
@@ -62,232 +58,245 @@
         self.block_name = block_name
         self.path = path
 
     def __str__(self) -> str:
         """
         Partition str formatting.
         """
-        formatted_str = (
-            f"'{self.path}' - '{self.part_type_name()}' - '{to_iec(int(self.size()))}'"
-        )
+        formatted_str = f"'{self.path}' - '{self.part_type_name()}' - '{archcraftsman.utils.to_iec(int(self.size()))}'"
         return formatted_str
 
     def size(self) -> int:
         """
         A method to get the partition size.
         """
-        return from_iec(
-            execute(
+        return archcraftsman.utils.from_iec(
+            archcraftsman.base.execute(
                 f'lsblk -nld "{self.path}" -o SIZE', force=True, capture_output=True
             ).output.strip()
         )
 
     def part_type_name(self) -> str:
         """
         A method to get the partition type name.
         """
-        return execute(
+        return archcraftsman.base.execute(
             f'lsblk -nld "{self.path}" -o PARTTYPENAME',
             force=True,
             capture_output=True,
         ).output.strip()
 
     def disk_name(self) -> str:
         """
         A method to get the disk name.
         """
-        return execute(
+        return archcraftsman.base.execute(
             f'lsblk -nld "{self.path}" -o PKNAME', force=True, capture_output=True
         ).output.strip()
 
     def fs_type(self) -> str:
         """
         A method to get the filesystem type.
         """
-        return execute(
+        return archcraftsman.base.execute(
             f'lsblk -nld "{self.path}" -o FSTYPE', force=True, capture_output=True
         ).output.strip()
 
     def uuid(self) -> str:
         """
         A method to get the partition uuid.
         """
-        return execute(
+        return archcraftsman.base.execute(
             f'lsblk -nld "{self.path}" -o UUID', force=True, capture_output=True
         ).output.strip()
 
     def need_format(self):
         """
         Method to know if the partition need to be formatted
         """
-        return self.part_type in {PartTypes.ROOT}
+        return self.part_type in {archcraftsman.options.PartTypes.ROOT}
 
     def no_format(self):
         """
         Method to know if the partition doesn't have to be formatted
         """
-        return self.part_type in {PartTypes.SWAP, PartTypes.NOT_USED}
+        return self.part_type in {
+            archcraftsman.options.PartTypes.SWAP,
+            archcraftsman.options.PartTypes.NOT_USED,
+        }
 
     def ask_for_format(self):
         """
         Method to ask if the partition have to be formatted and in which format.
         """
         if self.no_format():
             self.part_format = False
             return
         if self.need_format() or self.encrypted:
             self.part_format = True
-            self.part_format_type = ask_format_type()
+            self.part_format_type = archcraftsman.utils.ask_format_type()
             return
-        self.part_format = prompt_bool(_("Format the partition ?"))
+        self.part_format = archcraftsman.utils.prompt_bool(_("Format the partition ?"))
         if self.part_format:
-            if self.part_type == PartTypes.EFI:
-                self.part_format_type = FSFormats.VFAT
+            if self.part_type == archcraftsman.options.PartTypes.EFI:
+                self.part_format_type = archcraftsman.options.FSFormats.VFAT
             else:
-                self.part_format_type = ask_format_type()
+                self.part_format_type = archcraftsman.utils.ask_format_type()
 
     def is_encrypted(self) -> bool:
         """
         A method to detect if the partition is an existing-encrypted partition.
         """
         return bool(
-            execute(
+            archcraftsman.base.execute(
                 f"cryptsetup isLuks {self.path}", check=False, force=True, sudo=True
             )
         )
 
     def is_encryptable(self):
         """
         Method to know if the partition is encryptable.
         """
-        return self.part_type in {PartTypes.ROOT, PartTypes.HOME, PartTypes.OTHER}
+        return self.part_type in {
+            archcraftsman.options.PartTypes.ROOT,
+            archcraftsman.options.PartTypes.HOME,
+            archcraftsman.options.PartTypes.OTHER,
+        }
 
     def ask_for_encryption(self):
         """
         A method to ask if the partition will be encrypted.
         """
         if not self.part_format:
             self.encrypted = self.is_encrypted()
         elif not self.is_encryptable():
             return
         else:
-            self.encrypted = prompt_bool(
+            self.encrypted = archcraftsman.utils.prompt_bool(
                 _("Do you want to encrypt this partition ?"), default=False
             )
         if self.encrypted:
-            if self.part_type == PartTypes.ROOT:
+            if self.part_type == archcraftsman.options.PartTypes.ROOT:
                 self.block_name = "root"
-            elif self.part_type == PartTypes.HOME:
+            elif self.part_type == archcraftsman.options.PartTypes.HOME:
                 self.block_name = "home"
             else:
-                self.block_name = ask_encryption_block_name()
+                self.block_name = archcraftsman.utils.ask_encryption_block_name()
 
     def summary(self):
         """
         A method to get the partition summary.
         """
         if self.part_format:
             formatting = _("yes")
         else:
             formatting = _("no")
         name = str(self.index + 1)
         if self.path:
             name = self.path
-        if self.part_type == PartTypes.SWAP:
+        if self.part_type == archcraftsman.options.PartTypes.SWAP:
             return _("%s : %s") % (self.part_type, name)
         summary = _("%s : %s (mounting point : %s, format %s, format type %s)") % (
             self.part_type,
             name,
             self.part_mount_point,
             formatting,
             self.part_format_type,
         )
         if self.encrypted:
             summary += f" - {_('encrypted')} ('/dev/mapper/{self.block_name}')"
         return summary
 
-    def real_path(self) -> Optional[str]:
+    def real_path(self) -> typing.Optional[str]:
         """
         A method to get the partition path.
         """
         return f"/dev/mapper/{self.block_name}" if self.encrypted else self.path
 
     def format_partition(self):
         """
-        A method to execute formatting commands for the partition.
+        A method to archcraftsman.base.execute formatting commands for the partition.
         """
         if self.part_format:
-            print_sub_step(_("Formatting %s...") % (self.real_path()))
-        if self.part_type == PartTypes.SWAP:
-            execute(f'mkswap "{self.path}"')
-            execute(f'swapon "{self.path}"')
+            archcraftsman.base.print_sub_step(
+                _("Formatting %s...") % (self.real_path())
+            )
+        if self.part_type == archcraftsman.options.PartTypes.SWAP:
+            archcraftsman.base.execute(f'mkswap "{self.path}"')
+            archcraftsman.base.execute(f'swapon "{self.path}"')
             return
         if self.encrypted:
             if self.part_format:
-                execute(f"cryptsetup -y -v luksFormat {self.path}")
-            print_sub_step(_("Opening %s...") % (self.real_path()))
-            execute(f"cryptsetup open {self.path} {self.block_name}")
+                archcraftsman.base.execute(f"cryptsetup -y -v luksFormat {self.path}")
+            archcraftsman.base.print_sub_step(_("Opening %s...") % (self.real_path()))
+            archcraftsman.base.execute(f"cryptsetup open {self.path} {self.block_name}")
         match self.part_format_type:
-            case FSFormats.VFAT:
+            case archcraftsman.options.FSFormats.VFAT:
                 if self.part_format:
-                    execute(f'mkfs.vfat "{self.real_path()}"')
-            case FSFormats.BTRFS:
+                    archcraftsman.base.execute(f'mkfs.vfat "{self.real_path()}"')
+            case archcraftsman.options.FSFormats.BTRFS:
                 if self.part_format:
-                    execute(f'mkfs.btrfs -f "{self.real_path()}"')
+                    archcraftsman.base.execute(f'mkfs.btrfs -f "{self.real_path()}"')
             case _:
                 if self.part_format:
-                    execute(f'mkfs.ext4 "{self.real_path()}"')
+                    archcraftsman.base.execute(f'mkfs.ext4 "{self.real_path()}"')
 
     def is_mounted(self) -> bool:
         """
         A method to detect if the partition is mounted.
         """
         return bool(
-            execute(
+            archcraftsman.base.execute(
                 f"cat /proc/mounts | grep {self.real_path()}",
                 check=False,
                 capture_output=True,
                 force=True,
             )
         )
 
     def mount(self):
         """
         A method to mount the partition.
         """
-        print_sub_step(_("Mounting %s...") % (self.real_path()))
+        archcraftsman.base.print_sub_step(_("Mounting %s...") % (self.real_path()))
         match self.part_format_type:
-            case FSFormats.BTRFS:
-                execute(
+            case archcraftsman.options.FSFormats.BTRFS:
+                archcraftsman.base.execute(
                     f'mount --mkdir -o compress=zstd "{self.real_path()}" "/mnt{self.part_mount_point}"'
                 )
             case _:
-                execute(
+                archcraftsman.base.execute(
                     f'mount --mkdir "{self.real_path()}" "/mnt{self.part_mount_point}"'
                 )
 
     def umount(self) -> bool:
         """
         A method to unmount the partition.
         """
         try:
-            print_sub_step(_("Unmounting %s...") % (self.real_path()))
-            execute(f'umount "/mnt{self.part_mount_point}"')
+            archcraftsman.base.print_sub_step(
+                _("Unmounting %s...") % (self.real_path())
+            )
+            archcraftsman.base.execute(f'umount "/mnt{self.part_mount_point}"')
             if self.encrypted:
-                print_sub_step(_("Closing %s...") % (self.real_path()))
-                execute(f"cryptsetup close {self.block_name}")
-        except CalledProcessError:
+                archcraftsman.base.print_sub_step(
+                    _("Closing %s...") % (self.real_path())
+                )
+                archcraftsman.base.execute(f"cryptsetup close {self.block_name}")
+        except subprocess.CalledProcessError:
             return False
         return True
 
     def build_partition_name(self, disk_name: str):
         """
         A method to build a partition name with a disk and an index.
         """
-        block_devices_str = execute("lsblk -J", force=True, capture_output=True).output
+        block_devices_str = archcraftsman.base.execute(
+            "lsblk -J", force=True, capture_output=True
+        ).output
         if not block_devices_str:
             return
         block_devices_json = json.loads(block_devices_str)
         if (
             not block_devices_json
             or not isinstance(block_devices_json, dict)
             or "blockdevices" not in dict(block_devices_json)
```

## archcraftsman/partitioninginfo.py

```diff
@@ -16,64 +16,71 @@
 
 """
 The module of PartitioningInfo class.
 """
 import re
 import subprocess
 
-from archcraftsman import arguments
-from archcraftsman.base import execute, print_error, print_step
-from archcraftsman.i18n import _
-from archcraftsman.options import FSFormats, PartTypes
-from archcraftsman.partition import Partition
+import archcraftsman.arguments
+import archcraftsman.base
+import archcraftsman.i18n
+import archcraftsman.options
+import archcraftsman.partition
+
+_ = archcraftsman.i18n.translate
 
 
 class PartitioningInfo:
     """
     The class to contain all partitioning information.
     """
 
     def __init__(
         self,
         swapfile_size: str = "",
         main_disk: str = "",
         btrfs_in_use: bool = False,
     ) -> None:
-        self.partitions: list[Partition] = []
+        self.partitions: list[archcraftsman.partition.Partition] = []
         self.swapfile_size = swapfile_size
         self.main_disk = main_disk
         self.btrfs_in_use = btrfs_in_use
 
-    def root_partition(self) -> Partition:
+    def root_partition(self) -> archcraftsman.partition.Partition:
         """
         The root partition retrieving method.
         """
         return next(
             partition
             for partition in self.partitions
-            if partition.part_type == PartTypes.ROOT
+            if partition.part_type == archcraftsman.options.PartTypes.ROOT
         )
 
     def format_and_mount_partitions(self):
         """
         A method to format and mount all partitions.
         """
-        print_step(_("Formatting and mounting partitions..."), clear=False)
+        archcraftsman.base.print_step(
+            _("Formatting and mounting partitions..."), clear=False
+        )
 
         formatting_ok = False
         while not formatting_ok:
             try:
                 for partition in self.partitions:
-                    if partition.part_format_type == FSFormats.BTRFS:
+                    if (
+                        partition.part_format_type
+                        == archcraftsman.options.FSFormats.BTRFS
+                    ):
                         self.btrfs_in_use = True
                     partition.format_partition()
                 formatting_ok = True
             except subprocess.CalledProcessError as exception:
                 self.umount_partitions()
-                print_error(
+                archcraftsman.base.print_error(
                     _("A subprocess execution failed ! See the following error: %s")
                     % exception
                 )
 
         not_mounted_partitions = [
             partition
             for partition in self.partitions
@@ -81,49 +88,49 @@
         ]
         not_mounted_partitions.sort(
             key=lambda part: 0
             if not part.part_mount_point
             else len(part.part_mount_point)
         )
 
-        while not arguments.test() and False in [
+        while not archcraftsman.arguments.test() and False in [
             partition.is_mounted() for partition in not_mounted_partitions
         ]:
             for partition in not_mounted_partitions:
-                if partition.part_format_type == FSFormats.BTRFS:
+                if partition.part_format_type == archcraftsman.options.FSFormats.BTRFS:
                     self.btrfs_in_use = True
                 partition.mount()
 
     def umount_partitions(self):
         """
         A method to unmount all mounted partitions.
         """
-        print_step(_("Unmounting partitions..."), clear=False)
+        archcraftsman.base.print_step(_("Unmounting partitions..."), clear=False)
         swap = re.sub(
             "\\s",
             "",
-            execute(
+            archcraftsman.base.execute(
                 "swapon --noheadings | awk '{print $1}'",
                 check=False,
                 capture_output=True,
             ).output,
         )
         if swap:
-            execute(f"swapoff {swap} &>/dev/null", check=False)
+            archcraftsman.base.execute(f"swapoff {swap} &>/dev/null", check=False)
 
         mounted_partitions = [
             partition for partition in self.partitions if partition.is_mounted()
         ]
         mounted_partitions.sort(
             key=lambda part: 0
             if not part.part_mount_point
             else len(part.part_mount_point),
             reverse=True,
         )
 
-        while not arguments.test() and True in [
+        while not archcraftsman.arguments.test() and True in [
             partition.is_mounted() for partition in mounted_partitions
         ]:
             for partition in [
                 partition for partition in mounted_partitions if partition.is_mounted()
             ]:
                 partition.umount()
```

## archcraftsman/prelaunchinfo.py

```diff
@@ -15,68 +15,72 @@
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The module of PreLaunchInfo class.
 """
 import os
 
-from archcraftsman.base import execute, log, print_step
-from archcraftsman.i18n import _
-from archcraftsman.options import Languages
+import archcraftsman.base
+import archcraftsman.i18n
+import archcraftsman.options
 
+_ = archcraftsman.i18n.translate
 
-def parse_detected_language(detected_language: str) -> Languages:
+
+def parse_detected_language(detected_language: str) -> archcraftsman.options.Languages:
     """
     The function to parse the detected language.
     """
     match detected_language:
         case "fr-FR":
-            return Languages.FRENCH
+            return archcraftsman.options.Languages.FRENCH
         case _:
-            return Languages.ENGLISH
+            return archcraftsman.options.Languages.ENGLISH
 
 
 class PreLaunchInfo:
     """
     The class to contain all pre-launch information.
     """
 
     def __init__(
         self,
-        global_language: Languages = Languages.ENGLISH,
+        global_language: archcraftsman.options.Languages = archcraftsman.options.Languages.ENGLISH,
         keymap: str = "en",
         detected_timezone: str = "Etc/UTC",
         live_console_font: str = "",
     ) -> None:
         self.global_language = global_language
         self.keymap = keymap
         self.detected_timezone = detected_timezone
         self.live_console_font = live_console_font
 
     def setup_locale(self):
         """
         The method to set up environment locale.
         """
-        print_step(_("Configuring live environment..."), clear=False)
+        archcraftsman.base.print_step(_("Configuring live environment..."), clear=False)
         self.live_console_font = "ter-v16b"
-        execute(f'loadkeys "{self.keymap}"')
-        execute("setfont ter-v16b")
-        dimensions = execute("stty size", capture_output=True).output
+        archcraftsman.base.execute(f'loadkeys "{self.keymap}"')
+        archcraftsman.base.execute("setfont ter-v16b")
+        dimensions = archcraftsman.base.execute("stty size", capture_output=True).output
         if dimensions:
             split_dimensions = dimensions.split(" ")
             if (
                 split_dimensions
                 and len(split_dimensions) > 0
                 and int(split_dimensions[0]) >= 80
             ):
                 self.live_console_font = "ter-v32b"
-                execute("setfont ter-v32b")
-        if self.global_language == Languages.FRENCH:
-            execute('sed -i "s|#fr_FR.UTF-8 UTF-8|fr_FR.UTF-8 UTF-8|g" /etc/locale.gen')
-            execute("locale-gen")
+                archcraftsman.base.execute("setfont ter-v32b")
+        if self.global_language == archcraftsman.options.Languages.FRENCH:
+            archcraftsman.base.execute(
+                'sed -i "s|#fr_FR.UTF-8 UTF-8|fr_FR.UTF-8 UTF-8|g" /etc/locale.gen'
+            )
+            archcraftsman.base.execute("locale-gen")
             os.putenv("LANG", "fr_FR.UTF-8")
             os.putenv("LANGUAGE", "fr_FR.UTF-8")
         else:
             os.putenv("LANG", "en_US.UTF-8")
             os.putenv("LANGUAGE", "en_US.UTF-8")
 
     def setup_chroot_keyboard(self):
@@ -92,15 +96,15 @@
         content = [
             'Section "InputClass"\n',
             '    Identifier "system-keyboard"\n',
             '    MatchIsKeyboard "on"\n',
             f'    Option "XkbLayout" "{layout}"\n',
             "EndSection\n",
         ]
-        execute("mkdir --parents /mnt/etc/X11/xorg.conf.d/")
+        archcraftsman.base.execute("mkdir --parents /mnt/etc/X11/xorg.conf.d/")
         try:
             with open(
                 "/mnt/etc/X11/xorg.conf.d/00-keyboard.conf", "w", encoding="UTF-8"
             ) as keyboard_config_file:
                 keyboard_config_file.writelines(content)
         except FileNotFoundError as exception:
-            log(f"Exception: {exception}")
+            archcraftsman.base.log(f"Exception: {exception}")
```

## archcraftsman/shell.py

```diff
@@ -13,198 +13,204 @@
 #
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The shell mode module
 """
-from subprocess import CalledProcessError
-from typing import Optional
+import subprocess
+import typing
 
-from archcraftsman import config
-from archcraftsman.base import execute, print_error, print_step
-from archcraftsman.basesetup import pre_launch, setup_system
-from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.bundles.utils import prompt_bundle
-from archcraftsman.i18n import _
-from archcraftsman.manualpart import manual_partitioning
-from archcraftsman.options import (
-    Bundles,
-    Commands,
-    Desktops,
-    Kernels,
-    ShellBundles,
-    SubCommands,
-)
-from archcraftsman.utils import print_supported, prompt_option
+import archcraftsman.base
+import archcraftsman.basesetup
+import archcraftsman.bundles.bundle
+import archcraftsman.bundles.utils
+import archcraftsman.config
+import archcraftsman.i18n
+import archcraftsman.manualpart
+import archcraftsman.options
+import archcraftsman.utils
 
+_ = archcraftsman.i18n.translate
 
-def ask_for_kernel() -> Optional[Bundle]:
+
+def ask_for_kernel() -> typing.Optional[archcraftsman.bundles.bundle.Bundle]:
     """
     A method to ask for a kernel.
     """
     try:
-        return prompt_bundle(
+        return archcraftsman.bundles.utils.prompt_bundle(
             "> ",
             _("Kernel '%s' is not supported."),
-            Kernels,
+            archcraftsman.options.Kernels,
             _("Supported kernels : "),
             None,
             new_line_prompt=False,
         )
     except ValueError:
         return None
 
 
-def ask_for_desktop() -> Optional[Bundle]:
+def ask_for_desktop() -> typing.Optional[archcraftsman.bundles.bundle.Bundle]:
     """
     A method to ask for a desktop environment.
     """
     try:
-        return prompt_bundle(
+        return archcraftsman.bundles.utils.prompt_bundle(
             "> ",
             _("Desktop environment '%s' is not supported."),
-            Desktops,
+            archcraftsman.options.Desktops,
             _("Supported desktop environments : "),
             None,
             new_line_prompt=False,
         )
     except ValueError:
         return None
 
 
-def ask_for_bundle() -> Optional[Bundle]:
+def ask_for_bundle() -> typing.Optional[archcraftsman.bundles.bundle.Bundle]:
     """
     A method to ask for a bundle.
     """
     try:
-        return prompt_bundle(
+        return archcraftsman.bundles.utils.prompt_bundle(
             "> ",
             _("Bundle '%s' is not supported."),
-            Bundles,
+            archcraftsman.options.Bundles,
             _("Available bundles : "),
             None,
-            Bundles.COPY_ACM,
+            archcraftsman.options.Bundles.COPY_ACM,
             new_line_prompt=False,
         )
     except ValueError:
         return None
 
 
-def ask_for_shell_bundle() -> Optional[Bundle]:
+def ask_for_shell_bundle() -> typing.Optional[archcraftsman.bundles.bundle.Bundle]:
     """
     A method to ask for a bundle.
     """
     try:
-        return prompt_bundle(
+        return archcraftsman.bundles.utils.prompt_bundle(
             "> ",
             _("Shell bundle '%s' is not supported."),
-            ShellBundles,
+            archcraftsman.options.ShellBundles,
             _("Available shell bundles : "),
             None,
             new_line_prompt=False,
         )
     except ValueError:
         return None
 
 
-def install_bundle(bundle: Bundle):
+def install_bundle(bundle: archcraftsman.bundles.bundle.Bundle):
     """
     The method to install the bundle.
     """
     if bundle.is_aur():
         bundle.configure()
     else:
         if len(bundle.packages()) > 0:
-            execute(
+            archcraftsman.base.execute(
                 f'pacman -S {" ".join(bundle.packages())}',
                 check=False,
             )
 
 
 def uninstall_bundle(bundle):
     """
     The method to uninstall the bundle.
     """
     if len(bundle.packages()) > 0:
-        execute(
+        archcraftsman.base.execute(
             f'pacman -Rsnc {" ".join(bundle.packages())}',
             check=False,
         )
 
 
 def shell():
     """
     The shell mode method.
     """
-    print_step(_("ArchCraftsman interactive shell mode."))
-    print_supported(_("Available commands :"), list(Commands))
+    archcraftsman.base.print_step(_("ArchCraftsman interactive shell mode."))
+    archcraftsman.utils.print_supported(
+        _("Available commands :"), list(archcraftsman.options.Commands)
+    )
     want_exit = False
     while not want_exit:
         try:
-            command = prompt_option(
+            command = archcraftsman.utils.prompt_option(
                 "> ",
                 _("Command '%s' is not supported."),
-                Commands,
+                archcraftsman.options.Commands,
                 None,
                 None,
                 new_line_prompt=False,
             )
             bundle = None
             match command:
-                case Commands.KERNEL:
+                case archcraftsman.options.Commands.KERNEL:
                     bundle = ask_for_kernel()
-                case Commands.DESKTOP:
+                case archcraftsman.options.Commands.DESKTOP:
                     bundle = ask_for_desktop()
-                case Commands.BUNDLE:
+                case archcraftsman.options.Commands.BUNDLE:
                     bundle = ask_for_bundle()
-                case Commands.SHELL_BUNDLE:
+                case archcraftsman.options.Commands.SHELL_BUNDLE:
                     bundle = ask_for_shell_bundle()
-                case Commands.HELP:
-                    print_supported(_("Available commands :"), list(Commands))
+                case archcraftsman.options.Commands.HELP:
+                    archcraftsman.utils.print_supported(
+                        _("Available commands :"), list(archcraftsman.options.Commands)
+                    )
                     continue
-                case Commands.EXIT:
+                case archcraftsman.options.Commands.EXIT:
                     want_exit = True
-                    config.serialize()
+                    archcraftsman.config.serialize()
                     continue
 
-            if bundle and bundle.name == ShellBundles.GENERATE_CONFIG:
-                pre_launch()
-                setup_system()
+            if (
+                bundle
+                and bundle.name == archcraftsman.options.ShellBundles.GENERATE_CONFIG
+            ):
+                archcraftsman.basesetup.pre_launch()
+                archcraftsman.basesetup.setup_system()
                 partitioning_info_ok: bool = False
                 while not partitioning_info_ok:
-                    partitioning_info_ok = manual_partitioning(change_disks=False)
+                    partitioning_info_ok = archcraftsman.manualpart.manual_partitioning(
+                        change_disks=False
+                    )
                 continue
 
-            sub_command = prompt_option(
+            sub_command = archcraftsman.utils.prompt_option(
                 "> ",
                 _("Sub-command '%s' is not supported."),
-                SubCommands,
+                archcraftsman.options.SubCommands,
                 _("Available sub-commands : "),
                 None,
                 new_line_prompt=False,
             )
 
             match sub_command:
-                case SubCommands.INSTALL:
+                case archcraftsman.options.SubCommands.INSTALL:
                     if bundle:
                         install_bundle(bundle)
-                case SubCommands.UNINSTALL:
+                case archcraftsman.options.SubCommands.UNINSTALL:
                     if bundle:
                         uninstall_bundle(bundle)
-                case SubCommands.CANCEL:
+                case archcraftsman.options.SubCommands.CANCEL:
                     continue
         except KeyboardInterrupt:
-            config.serialize()
-            print_error(_("Script execution interrupted by the user !"), do_pause=False)
+            archcraftsman.config.serialize()
+            archcraftsman.base.print_error(
+                _("Script execution interrupted by the user !"), do_pause=False
+            )
             want_exit = True
-        except CalledProcessError as sub_process_exception:
-            config.serialize()
-            print_error(
+        except subprocess.CalledProcessError as sub_process_exception:
+            archcraftsman.config.serialize()
+            archcraftsman.base.print_error(
                 _("A subprocess execution failed ! See the following error: %s")
                 % sub_process_exception,
                 do_pause=False,
             )
             want_exit = True
         except EOFError:
-            config.serialize()
+            archcraftsman.config.serialize()
             want_exit = True
```

## archcraftsman/systeminfo.py

```diff
@@ -14,16 +14,16 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The module of SystemInfo class.
 """
 
-from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.options import BundleTypes, get_btype_by_name
+import archcraftsman.bundles.bundle
+import archcraftsman.options
 
 
 class SystemInfo:
     """
     The class to contain all system information.
     """
 
@@ -33,74 +33,80 @@
         timezone: str = "Etc/UTC",
         user_name: str = "",
         user_full_name: str = "",
         root_password: str = "",
         user_password: str = "",
     ) -> None:
         self.hostname = hostname
-        self.bundles: list[Bundle] = []
+        self.bundles: list[archcraftsman.bundles.bundle.Bundle] = []
         self.timezone = timezone
         self.user_name = user_name
         self.user_full_name = user_full_name
         self.more_pkgs: list[str] = []
         self.root_password = root_password
         self.user_password = user_password
 
-    def kernel(self) -> Bundle:
+    def kernel(self) -> archcraftsman.bundles.bundle.Bundle:
         """
         The kernel bundle retrieving method.
         """
         return next(
             bundle
             for bundle in self.bundles
-            if get_btype_by_name(bundle.name) == BundleTypes.KERNEL
+            if archcraftsman.options.get_btype_by_name(bundle.name)
+            == archcraftsman.options.BundleTypes.KERNEL
         )
 
-    def microcode(self) -> Bundle:
+    def microcode(self) -> archcraftsman.bundles.bundle.Bundle:
         """
         The microcode bundle retrieving method.
         """
         return next(
             bundle
             for bundle in self.bundles
-            if get_btype_by_name(bundle.name) == BundleTypes.MICRO_CODES
+            if archcraftsman.options.get_btype_by_name(bundle.name)
+            == archcraftsman.options.BundleTypes.MICRO_CODES
         )
 
-    def bootloader(self) -> Bundle:
+    def bootloader(self) -> archcraftsman.bundles.bundle.Bundle:
         """
         The bootloader bundle retrieving method.
         """
         return next(
             bundle
             for bundle in self.bundles
-            if get_btype_by_name(bundle.name) == BundleTypes.BOOTLOADER
+            if archcraftsman.options.get_btype_by_name(bundle.name)
+            == archcraftsman.options.BundleTypes.BOOTLOADER
         )
 
-    def desktop(self) -> Bundle:
+    def desktop(self) -> archcraftsman.bundles.bundle.Bundle:
         """
         The desktop bundle retrieving method.
         """
         return next(
             bundle
             for bundle in self.bundles
-            if get_btype_by_name(bundle.name) == BundleTypes.DESKTOP
+            if archcraftsman.options.get_btype_by_name(bundle.name)
+            == archcraftsman.options.BundleTypes.DESKTOP
         )
 
-    def network(self) -> Bundle:
+    def network(self) -> archcraftsman.bundles.bundle.Bundle:
         """
         The network bundle retrieving method.
         """
         return next(
             bundle
             for bundle in self.bundles
-            if get_btype_by_name(bundle.name) == BundleTypes.NETWORK
+            if archcraftsman.options.get_btype_by_name(bundle.name)
+            == archcraftsman.options.BundleTypes.NETWORK
         )
 
-    def others(self) -> list[Bundle]:
+    def others(self) -> list[archcraftsman.bundles.bundle.Bundle]:
         """
         The other bundles retrieving method.
         """
         return [
             bundle
             for bundle in self.bundles
-            if get_btype_by_name(bundle.name) == BundleTypes.OTHER
+            if archcraftsman.options.get_btype_by_name(bundle.name)
+            == archcraftsman.options.BundleTypes.OTHER
         ]
```

## archcraftsman/utils.py

```diff
@@ -13,70 +13,64 @@
 #
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The general utility methods and tools module
 """
+import importlib.resources
 import re
 import readline
 import subprocess
-from importlib.resources import files
-from typing import Optional, TypeVar
+import typing
 
-from archcraftsman.base import (
-    execute,
-    glob_completer,
-    print_error,
-    print_help,
-    print_step,
-    print_sub_step,
-    prompt,
-    prompt_ln,
-    prompt_passwd,
-)
-from archcraftsman.i18n import _
-from archcraftsman.options import FSFormats, OptionEnum
+import archcraftsman.base
+import archcraftsman.i18n
+import archcraftsman.options
+
+_ = archcraftsman.i18n.translate
 
 
 def generate_translations(global_language: str):
     """
     Generate translations for ArchCraftsman.
     """
-    locale_file_path = files("archcraftsman.locales").joinpath(f"{global_language}.po")
+    locale_file_path = importlib.resources.files("archcraftsman.locales").joinpath(
+        f"{global_language}.po"
+    )
     if locale_file_path.is_file():
-        execute(
+        archcraftsman.base.execute(
             f"msgfmt -o /usr/share/locale/fr/LC_MESSAGES/archcraftsman.mo {locale_file_path} &>/dev/null",
             force=True,
             sudo=True,
         )
 
 
 def to_iec(size: int) -> str:
     """
     The method to convert a size in iec format.
     """
     return re.sub(
         "\\s",
         "",
-        execute(
+        archcraftsman.base.execute(
             f'printf "{size}" | numfmt --to=iec', capture_output=True, force=True
         ).output,
     )
 
 
 def from_iec(size: str) -> int:
     """
     The method to convert an iec formatted size in bytes.
     """
     try:
         value = re.sub(
             "\\s",
             "",
-            execute(
+            archcraftsman.base.execute(
                 f'printf "{size}" | numfmt --from=iec',
                 capture_output=True,
                 force=True,
             ).output,
         )
         return int(value) if value else 0
     except subprocess.CalledProcessError:
@@ -84,31 +78,31 @@
 
 
 def print_supported(supported_msg: str, options: list[str], *ignores: str):
     """
     A method to print all supported options.
     """
     supported_options = [option for option in options if option not in ignores]
-    print_step(supported_msg, clear=False)
-    print_sub_step(" ".join(supported_options))
+    archcraftsman.base.print_step(supported_msg, clear=False)
+    archcraftsman.base.print_sub_step(" ".join(supported_options))
     print("")
 
 
-T = TypeVar("T", bound=OptionEnum)
+T = typing.TypeVar("T", bound=archcraftsman.options.OptionEnum)
 
 
 def prompt_option(
     message: str,
     error_msg: str,
     options: type[T],
-    supported_msg: Optional[str],
-    default: Optional[T],
+    supported_msg: typing.Optional[str],
+    default: typing.Optional[T],
     *ignores: T,
     new_line_prompt: bool = True,
-) -> Optional[T]:
+) -> typing.Optional[T]:
     """
     A method to prompt for a bundle.
     """
     readline.set_completer(
         lambda text, state: (
             [
                 option
@@ -124,33 +118,37 @@
     option_ok = False
     option = None
     while not option_ok:
         prompt_message = message
         if default:
             prompt_message = message % default.value
         if new_line_prompt:
-            option_name = prompt_ln(prompt_message, default=default).lower()
+            option_name = archcraftsman.base.prompt_ln(
+                prompt_message, default=default
+            ).lower()
         else:
-            option_name = prompt(prompt_message, default=default).lower()
+            option_name = archcraftsman.base.prompt(
+                prompt_message, default=default
+            ).lower()
         if option_name in supported_options:
             option_ok = True
             option = options(option_name)
         else:
-            print_error(error_msg % option_name, do_pause=False)
+            archcraftsman.base.print_error(error_msg % option_name, do_pause=False)
             continue
-    readline.set_completer(glob_completer)
+    readline.set_completer(archcraftsman.base.glob_completer)
     return option
 
 
 def ask_keymap(default: str) -> str:
     """
     A method to prompt for a keymap.
     """
     keymaps = (
-        execute(
+        archcraftsman.base.execute(
             "localectl list-keymaps",
             capture_output=True,
             force=True,
         )
         .output.strip()
         .split("\n")
     )
@@ -169,82 +167,84 @@
     while not keymap_ok:
         prompt_message = (
             _(
                 "Type your installation's keymap, or 'help' to get the list of keymaps (%s) : "
             )
             % default
         )
-        keymap = prompt_ln(prompt_message, default=default).lower()
+        keymap = archcraftsman.base.prompt_ln(prompt_message, default=default).lower()
         if keymap == "help":
-            print_help(" ".join(keymaps))
+            archcraftsman.base.print_help(" ".join(keymaps))
             continue
         if keymap in keymaps:
             keymap_ok = True
         else:
-            print_error(_("Keymap '%s' doesn't exist.") % keymap, do_pause=False)
+            archcraftsman.base.print_error(
+                _("Keymap '%s' doesn't exist.") % keymap, do_pause=False
+            )
             continue
-    readline.set_completer(glob_completer)
+    readline.set_completer(archcraftsman.base.glob_completer)
     return keymap
 
 
-def ask_format_type() -> FSFormats:
+def ask_format_type() -> archcraftsman.options.FSFormats:
     """
     The method to ask the user for the format type.
     """
     format_type = prompt_option(
         _("Which format type do you want ? (%s) : "),
         _("Format type '%s' is not supported."),
-        FSFormats,
+        archcraftsman.options.FSFormats,
         _("Supported format types : "),
-        FSFormats.EXT4,
-        FSFormats.VFAT,
+        archcraftsman.options.FSFormats.EXT4,
+        archcraftsman.options.FSFormats.VFAT,
     )
-    return format_type if format_type else FSFormats.EXT4
+    return format_type if format_type else archcraftsman.options.FSFormats.EXT4
 
 
 def ask_encryption_block_name() -> str:
     """
     Method to ask for encryption block name.
     """
     block_name_pattern = re.compile("^[a-z][a-z\\d_]*$")
     block_name_ok = False
     block_name = ""
     while not block_name_ok:
-        block_name = prompt_ln(
+        block_name = archcraftsman.base.prompt_ln(
             _("What will be the encrypted block name ? : "), required=True
         )
         if block_name and not block_name_pattern.match(block_name):
-            print_error(_("Invalid encrypted block name."))
+            archcraftsman.base.print_error(_("Invalid encrypted block name."))
             continue
         block_name_ok = True
     return block_name
 
 
 def ask_password(prompt_message: str, required: bool = False) -> str:
     """
     A method to ask a password to the user.
     """
     password_confirm = None
     password = None
     while password is None or password != password_confirm:
-        password = prompt_passwd(prompt_message, required=required)
-        password_confirm = prompt_passwd(
+        password = archcraftsman.base.prompt_passwd(prompt_message, required=required)
+        password_confirm = archcraftsman.base.prompt_passwd(
             _("Enter it again to confirm : "), required=required
         )
         if password != password_confirm:
-            print_error(_("Passwords entered don't match."))
+            archcraftsman.base.print_error(_("Passwords entered don't match."))
     return password
 
 
 def ask_drive() -> str:
     """
     A method to prompt for a drive to partition.
     """
     drives = (
-        execute(
+        archcraftsman.base.execute(
             "lsblk -lpdno NAME,TYPE | grep disk | awk '{print $1}'",
             capture_output=True,
             force=True,
         )
         .output.strip()
         .split("\n")
     )
@@ -257,36 +257,42 @@
     print_supported(_("Detected drives :"), drives)
     drive_ok = False
     drive = ""
     while not drive_ok:
         prompt_message = _(
             "On which drive should Archlinux be installed ? (type the entire name, for example '/dev/sda') : "
         )
-        drive = prompt_ln(prompt_message).lower()
+        drive = archcraftsman.base.prompt_ln(prompt_message).lower()
         if drive in drives:
             drive_ok = True
         else:
-            print_error(
+            archcraftsman.base.print_error(
                 _("The target drive '%s' doesn't exist.") % drive, do_pause=False
             )
             continue
-    readline.set_completer(glob_completer)
+    readline.set_completer(archcraftsman.base.glob_completer)
     return drive
 
 
 def prompt_bool(
-    message: str, default: bool = True, help_msg: Optional[str] = None
+    message: str, default: bool = True, help_msg: typing.Optional[str] = None
 ) -> bool:
     """
     A method to prompt for a boolean choice.
     """
     message += " ("
     if default:
         message += f"{_('yes').upper()[0]}/{_('no')[0]}"
     else:
         message += f"{_('yes')[0]}/{_('no').upper()[0]}"
-    if help_msg is not None:
+    if help_msg:
         message += "/?"
     message += ") : "
     if not default:
-        return prompt(f"{message}", help_msg=help_msg).upper() == _("yes").upper()[0]
-    return prompt(f"{message}", help_msg=help_msg).upper() != _("no").upper()[0]
+        return (
+            archcraftsman.base.prompt(f"{message}", help_msg=help_msg).upper()
+            == _("yes").upper()[0]
+        )
+    return (
+        archcraftsman.base.prompt(f"{message}", help_msg=help_msg).upper()
+        != _("no").upper()[0]
+    )
```

## archcraftsman/bundles/budgie.py

```diff
@@ -14,27 +14,32 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The budgie bundle module
 """
 
-from archcraftsman import info
-from archcraftsman.base import execute, print_sub_step
-from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import _
-from archcraftsman.utils import prompt_bool
+import archcraftsman.base
+import archcraftsman.bundles.bundle
+import archcraftsman.i18n
+import archcraftsman.info
+import archcraftsman.options
+import archcraftsman.utils
 
+_ = archcraftsman.i18n.translate
 
-class Budgie(Bundle):
+
+class Budgie(archcraftsman.bundles.bundle.Bundle):
     """
     Bundle class.
     """
 
-    display_manager = True
+    def __init__(self):
+        super().__init__(archcraftsman.options.Desktops.BUDGIE)
+        self.display_manager = True
 
     def packages(self) -> list[str]:
         packages = [
             "budgie-desktop",
             "budgie-desktop-view",
             "budgie-screensaver",
             "gnome-control-center",
@@ -51,24 +56,24 @@
         if self.display_manager:
             packages.extend(
                 ["lightdm", "lightdm-gtk-greeter", "lightdm-gtk-greeter-settings"]
             )
         return packages
 
     def prompt_extra(self):
-        self.display_manager = prompt_bool(
+        self.display_manager = archcraftsman.utils.prompt_bool(
             _("The display manager to install is '%s'. Do you want to install it ?")
             % "LightDM",
             default=True,
         )
 
     def print_resume(self):
-        print_sub_step(_("Desktop environment : %s") % self.name)
-        print_sub_step(
+        archcraftsman.base.print_sub_step(_("Desktop environment : %s") % self.name)
+        archcraftsman.base.print_sub_step(
             _("Display manager : %s")
             % ("LightDM" if self.display_manager else _("none"))
         )
 
     def configure(self):
         if self.display_manager:
-            execute('arch-chroot /mnt bash -c "systemctl enable lightdm"')
-        info.ai.pre_launch_info.setup_chroot_keyboard()
+            archcraftsman.base.execute("systemctl enable lightdm", chroot=True)
+        archcraftsman.info.ai.pre_launch_info.setup_chroot_keyboard()
```

## archcraftsman/bundles/bundle.py

```diff
@@ -20,17 +20,29 @@
 
 
 class Bundle:
     """
     A class to represent a bootloader.
     """
 
-    def __init__(self, name: str = ""):
+    def __init__(self, name: str = "") -> None:
         self.name = name
 
+    def prompt(self) -> str:
+        """
+        Bundle's main prompt retrieving method.
+        """
+        return ""
+
+    def help(self) -> str:
+        """
+        Bundle's help retrieving method.
+        """
+        return ""
+
     def packages(self) -> list[str]:
         """
         Bundle's packages retrieving method.
         """
         return []
 
     def is_aur(self) -> bool:
```

## archcraftsman/bundles/cinnamon.py

```diff
@@ -14,27 +14,32 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The cinnamon bundle module
 """
 
-from archcraftsman import info
-from archcraftsman.base import execute, print_sub_step
-from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import _
-from archcraftsman.utils import prompt_bool
+import archcraftsman.base
+import archcraftsman.bundles.bundle
+import archcraftsman.i18n
+import archcraftsman.info
+import archcraftsman.options
+import archcraftsman.utils
 
+_ = archcraftsman.i18n.translate
 
-class Cinnamon(Bundle):
+
+class Cinnamon(archcraftsman.bundles.bundle.Bundle):
     """
     Bundle class.
     """
 
-    display_manager = True
+    def __init__(self):
+        super().__init__(archcraftsman.options.Desktops.CINNAMON)
+        self.display_manager = True
 
     def packages(self) -> list[str]:
         packages = [
             "cinnamon",
             "metacity",
             "gnome-shell",
             "gnome-terminal",
@@ -52,27 +57,27 @@
         if self.display_manager:
             packages.extend(
                 ["lightdm", "lightdm-gtk-greeter", "lightdm-gtk-greeter-settings"]
             )
         return packages
 
     def prompt_extra(self):
-        self.display_manager = prompt_bool(
+        self.display_manager = archcraftsman.utils.prompt_bool(
             _("The display manager to install is '%s'. Do you want to install it ?")
             % "LightDM",
             default=True,
         )
 
     def print_resume(self):
-        print_sub_step(_("Desktop environment : %s") % self.name)
-        print_sub_step(
+        archcraftsman.base.print_sub_step(_("Desktop environment : %s") % self.name)
+        archcraftsman.base.print_sub_step(
             _("Display manager : %s")
             % ("LightDM" if self.display_manager else _("none"))
         )
 
     def configure(self):
         if self.display_manager:
-            execute('arch-chroot /mnt bash -c "systemctl enable lightdm"')
-        execute(
+            archcraftsman.base.execute("systemctl enable lightdm", chroot=True)
+        archcraftsman.base.execute(
             'sed -i "s|#logind-check-graphical=false|logind-check-graphical=true|g" /mnt/etc/lightdm/lightdm.conf'
         )
-        info.ai.pre_launch_info.setup_chroot_keyboard()
+        archcraftsman.info.ai.pre_launch_info.setup_chroot_keyboard()
```

## archcraftsman/bundles/copyacm.py

```diff
@@ -13,36 +13,41 @@
 #
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The copy ArchCraftsman bundle module
 """
-from archcraftsman import info
-from archcraftsman.base import execute, print_sub_step
-from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import _
+import archcraftsman.base
+import archcraftsman.bundles.bundle
+import archcraftsman.i18n
+import archcraftsman.info
+import archcraftsman.options
 
+_ = archcraftsman.i18n.translate
 
-class CopyACM(Bundle):
+
+class CopyACM(archcraftsman.bundles.bundle.Bundle):
     """
     The CopyACM class.
     """
 
+    def __init__(self):
+        super().__init__(archcraftsman.options.Bundles.COPY_ACM)
+
     def print_resume(self):
-        print_sub_step(_("Copy ArchCraftsman to the new system."))
+        archcraftsman.base.print_sub_step(_("Copy ArchCraftsman to the new system."))
 
     def configure(self):
-        if info.ai.system_info.user_name:
-            path = f"/home/{info.ai.system_info.user_name}"
-            execute(f"mkdir -p /mnt{path}")
-            execute(f"cp -r ~/archcraftsman /mnt{path}")
-            execute(
-                (
-                    f'arch-chroot /mnt bash -c "chown -R {info.ai.system_info.user_name}:'
-                    f'{info.ai.system_info.user_name} {path}"'
-                )
+        if archcraftsman.info.ai.system_info.user_name:
+            path = f"/home/{archcraftsman.info.ai.system_info.user_name}"
+            archcraftsman.base.execute(f"mkdir -p /mnt{path}")
+            archcraftsman.base.execute(f"cp -r ~/archcraftsman /mnt{path}")
+            archcraftsman.base.execute(
+                f"chown -R {archcraftsman.info.ai.system_info.user_name}:"
+                f"{archcraftsman.info.ai.system_info.user_name} {path}",
+                chroot=True,
             )
         else:
             path = "/root"
-            execute(f"mkdir -p /mnt{path}")
-            execute(f"cp -r ~/archcraftsman /mnt{path}")
+            archcraftsman.base.execute(f"mkdir -p /mnt{path}")
+            archcraftsman.base.execute(f"cp -r ~/archcraftsman /mnt{path}")
```

## archcraftsman/bundles/cutefish.py

```diff
@@ -14,27 +14,32 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The cutefish bundle module
 """
 
-from archcraftsman import info
-from archcraftsman.base import execute, print_sub_step
-from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import _
-from archcraftsman.utils import prompt_bool
+import archcraftsman.base
+import archcraftsman.bundles.bundle
+import archcraftsman.i18n
+import archcraftsman.info
+import archcraftsman.options
+import archcraftsman.utils
 
+_ = archcraftsman.i18n.translate
 
-class Cutefish(Bundle):
+
+class Cutefish(archcraftsman.bundles.bundle.Bundle):
     """
     Bundle class.
     """
 
-    display_manager = True
+    def __init__(self):
+        super().__init__(archcraftsman.options.Desktops.CUTEFISH)
+        self.display_manager = True
 
     def packages(self) -> list[str]:
         packages = [
             "cutefish",
             "xorg-server",
             "alsa-utils",
             "pulseaudio",
@@ -42,23 +47,23 @@
             "pavucontrol",
         ]
         if self.display_manager:
             packages.extend(["sddm"])
         return packages
 
     def prompt_extra(self):
-        self.display_manager = prompt_bool(
+        self.display_manager = archcraftsman.utils.prompt_bool(
             _("The display manager to install is '%s'. Do you want to install it ?")
             % "SDDM",
             default=True,
         )
 
     def print_resume(self):
-        print_sub_step(_("Desktop environment : %s") % self.name)
-        print_sub_step(
+        archcraftsman.base.print_sub_step(_("Desktop environment : %s") % self.name)
+        archcraftsman.base.print_sub_step(
             _("Display manager : %s") % ("SDDM" if self.display_manager else _("none"))
         )
 
     def configure(self):
         if self.display_manager:
-            execute('arch-chroot /mnt bash -c "systemctl enable sddm"')
-        info.ai.pre_launch_info.setup_chroot_keyboard()
+            archcraftsman.base.execute("systemctl enable sddm", chroot=True)
+        archcraftsman.info.ai.pre_launch_info.setup_chroot_keyboard()
```

## archcraftsman/bundles/deepin.py

```diff
@@ -14,27 +14,32 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The deepin bundle module
 """
 
-from archcraftsman import info
-from archcraftsman.base import execute, print_sub_step
-from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import _
-from archcraftsman.utils import prompt_bool
+import archcraftsman.base
+import archcraftsman.bundles.bundle
+import archcraftsman.i18n
+import archcraftsman.info
+import archcraftsman.options
+import archcraftsman.utils
 
+_ = archcraftsman.i18n.translate
 
-class Deepin(Bundle):
+
+class Deepin(archcraftsman.bundles.bundle.Bundle):
     """
     Bundle class.
     """
 
-    minimal = False
+    def __init__(self):
+        super().__init__(archcraftsman.options.Desktops.DEEPIN)
+        self.minimal = False
 
     def packages(self) -> list[str]:
         packages = [
             "deepin",
             "xorg-server",
             "alsa-utils",
             "pulseaudio",
@@ -43,27 +48,27 @@
         if self.minimal is not True:
             packages.append("deepin-extra")
         else:
             packages.append("deepin-terminal")
         return packages
 
     def print_resume(self):
-        print_sub_step(_("Desktop environment : %s") % self.name)
-        print_sub_step(_("Display manager : %s") % "LightDM")
+        archcraftsman.base.print_sub_step(_("Desktop environment : %s") % self.name)
+        archcraftsman.base.print_sub_step(_("Display manager : %s") % "LightDM")
         if self.minimal:
-            print_sub_step(_("Install a minimal environment."))
+            archcraftsman.base.print_sub_step(_("Install a minimal environment."))
 
     def prompt_extra(self):
-        self.minimal = prompt_bool(
+        self.minimal = archcraftsman.utils.prompt_bool(
             _("Install a minimal environment ?"),
             default=False,
             help_msg=_(
                 "If yes, the script will not install any extra packages, only base packages."
             ),
         )
 
     def configure(self):
-        execute('arch-chroot /mnt bash -c "systemctl enable lightdm"')
-        execute(
+        archcraftsman.base.execute("systemctl enable lightdm", chroot=True)
+        archcraftsman.base.execute(
             'sed -i "s|#logind-check-graphical=false|logind-check-graphical=true|g" /mnt/etc/lightdm/lightdm.conf'
         )
-        info.ai.pre_launch_info.setup_chroot_keyboard()
+        archcraftsman.info.ai.pre_launch_info.setup_chroot_keyboard()
```

## archcraftsman/bundles/enlightenment.py

```diff
@@ -14,25 +14,31 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The enlightenment bundle module
 """
 
-from archcraftsman import info
-from archcraftsman.base import execute, print_sub_step
-from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import _
+import archcraftsman.base
+import archcraftsman.bundles.bundle
+import archcraftsman.i18n
+import archcraftsman.info
+import archcraftsman.options
 
+_ = archcraftsman.i18n.translate
 
-class Enlightenment(Bundle):
+
+class Enlightenment(archcraftsman.bundles.bundle.Bundle):
     """
     Bundle class.
     """
 
+    def __init__(self):
+        super().__init__(archcraftsman.options.Desktops.ENLIGHTENMENT)
+
     def packages(self) -> list[str]:
         packages = [
             "enlightenment",
             "terminology",
             "xorg-server",
             "xorg-xinit",
             "alsa-utils",
@@ -41,13 +47,13 @@
             "pavucontrol",
             "system-config-printer",
             "acpid",
         ]
         return packages
 
     def print_resume(self):
-        print_sub_step(_("Desktop environment : %s") % self.name)
-        print_sub_step(_("Display manager : %s") % _("none"))
+        archcraftsman.base.print_sub_step(_("Desktop environment : %s") % self.name)
+        archcraftsman.base.print_sub_step(_("Display manager : %s") % _("none"))
 
     def configure(self):
-        execute('arch-chroot /mnt bash -c "systemctl enable acpid"')
-        info.ai.pre_launch_info.setup_chroot_keyboard()
+        archcraftsman.base.execute("systemctl enable acpid", chroot=True)
+        archcraftsman.info.ai.pre_launch_info.setup_chroot_keyboard()
```

## archcraftsman/bundles/generateconfig.py

```diff
@@ -14,19 +14,25 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The yay bundle module
 """
 
-from archcraftsman.base import print_sub_step
-from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import _
+import archcraftsman.base
+import archcraftsman.bundles.bundle
+import archcraftsman.i18n
+import archcraftsman.options
 
+_ = archcraftsman.i18n.translate
 
-class GenerateConfig(Bundle):
+
+class GenerateConfig(archcraftsman.bundles.bundle.Bundle):
     """
     The generate configuration shell bundle.
     """
 
+    def __init__(self):
+        super().__init__(archcraftsman.options.ShellBundles.GENERATE_CONFIG)
+
     def print_resume(self):
-        print_sub_step(_("Generate configuration."))
+        archcraftsman.base.print_sub_step(_("Generate configuration."))
```

## archcraftsman/bundles/gnome.py

```diff
@@ -14,51 +14,57 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The gnome bundle module
 """
 
-from archcraftsman import info
-from archcraftsman.base import execute, print_sub_step
-from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import _
-from archcraftsman.utils import prompt_bool
+import archcraftsman.base
+import archcraftsman.bundles.bundle
+import archcraftsman.i18n
+import archcraftsman.info
+import archcraftsman.options
+import archcraftsman.utils
 
+_ = archcraftsman.i18n.translate
 
-class Gnome(Bundle):
+
+class Gnome(archcraftsman.bundles.bundle.Bundle):
     """
     Bundle class.
     """
 
-    minimal = False
+    def __init__(self):
+        super().__init__(archcraftsman.options.Desktops.GNOME)
+        self.minimal = False
 
     def packages(self) -> list[str]:
         packages = [
             "gnome",
             "alsa-utils",
             "pulseaudio",
             "pulseaudio-alsa",
             "xdg-desktop-portal",
             "xdg-desktop-portal-gnome",
             "qt5-wayland",
+            "gst-plugin-pipewire",
         ]
         if self.minimal is not True:
             packages.append("gnome-extra")
         return packages
 
     def print_resume(self):
-        print_sub_step(_("Desktop environment : %s") % self.name)
-        print_sub_step(_("Display manager : %s") % "GDM")
+        archcraftsman.base.print_sub_step(_("Desktop environment : %s") % self.name)
+        archcraftsman.base.print_sub_step(_("Display manager : %s") % "GDM")
 
     def prompt_extra(self):
-        self.minimal = prompt_bool(
+        self.minimal = archcraftsman.utils.prompt_bool(
             _("Install a minimal environment ?"),
             default=False,
             help_msg=_(
                 "If yes, the script will not install any extra packages, only base packages."
             ),
         )
 
     def configure(self):
-        execute('arch-chroot /mnt bash -c "systemctl enable gdm"')
-        info.ai.pre_launch_info.setup_chroot_keyboard()
+        archcraftsman.base.execute("systemctl enable gdm", chroot=True)
+        archcraftsman.info.ai.pre_launch_info.setup_chroot_keyboard()
```

## archcraftsman/bundles/grmlzsh.py

```diff
@@ -14,29 +14,37 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The grml zsh bundle module
 """
 
-from archcraftsman import info
-from archcraftsman.base import execute, print_sub_step
-from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import _
+import archcraftsman.base
+import archcraftsman.bundles.bundle
+import archcraftsman.i18n
+import archcraftsman.info
+import archcraftsman.options
 
+_ = archcraftsman.i18n.translate
 
-class GrmlZsh(Bundle):
+
+class GrmlZsh(archcraftsman.bundles.bundle.Bundle):
     """
     Grml ZSH config class.
     """
 
+    def __init__(self):
+        super().__init__(archcraftsman.options.Bundles.GRML)
+
     def packages(self) -> list[str]:
         return ["zsh", "zsh-completions", "grml-zsh-config"]
 
     def print_resume(self):
-        print_sub_step(_("Install ZSH with GRML configuration."))
+        archcraftsman.base.print_sub_step(_("Install ZSH with GRML configuration."))
 
     def configure(self):
-        execute('arch-chroot /mnt bash -c "chsh --shell /bin/zsh"')
-        execute(
-            f'arch-chroot /mnt bash -c "chsh --shell /bin/zsh {info.ai.system_info.user_name}"'
-        )
+        archcraftsman.base.execute("chsh --shell /bin/zsh", chroot=True)
+        if archcraftsman.info.ai.system_info.user_name:
+            archcraftsman.base.execute(
+                f"chsh --shell /bin/zsh {archcraftsman.info.ai.system_info.user_name}",
+                chroot=True,
+            )
```

## archcraftsman/bundles/grub.py

```diff
@@ -15,93 +15,99 @@
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The grub bundle module
 """
 import re
 
-from archcraftsman import info
-from archcraftsman.base import execute, is_bios
-from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.options import FSFormats, PartTypes
+import archcraftsman.base
+import archcraftsman.bundles.bundle
+import archcraftsman.info
+import archcraftsman.options
 
 
-class Grub(Bundle):
+class Grub(archcraftsman.bundles.bundle.Bundle):
     """
     The Grub Bootloader class.
     """
 
+    def __init__(self):
+        super().__init__(archcraftsman.options.BootLoaders.GRUB)
+
     def packages(self) -> list[str]:
         return ["grub"]
 
     def configure(self):
-        if is_bios():
-            execute(
-                f'arch-chroot /mnt bash -c "grub-install --target=i386-pc {info.ai.partitioning_info.main_disk}"'
+        if archcraftsman.base.is_bios():
+            archcraftsman.base.execute(
+                f"grub-install --target=i386-pc {archcraftsman.info.ai.partitioning_info.main_disk}",
+                chroot=True,
             )
         else:
-            execute(
-                'arch-chroot /mnt bash -c "grub-install --target=x86_64-efi --efi-directory=/boot/efi '
-                "--bootloader-id='Arch Linux'\""
+            archcraftsman.base.execute(
+                "grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id='Arch Linux'",
+                chroot=True,
             )
-        execute(
+        archcraftsman.base.execute(
             'sed -i "/^GRUB_CMDLINE_LINUX=.*/a GRUB_DISABLE_OS_PROBER=false" /mnt/etc/default/grub'
         )
 
-        if info.ai.partitioning_info.root_partition().encrypted:
-            hooks = execute(
+        if archcraftsman.info.ai.partitioning_info.root_partition().encrypted:
+            hooks = archcraftsman.base.execute(
                 "grep -e '^HOOKS' /mnt/etc/mkinitcpio.conf",
                 check=False,
                 capture_output=True,
             ).output.strip()
             pattern = re.compile(r"^HOOKS=\((.+)\)")
             hooks_match = pattern.search(hooks)
             if hooks_match:
                 extracted_hooks = hooks_match.group(1).split(" ")
                 extracted_hooks.insert(extracted_hooks.index("filesystems"), "encrypt")
             else:
                 extracted_hooks = ["encrypt"]
             processed_hooks = f"HOOKS=({' '.join(extracted_hooks)})"
-            execute(f"sed -i 's|{hooks}|{processed_hooks}|g' /mnt/etc/mkinitcpio.conf")
-            execute('arch-chroot /mnt bash -c "mkinitcpio -P"')
+            archcraftsman.base.execute(
+                f"sed -i 's|{hooks}|{processed_hooks}|g' /mnt/etc/mkinitcpio.conf"
+            )
+            archcraftsman.base.execute("mkinitcpio -P", chroot=True)
 
-            grub_cmdline = execute(
+            grub_cmdline = archcraftsman.base.execute(
                 "grep -e '^GRUB_CMDLINE_LINUX_DEFAULT' /mnt/etc/default/grub",
                 check=False,
                 capture_output=True,
             ).output.strip()
             pattern = re.compile(r'^GRUB_CMDLINE_LINUX_DEFAULT="(.+)"')
             grub_cmdline_match = pattern.search(grub_cmdline)
             if grub_cmdline_match:
                 extracted_grub_cmdline = grub_cmdline_match.group(1).split(" ")
             else:
                 extracted_grub_cmdline = []
             extracted_grub_cmdline.append(
-                f"cryptdevice=UUID={info.ai.partitioning_info.root_partition().uuid()}:root"
+                f"cryptdevice=UUID={archcraftsman.info.ai.partitioning_info.root_partition().uuid()}:root"
             )
             processed_grub_cmdline = (
                 f"GRUB_CMDLINE_LINUX_DEFAULT=\"{' '.join(extracted_grub_cmdline)}\""
             )
-            execute(
+            archcraftsman.base.execute(
                 f"sed -i 's|{grub_cmdline}|{processed_grub_cmdline}|g' /mnt/etc/default/grub"
             )
 
         for partition in [
             part
-            for part in info.ai.partitioning_info.partitions
-            if part.encrypted and part.part_type != PartTypes.ROOT
+            for part in archcraftsman.info.ai.partitioning_info.partitions
+            if part.encrypted and part.part_type != archcraftsman.options.PartTypes.ROOT
         ]:
-            execute(
+            archcraftsman.base.execute(
                 f'echo "{partition.block_name} UUID={partition.uuid()} none" >> /mnt/etc/crypttab'
             )
 
         if (
-            info.ai.partitioning_info.root_partition().part_format_type
-            == FSFormats.EXT4
+            archcraftsman.info.ai.partitioning_info.root_partition().part_format_type
+            == archcraftsman.options.FSFormats.EXT4
         ):
-            execute(
+            archcraftsman.base.execute(
                 'sed -i "s|GRUB_DEFAULT=.*|GRUB_DEFAULT=saved|g" /mnt/etc/default/grub'
             )
-            execute(
+            archcraftsman.base.execute(
                 'sed -i "/^GRUB_DEFAULT=.*/a GRUB_SAVEDEFAULT=true" /mnt/etc/default/grub'
             )
-        execute('arch-chroot /mnt bash -c "grub-mkconfig -o /boot/grub/grub.cfg"')
+        archcraftsman.base.execute("grub-mkconfig -o /boot/grub/grub.cfg", chroot=True)
```

## archcraftsman/bundles/i3.py

```diff
@@ -14,25 +14,31 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The i3 bundle module
 """
 
-from archcraftsman import info
-from archcraftsman.base import execute, print_sub_step
-from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import _
+import archcraftsman.base
+import archcraftsman.bundles.bundle
+import archcraftsman.i18n
+import archcraftsman.info
+import archcraftsman.options
 
+_ = archcraftsman.i18n.translate
 
-class I3(Bundle):
+
+class I3(archcraftsman.bundles.bundle.Bundle):
     """
     Bundle class.
     """
 
+    def __init__(self):
+        super().__init__(archcraftsman.options.Desktops.I3)
+
     def packages(self) -> list[str]:
         packages = [
             "i3",
             "rofi",
             "dmenu",
             "perl",
             "alacritty",
@@ -46,13 +52,13 @@
             "acpid",
             "gnome-keyring",
             "dex",
         ]
         return packages
 
     def print_resume(self):
-        print_sub_step(_("Desktop environment : %s") % self.name)
-        print_sub_step(_("Display manager : %s") % _("none"))
+        archcraftsman.base.print_sub_step(_("Desktop environment : %s") % self.name)
+        archcraftsman.base.print_sub_step(_("Display manager : %s") % _("none"))
 
     def configure(self):
-        execute('arch-chroot /mnt bash -c "systemctl enable acpid"')
-        info.ai.pre_launch_info.setup_chroot_keyboard()
+        archcraftsman.base.execute("systemctl enable acpid", chroot=True)
+        archcraftsman.info.ai.pre_launch_info.setup_chroot_keyboard()
```

## archcraftsman/bundles/iwd.py

```diff
@@ -14,29 +14,35 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The network manager bundle module
 """
 
-from archcraftsman.base import execute, print_sub_step
-from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.bundles.systemdnet import SystemdNet
-from archcraftsman.i18n import _
+import archcraftsman.base
+import archcraftsman.bundles.bundle
+import archcraftsman.bundles.systemdnet
+import archcraftsman.i18n
+import archcraftsman.options
 
+_ = archcraftsman.i18n.translate
 
-class Iwd(Bundle):
+
+class Iwd(archcraftsman.bundles.bundle.Bundle):
     """
-    Grml ZSH config class.
+    Iwd config class.
     """
 
+    def __init__(self):
+        super().__init__(archcraftsman.options.Network.IWD)
+
     def packages(self) -> list[str]:
         packages = ["iwd"]
         return packages
 
     def print_resume(self):
-        print_sub_step(_("Install Iwd."))
-        SystemdNet(self.name).print_resume()
+        archcraftsman.base.print_sub_step(_("Install Iwd."))
+        archcraftsman.bundles.systemdnet.SystemdNet().print_resume()
 
     def configure(self):
-        execute('arch-chroot /mnt bash -c "systemctl enable iwd.service"')
-        SystemdNet(self.name).configure()
+        archcraftsman.base.execute("systemctl enable iwd.service", chroot=True)
+        archcraftsman.bundles.systemdnet.SystemdNet().configure()
```

## archcraftsman/bundles/linux.py

```diff
@@ -13,59 +13,73 @@
 #
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 All supported linux kernel bundles module
 """
-from archcraftsman.base import print_sub_step
-from archcraftsman.bundles import bundle
-from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import _
+import archcraftsman.base
+import archcraftsman.bundles.bundle
+import archcraftsman.i18n
+import archcraftsman.options
 
+_ = archcraftsman.i18n.translate
 
-class LinuxCurrent(bundle.Bundle):
+
+class LinuxCurrent(archcraftsman.bundles.bundle.Bundle):
     """
     The Linux current kernel class.
     """
 
+    def __init__(self):
+        super().__init__(archcraftsman.options.Kernels.CURRENT)
+
     def packages(self) -> list[str]:
         return ["linux", "linux-headers"]
 
     def print_resume(self):
-        print_sub_step(_("Install Linux current kernel."))
+        archcraftsman.base.print_sub_step(_("Install Linux current kernel."))
 
 
-class LinuxHardened(Bundle):
+class LinuxHardened(archcraftsman.bundles.bundle.Bundle):
     """
     The Linux hardened kernel class.
     """
 
+    def __init__(self):
+        super().__init__(archcraftsman.options.Kernels.HARDENED)
+
     def packages(self) -> list[str]:
         return ["linux-hardened", "linux-hardened-headers"]
 
     def print_resume(self):
-        print_sub_step(_("Install Linux hardened kernel."))
+        archcraftsman.base.print_sub_step(_("Install Linux hardened kernel."))
 
 
-class LinuxLts(bundle.Bundle):
+class LinuxLts(archcraftsman.bundles.bundle.Bundle):
     """
     The Linux LTS kernel class.
     """
 
+    def __init__(self):
+        super().__init__(archcraftsman.options.Kernels.LTS)
+
     def packages(self) -> list[str]:
         return ["linux-lts", "linux-lts-headers"]
 
     def print_resume(self):
-        print_sub_step(_("Install Linux LTS kernel."))
+        archcraftsman.base.print_sub_step(_("Install Linux LTS kernel."))
 
 
-class LinuxZen(bundle.Bundle):
+class LinuxZen(archcraftsman.bundles.bundle.Bundle):
     """
     The Linux zen kernel class.
     """
 
+    def __init__(self):
+        super().__init__(archcraftsman.options.Kernels.ZEN)
+
     def packages(self) -> list[str]:
         return ["linux-zen", "linux-zen-headers"]
 
     def print_resume(self):
-        print_sub_step(_("Install Linux zen kernel."))
+        archcraftsman.base.print_sub_step(_("Install Linux zen kernel."))
```

## archcraftsman/bundles/lxqt.py

```diff
@@ -14,27 +14,32 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The lxqt bundle module
 """
 
-from archcraftsman import info
-from archcraftsman.base import execute, print_sub_step
-from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import _
-from archcraftsman.utils import prompt_bool
+import archcraftsman.base
+import archcraftsman.bundles.bundle
+import archcraftsman.i18n
+import archcraftsman.info
+import archcraftsman.options
+import archcraftsman.utils
 
+_ = archcraftsman.i18n.translate
 
-class Lxqt(Bundle):
+
+class Lxqt(archcraftsman.bundles.bundle.Bundle):
     """
     Bundle class.
     """
 
-    display_manager = True
+    def __init__(self):
+        super().__init__(archcraftsman.options.Desktops.LXQT)
+        self.display_manager = True
 
     def packages(self) -> list[str]:
         packages = [
             "lxqt",
             "xorg-server",
             "breeze-icons",
             "xdg-utils",
@@ -52,23 +57,23 @@
             "pavucontrol",
         ]
         if self.display_manager:
             packages.extend(["sddm"])
         return packages
 
     def prompt_extra(self):
-        self.display_manager = prompt_bool(
+        self.display_manager = archcraftsman.utils.prompt_bool(
             _("The display manager to install is '%s'. Do you want to install it ?")
             % "SDDM",
             default=True,
         )
 
     def print_resume(self):
-        print_sub_step(_("Desktop environment : %s") % self.name)
-        print_sub_step(
+        archcraftsman.base.print_sub_step(_("Desktop environment : %s") % self.name)
+        archcraftsman.base.print_sub_step(
             _("Display manager : %s") % ("SDDM" if self.display_manager else _("none"))
         )
 
     def configure(self):
         if self.display_manager:
-            execute('arch-chroot /mnt bash -c "systemctl enable sddm"')
-        info.ai.pre_launch_info.setup_chroot_keyboard()
+            archcraftsman.base.execute("systemctl enable sddm", chroot=True)
+        archcraftsman.info.ai.pre_launch_info.setup_chroot_keyboard()
```

## archcraftsman/bundles/mate.py

```diff
@@ -14,28 +14,33 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The mate bundle module
 """
 
-from archcraftsman import info
-from archcraftsman.base import execute, print_sub_step
-from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import _
-from archcraftsman.utils import prompt_bool
+import archcraftsman.base
+import archcraftsman.bundles.bundle
+import archcraftsman.i18n
+import archcraftsman.info
+import archcraftsman.options
+import archcraftsman.utils
 
+_ = archcraftsman.i18n.translate
 
-class Mate(Bundle):
+
+class Mate(archcraftsman.bundles.bundle.Bundle):
     """
     Bundle class.
     """
 
-    display_manager = True
-    minimal = False
+    def __init__(self):
+        super().__init__(archcraftsman.options.Desktops.MATE)
+        self.display_manager = True
+        self.minimal = False
 
     def packages(self) -> list[str]:
         packages = [
             "mate",
             "xorg-server",
             "alsa-utils",
             "pulseaudio",
@@ -48,36 +53,36 @@
         if self.minimal is not True:
             packages.append("mate-extra")
         else:
             packages.append("mate-terminal")
         return packages
 
     def print_resume(self):
-        print_sub_step(_("Desktop environment : %s") % self.name)
-        print_sub_step(
+        archcraftsman.base.print_sub_step(_("Desktop environment : %s") % self.name)
+        archcraftsman.base.print_sub_step(
             _("Display manager : %s")
             % ("LightDM" if self.display_manager else _("none"))
         )
         if self.minimal:
-            print_sub_step(_("Install a minimal environment."))
+            archcraftsman.base.print_sub_step(_("Install a minimal environment."))
 
     def prompt_extra(self):
-        self.display_manager = prompt_bool(
+        self.display_manager = archcraftsman.utils.prompt_bool(
             _("The display manager to install is '%s'. Do you want to install it ?")
             % "LightDM",
             default=True,
         )
-        self.minimal = prompt_bool(
+        self.minimal = archcraftsman.utils.prompt_bool(
             _("Install a minimal environment ?"),
             default=False,
             help_msg=_(
                 "If yes, the script will not install any extra packages, only base packages."
             ),
         )
 
     def configure(self):
         if self.display_manager:
-            execute('arch-chroot /mnt bash -c "systemctl enable lightdm"')
-        execute(
+            archcraftsman.base.execute("systemctl enable lightdm", chroot=True)
+        archcraftsman.base.execute(
             'sed -i "s|#logind-check-graphical=false|logind-check-graphical=true|g" /mnt/etc/lightdm/lightdm.conf'
         )
-        info.ai.pre_launch_info.setup_chroot_keyboard()
+        archcraftsman.info.ai.pre_launch_info.setup_chroot_keyboard()
```

## archcraftsman/bundles/microcodes.py

```diff
@@ -14,49 +14,55 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The microcodes auto-installation bundle module
 """
 import re
-from typing import Optional
+import typing
 
-from archcraftsman.base import execute, print_sub_step
-from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import _
+import archcraftsman.base
+import archcraftsman.bundles.bundle
+import archcraftsman.i18n
+import archcraftsman.options
 
+_ = archcraftsman.i18n.translate
 
-class Microcodes(Bundle):
+
+class Microcodes(archcraftsman.bundles.bundle.Bundle):
     """
     The Microcodes class.
     """
 
-    def __init__(self, name: str = ""):
-        super().__init__(name)
-        cpu_info_vendor = execute(
+    def __init__(self):
+        super().__init__(archcraftsman.options.Bundles.MICROCODES)
+        self._cpu_info_vendor = archcraftsman.base.execute(
             'grep </proc/cpuinfo "vendor" | uniq', force=True, capture_output=True
         ).output
-        if cpu_info_vendor:
-            self.microcode_name = re.sub("\\s+", "", cpu_info_vendor).split(":")[1]
-        else:
-            self.microcode_name = ""
+        self._microcode_name = (
+            re.sub("\\s+", "", self._cpu_info_vendor).split(":")[1]
+            if self._cpu_info_vendor
+            else ""
+        )
 
     def packages(self) -> list[str]:
-        if self.microcode_name == "GenuineIntel":
+        if self._microcode_name == "GenuineIntel":
             return ["intel-ucode"]
-        if self.microcode_name == "AuthenticAMD":
+        if self._microcode_name == "AuthenticAMD":
             return ["amd-ucode"]
         return []
 
-    def microcode_img(self) -> Optional[str]:
+    def microcode_img(self) -> typing.Optional[str]:
         """
         The microcode img file name retrieving method.
         """
-        if self.microcode_name == "GenuineIntel":
+        if self._microcode_name == "GenuineIntel":
             return "/intel-ucode.img"
-        if self.microcode_name == "AuthenticAMD":
+        if self._microcode_name == "AuthenticAMD":
             return "/amd-ucode.img"
         return None
 
     def print_resume(self):
-        if self.microcode_name in {"GenuineIntel", "AuthenticAMD"}:
-            print_sub_step(_("Microcodes to install : %s") % self.microcode_name)
+        if self._microcode_name in {"GenuineIntel", "AuthenticAMD"}:
+            archcraftsman.base.print_sub_step(
+                _("Microcodes to install : %s") % self._microcode_name
+            )
```

## archcraftsman/bundles/networkmanager.py

```diff
@@ -14,38 +14,43 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The network manager bundle module
 """
 
-from archcraftsman import info
-from archcraftsman.base import execute, print_sub_step
-from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import _
-from archcraftsman.options import Desktops
+import archcraftsman.base
+import archcraftsman.bundles.bundle
+import archcraftsman.i18n
+import archcraftsman.info
+import archcraftsman.options
 
+_ = archcraftsman.i18n.translate
 
-class NetworkManager(Bundle):
+
+class NetworkManager(archcraftsman.bundles.bundle.Bundle):
     """
     Grml ZSH config class.
     """
 
+    def __init__(self):
+        super().__init__(archcraftsman.options.Network.NETWORK_MANAGER)
+
     def packages(self) -> list[str]:
         packages = ["networkmanager"]
-        if info.ai.system_info.desktop().name in [
-            Desktops.BUDGIE,
-            Desktops.I3,
-            Desktops.LXQT,
-            Desktops.MATE,
-            Desktops.SWAY,
-            Desktops.ENLIGHTENMENT,
-            Desktops.XFCE,
+        if archcraftsman.info.ai.system_info.desktop().name in [
+            archcraftsman.options.Desktops.BUDGIE,
+            archcraftsman.options.Desktops.I3,
+            archcraftsman.options.Desktops.LXQT,
+            archcraftsman.options.Desktops.MATE,
+            archcraftsman.options.Desktops.SWAY,
+            archcraftsman.options.Desktops.ENLIGHTENMENT,
+            archcraftsman.options.Desktops.XFCE,
         ]:
             packages.append("network-manager-applet")
         return packages
 
     def print_resume(self):
-        print_sub_step(_("Install NetworkManager."))
+        archcraftsman.base.print_sub_step(_("Install NetworkManager."))
 
     def configure(self):
-        execute('arch-chroot /mnt bash -c "systemctl enable NetworkManager"')
+        archcraftsman.base.execute("systemctl enable NetworkManager", chroot=True)
```

## archcraftsman/bundles/nvidia.py

```diff
@@ -13,29 +13,35 @@
 #
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The nvidia proprietary driver bundle module
 """
-from archcraftsman import info
-from archcraftsman.base import print_sub_step
-from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import _
-from archcraftsman.options import Kernels
+import archcraftsman.base
+import archcraftsman.bundles.bundle
+import archcraftsman.i18n
+import archcraftsman.info
+import archcraftsman.options
 
+_ = archcraftsman.i18n.translate
 
-class NvidiaDriver(Bundle):
+
+class NvidiaDriver(archcraftsman.bundles.bundle.Bundle):
     """
     The Nvidia driver class.
     """
 
+    def __init__(self):
+        super().__init__(archcraftsman.options.Bundles.NVIDIA)
+
     def packages(self) -> list[str]:
         if (
-            info.ai.system_info.kernel()
-            and info.ai.system_info.kernel().name == Kernels.LTS
+            archcraftsman.info.ai.system_info.kernel()
+            and archcraftsman.info.ai.system_info.kernel().name
+            == archcraftsman.options.Kernels.LTS
         ):
             return ["nvidia-lts"]
         return ["nvidia"]
 
     def print_resume(self):
-        print_sub_step(_("Install proprietary Nvidia driver."))
+        archcraftsman.base.print_sub_step(_("Install proprietary Nvidia driver."))
```

## archcraftsman/bundles/plasma.py

```diff
@@ -14,69 +14,79 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The plasma bundle module
 """
 
-from archcraftsman import info
-from archcraftsman.base import execute, print_sub_step
-from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import _
-from archcraftsman.options import Bundles
-from archcraftsman.utils import prompt_bool
+import archcraftsman.base
+import archcraftsman.bundles.bundle
+import archcraftsman.i18n
+import archcraftsman.info
+import archcraftsman.options
+import archcraftsman.utils
 
+_ = archcraftsman.i18n.translate
 
-class Plasma(Bundle):
+
+class Plasma(archcraftsman.bundles.bundle.Bundle):
     """
     Bundle class.
     """
 
-    minimal = False
-    plasma_wayland = False
+    def __init__(self):
+        super().__init__(archcraftsman.options.Desktops.PLASMA)
+        self.minimal = False
+        self.plasma_wayland = False
 
     def packages(self) -> list[str]:
         packages = [
             "plasma",
             "xorg-server",
             "alsa-utils",
             "pulseaudio",
             "pulseaudio-alsa",
             "xdg-desktop-portal",
             "xdg-desktop-portal-kde",
         ]
         if self.plasma_wayland:
             packages.extend(["plasma-wayland-session", "qt5-wayland"])
-            if info.ai.system_info.others() and Bundles.NVIDIA in [
-                bundle.name for bundle in info.ai.system_info.others()
-            ]:
+            if (
+                archcraftsman.info.ai.system_info.others()
+                and archcraftsman.options.Bundles.NVIDIA
+                in [
+                    bundle.name for bundle in archcraftsman.info.ai.system_info.others()
+                ]
+            ):
                 packages.append("egl-wayland")
             if self.minimal is not True:
                 packages.append("kde-applications")
             else:
                 packages.append("konsole")
 
         return packages
 
     def print_resume(self):
-        print_sub_step(_("Desktop environment : %s") % self.name)
-        print_sub_step(_("Display manager : %s") % "SDDM")
+        archcraftsman.base.print_sub_step(_("Desktop environment : %s") % self.name)
+        archcraftsman.base.print_sub_step(_("Display manager : %s") % "SDDM")
         if self.minimal:
-            print_sub_step(_("Install a minimal environment."))
+            archcraftsman.base.print_sub_step(_("Install a minimal environment."))
         if self.plasma_wayland:
-            print_sub_step(_("Install Wayland support for the plasma session."))
+            archcraftsman.base.print_sub_step(
+                _("Install Wayland support for the plasma session.")
+            )
 
     def prompt_extra(self):
-        self.minimal = prompt_bool(
+        self.minimal = archcraftsman.utils.prompt_bool(
             _("Install a minimal environment ?"),
             default=False,
             help_msg=_(
                 "If yes, the script will not install any extra packages, only base packages."
             ),
         )
-        self.plasma_wayland = prompt_bool(
+        self.plasma_wayland = archcraftsman.utils.prompt_bool(
             _("Install Wayland support for the plasma session ?"), default=False
         )
 
     def configure(self):
-        execute('arch-chroot /mnt bash -c "systemctl enable sddm"')
-        info.ai.pre_launch_info.setup_chroot_keyboard()
+        archcraftsman.base.execute("systemctl enable sddm", chroot=True)
+        archcraftsman.info.ai.pre_launch_info.setup_chroot_keyboard()
```

## archcraftsman/bundles/sway.py

```diff
@@ -14,25 +14,31 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The sway bundle module
 """
 
-from archcraftsman import info
-from archcraftsman.base import execute, print_sub_step
-from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import _
+import archcraftsman.base
+import archcraftsman.bundles.bundle
+import archcraftsman.i18n
+import archcraftsman.info
+import archcraftsman.options
 
+_ = archcraftsman.i18n.translate
 
-class Sway(Bundle):
+
+class Sway(archcraftsman.bundles.bundle.Bundle):
     """
     Bundle class.
     """
 
+    def __init__(self):
+        super().__init__(archcraftsman.options.Desktops.SWAY)
+
     def packages(self) -> list[str]:
         packages = [
             "sway",
             "dmenu",
             "bemenu-wayland",
             "j4-dmenu-desktop",
             "foot",
@@ -62,15 +68,17 @@
             "gnome-keyring",
             "xdg-desktop-portal",
             "xdg-desktop-portal-wlr",
         ]
         return packages
 
     def print_resume(self):
-        print_sub_step(_("Desktop environment : %s") % self.name)
-        print_sub_step(_("Display manager : %s") % _("none"))
+        archcraftsman.base.print_sub_step(_("Desktop environment : %s") % self.name)
+        archcraftsman.base.print_sub_step(_("Display manager : %s") % _("none"))
 
     def configure(self):
-        execute('arch-chroot /mnt bash -c "systemctl enable acpid"')
-        info.ai.pre_launch_info.setup_chroot_keyboard()
-        if "fr" in info.ai.pre_launch_info.keymap:
-            execute("echo 'XKB_DEFAULT_LAYOUT=fr' >> /mnt/etc/environment")
+        archcraftsman.base.execute("systemctl enable acpid", chroot=True)
+        archcraftsman.info.ai.pre_launch_info.setup_chroot_keyboard()
+        if "fr" in archcraftsman.info.ai.pre_launch_info.keymap:
+            archcraftsman.base.execute(
+                "echo 'XKB_DEFAULT_LAYOUT=fr' >> /mnt/etc/environment"
+            )
```

## archcraftsman/bundles/systemdnet.py

```diff
@@ -14,28 +14,36 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The systemd network bundle module
 """
 
-from archcraftsman.base import execute, print_sub_step
-from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import _
+import archcraftsman.base
+import archcraftsman.bundles.bundle
+import archcraftsman.i18n
+import archcraftsman.options
 
+_ = archcraftsman.i18n.translate
 
-class SystemdNet(Bundle):
+
+class SystemdNet(archcraftsman.bundles.bundle.Bundle):
     """
     Grml ZSH config class.
     """
 
+    def __init__(self):
+        super().__init__(archcraftsman.options.Network.SYSTEMD)
+
     def packages(self) -> list[str]:
         return ["systemd-resolvconf"]
 
     def print_resume(self):
-        print_sub_step(_("Enable systemd network stack."))
+        archcraftsman.base.print_sub_step(_("Enable systemd network stack."))
 
     def configure(self):
-        execute("ln -sf /run/systemd/resolve/stub-resolv.conf /mnt/etc/resolv.conf")
-        execute("cp -r /etc/systemd/network /mnt/etc/systemd/")
-        execute('arch-chroot /mnt bash -c "systemctl enable systemd-networkd"')
-        execute('arch-chroot /mnt bash -c "systemctl enable systemd-resolved"')
+        archcraftsman.base.execute(
+            "ln -sf /run/systemd/resolve/stub-resolv.conf /mnt/etc/resolv.conf"
+        )
+        archcraftsman.base.execute("cp -r /etc/systemd/network /mnt/etc/systemd/")
+        archcraftsman.base.execute("systemctl enable systemd-networkd", chroot=True)
+        archcraftsman.base.execute("systemctl enable systemd-resolved", chroot=True)
```

## archcraftsman/bundles/terminus.py

```diff
@@ -14,28 +14,34 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The terminus console font bundle module
 """
 
-from archcraftsman import info
-from archcraftsman.base import execute, print_sub_step
-from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import _
+import archcraftsman.base
+import archcraftsman.bundles.bundle
+import archcraftsman.i18n
+import archcraftsman.info
+import archcraftsman.options
 
+_ = archcraftsman.i18n.translate
 
-class TerminusFont(Bundle):
+
+class TerminusFont(archcraftsman.bundles.bundle.Bundle):
     """
     The Terminus console font class.
     """
 
+    def __init__(self):
+        super().__init__(archcraftsman.options.Bundles.TERMINUS)
+
     def packages(self) -> list[str]:
         return ["terminus-font"]
 
     def print_resume(self):
-        print_sub_step(_("Install terminus console font."))
+        archcraftsman.base.print_sub_step(_("Install terminus console font."))
 
     def configure(self):
-        execute(
-            f'echo "FONT={info.ai.pre_launch_info.live_console_font}" >>/mnt/etc/vconsole.conf'
+        archcraftsman.base.execute(
+            f'echo "FONT={archcraftsman.info.ai.pre_launch_info.live_console_font}" >>/mnt/etc/vconsole.conf'
         )
```

## archcraftsman/bundles/utils.py

```diff
@@ -13,155 +13,92 @@
 #
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The bundles related utility methods and tools module
 """
-from typing import Optional, TypeVar
+import importlib
+import importlib.resources
+import typing
 
-from archcraftsman.bundles.budgie import Budgie
-from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.bundles.cinnamon import Cinnamon
-from archcraftsman.bundles.copyacm import CopyACM
-from archcraftsman.bundles.cups import Cups
-from archcraftsman.bundles.cutefish import Cutefish
-from archcraftsman.bundles.deepin import Deepin
-from archcraftsman.bundles.enlightenment import Enlightenment
-from archcraftsman.bundles.generateconfig import GenerateConfig
-from archcraftsman.bundles.gnome import Gnome
-from archcraftsman.bundles.grmlzsh import GrmlZsh
-from archcraftsman.bundles.grub import Grub
-from archcraftsman.bundles.i3 import I3
-from archcraftsman.bundles.iwd import Iwd
-from archcraftsman.bundles.linux import LinuxCurrent, LinuxHardened, LinuxLts, LinuxZen
-from archcraftsman.bundles.lxqt import Lxqt
-from archcraftsman.bundles.mainfilesystems import MainFileSystems
-from archcraftsman.bundles.mainfonts import MainFonts
-from archcraftsman.bundles.mate import Mate
-from archcraftsman.bundles.microcodes import Microcodes
-from archcraftsman.bundles.networkmanager import NetworkManager
-from archcraftsman.bundles.nvidia import NvidiaDriver
-from archcraftsman.bundles.pipewire import PipeWire
-from archcraftsman.bundles.plasma import Plasma
-from archcraftsman.bundles.sway import Sway
-from archcraftsman.bundles.systemdnet import SystemdNet
-from archcraftsman.bundles.terminus import TerminusFont
-from archcraftsman.bundles.xfce import Xfce
-from archcraftsman.bundles.yay import Yay
-from archcraftsman.bundles.zram import Zram
-from archcraftsman.options import (
-    BootLoaders,
-    Bundles,
-    Desktops,
-    Kernels,
-    Network,
-    OptionEnum,
-    ShellBundles,
-)
-from archcraftsman.utils import prompt_option
+import archcraftsman.bundles.bundle
+import archcraftsman.options
+import archcraftsman.utils
 
 
-def get_bundle_type_by_name(name: str) -> type[Bundle]:
+def get_all_bundle_types() -> list[type[archcraftsman.bundles.bundle.Bundle]]:
+    """
+    A function to get all available bundles.
+    """
+    for name in list(
+        f'archcraftsman.bundles.{resource.name.replace(".py", "")}'
+        for resource in importlib.resources.files("archcraftsman.bundles").iterdir()
+        if resource.is_file()
+        and resource.name.endswith(".py")
+        and resource.name != "__init__.py"
+    ):
+        importlib.import_module(name)
+    return archcraftsman.bundles.bundle.Bundle.__subclasses__()
+
+
+_BUNDLES_MAP: dict[str, type[archcraftsman.bundles.bundle.Bundle]] = {
+    bundle().name: bundle for bundle in get_all_bundle_types()
+}
+
+
+def get_bundle_type_by_name(name: str) -> type[archcraftsman.bundles.bundle.Bundle]:
     """
     A function to get the bundle type by its name.
     """
-    match name:
-        case Kernels.CURRENT:
-            bundle = LinuxCurrent
-        case Kernels.LTS:
-            bundle = LinuxLts
-        case Kernels.ZEN:
-            bundle = LinuxZen
-        case Kernels.HARDENED:
-            bundle = LinuxHardened
-        case BootLoaders.GRUB:
-            bundle = Grub
-        case Desktops.GNOME:
-            bundle = Gnome
-        case Desktops.PLASMA:
-            bundle = Plasma
-        case Desktops.XFCE:
-            bundle = Xfce
-        case Desktops.BUDGIE:
-            bundle = Budgie
-        case Desktops.CINNAMON:
-            bundle = Cinnamon
-        case Desktops.CUTEFISH:
-            bundle = Cutefish
-        case Desktops.DEEPIN:
-            bundle = Deepin
-        case Desktops.LXQT:
-            bundle = Lxqt
-        case Desktops.MATE:
-            bundle = Mate
-        case Desktops.ENLIGHTENMENT:
-            bundle = Enlightenment
-        case Desktops.I3:
-            bundle = I3
-        case Desktops.SWAY:
-            bundle = Sway
-        case Network.NETWORK_MANAGER:
-            bundle = NetworkManager
-        case Network.IWD:
-            bundle = Iwd
-        case Network.SYSTEMD:
-            bundle = SystemdNet
-        case Bundles.CUPS:
-            bundle = Cups
-        case Bundles.GRML:
-            bundle = GrmlZsh
-        case Bundles.MAIN_FILE_SYSTEMS:
-            bundle = MainFileSystems
-        case Bundles.MAIN_FONTS:
-            bundle = MainFonts
-        case Bundles.MICROCODES:
-            bundle = Microcodes
-        case Bundles.NVIDIA:
-            bundle = NvidiaDriver
-        case Bundles.PIPEWIRE:
-            bundle = PipeWire
-        case Bundles.TERMINUS:
-            bundle = TerminusFont
-        case Bundles.ZRAM:
-            bundle = Zram
-        case Bundles.COPY_ACM:
-            bundle = CopyACM
-        case ShellBundles.YAY:
-            bundle = Yay
-        case ShellBundles.GENERATE_CONFIG:
-            bundle = GenerateConfig
-        case _:
-            bundle = Bundle
-    return bundle
+    return (
+        _BUNDLES_MAP[name]
+        if name in _BUNDLES_MAP
+        else archcraftsman.bundles.bundle.Bundle
+    )
+
+
+def list_generic_bundles() -> list[str]:
+    """
+    List all available generic bundles.
+    """
+    return list(
+        resource.name.replace(".toml", "")
+        for resource in importlib.resources.files(
+            "archcraftsman.bundles.configs"
+        ).iterdir()
+        if resource.is_file() and resource.name.endswith(".toml")
+    )
 
 
-def process_bundle(name: OptionEnum) -> Bundle:
+def process_bundle(
+    name: archcraftsman.options.OptionEnum,
+) -> archcraftsman.bundles.bundle.Bundle:
     """
     Process a bundle name into a Bundle object.
     """
-    return get_bundle_type_by_name(name.value)(name)
+    return get_bundle_type_by_name(name.value)()
 
 
-T = TypeVar("T", bound=OptionEnum)
+T = typing.TypeVar("T", bound=archcraftsman.options.OptionEnum)
 
 
 def prompt_bundle(
     message: str,
     error_msg: str,
     options: type[T],
-    supported_msg: Optional[str],
-    default: Optional[T],
+    supported_msg: typing.Optional[str],
+    default: typing.Optional[T],
     *ignores: T,
     new_line_prompt: bool = True,
-) -> Bundle:
+) -> archcraftsman.bundles.bundle.Bundle:
     """
     A method to prompt for a bundle.
     """
-    option = prompt_option(
+    option = archcraftsman.utils.prompt_option(
         message,
         error_msg,
         options,
         supported_msg,
         default,
         *ignores,
         new_line_prompt=new_line_prompt,
```

## archcraftsman/bundles/xfce.py

```diff
@@ -14,28 +14,33 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The xfce bundle module
 """
 
-from archcraftsman import info
-from archcraftsman.base import execute, print_sub_step
-from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import _
-from archcraftsman.utils import prompt_bool
+import archcraftsman.base
+import archcraftsman.bundles.bundle
+import archcraftsman.i18n
+import archcraftsman.info
+import archcraftsman.options
+import archcraftsman.utils
 
+_ = archcraftsman.i18n.translate
 
-class Xfce(Bundle):
+
+class Xfce(archcraftsman.bundles.bundle.Bundle):
     """
     Bundle class.
     """
 
-    display_manager = True
-    minimal = False
+    def __init__(self):
+        super().__init__(archcraftsman.options.Desktops.XFCE)
+        self.display_manager = True
+        self.minimal = False
 
     def packages(self) -> list[str]:
         packages = [
             "xfce4",
             "xorg-server",
             "alsa-utils",
             "pulseaudio",
@@ -47,36 +52,36 @@
                 ["lightdm", "lightdm-gtk-greeter", "lightdm-gtk-greeter-settings"]
             )
         if self.minimal is not True:
             packages.append("xfce4-goodies")
         return packages
 
     def print_resume(self):
-        print_sub_step(_("Desktop environment : %s") % self.name)
-        print_sub_step(
+        archcraftsman.base.print_sub_step(_("Desktop environment : %s") % self.name)
+        archcraftsman.base.print_sub_step(
             _("Display manager : %s")
             % ("LightDM" if self.display_manager else _("none"))
         )
         if self.minimal:
-            print_sub_step(_("Install a minimal environment."))
+            archcraftsman.base.print_sub_step(_("Install a minimal environment."))
 
     def prompt_extra(self):
-        self.display_manager = prompt_bool(
+        self.display_manager = archcraftsman.utils.prompt_bool(
             _("The display manager to install is '%s'. Do you want to install it ?")
             % "LightDM",
             default=True,
         )
-        self.minimal = prompt_bool(
+        self.minimal = archcraftsman.utils.prompt_bool(
             _("Install a minimal environment ?"),
             default=False,
             help_msg=_(
                 "If yes, the script will not install any extra packages, only base packages."
             ),
         )
 
     def configure(self):
         if self.display_manager:
-            execute('arch-chroot /mnt bash -c "systemctl enable lightdm"')
-        execute(
+            archcraftsman.base.execute("systemctl enable lightdm", chroot=True)
+        archcraftsman.base.execute(
             'sed -i "s|#logind-check-graphical=false|logind-check-graphical=true|g" /mnt/etc/lightdm/lightdm.conf'
         )
-        info.ai.pre_launch_info.setup_chroot_keyboard()
+        archcraftsman.info.ai.pre_launch_info.setup_chroot_keyboard()
```

## archcraftsman/bundles/yay.py

```diff
@@ -14,32 +14,40 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The yay bundle module
 """
 
-from archcraftsman.base import execute, is_root, print_error, print_sub_step
-from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import _
+import archcraftsman.base
+import archcraftsman.bundles.bundle
+import archcraftsman.i18n
+import archcraftsman.options
 
+_ = archcraftsman.i18n.translate
 
-class Yay(Bundle):
+
+class Yay(archcraftsman.bundles.bundle.Bundle):
     """
     The Yay class.
     """
 
+    def __init__(self):
+        super().__init__(archcraftsman.options.ShellBundles.YAY)
+
     def packages(self) -> list[str]:
         return ["yay"]
 
     def is_aur(self) -> bool:
         return True
 
     def print_resume(self):
-        print_sub_step(_("Install YAY."))
+        archcraftsman.base.print_sub_step(_("Install YAY."))
 
     def configure(self):
-        if is_root():
-            print_error(_("You must not be root to install yay."), do_pause=False)
+        if archcraftsman.base.is_root():
+            archcraftsman.base.print_error(
+                _("You must not be root to install yay."), do_pause=False
+            )
             return
-        execute("git clone https://aur.archlinux.org/yay")
-        execute("cd yay; makepkg -si; cd -; rm -rf yay")
+        archcraftsman.base.execute("git clone https://aur.archlinux.org/yay")
+        archcraftsman.base.execute("cd yay; makepkg -si; cd -; rm -rf yay")
```

## archcraftsman/bundles/zram.py

```diff
@@ -13,32 +13,38 @@
 #
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The zram bundle module
 """
-from archcraftsman.base import log, print_sub_step
-from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import _
+import archcraftsman.base
+import archcraftsman.bundles.bundle
+import archcraftsman.i18n
+import archcraftsman.options
 
+_ = archcraftsman.i18n.translate
 
-class Zram(Bundle):
+
+class Zram(archcraftsman.bundles.bundle.Bundle):
     """
     The ZRAM class.
     """
 
+    def __init__(self):
+        super().__init__(archcraftsman.options.Bundles.ZRAM)
+
     def packages(self) -> list[str]:
         return ["zram-generator"]
 
     def print_resume(self):
-        print_sub_step(_("Install and enable ZRAM."))
+        archcraftsman.base.print_sub_step(_("Install and enable ZRAM."))
 
     def configure(self):
         content = ["[zram0]\n", "zram-size = ram / 2\n"]
         try:
             with open(
                 "/mnt/etc/systemd/zram-generator.conf", "w", encoding="UTF-8"
             ) as zram_config_file:
                 zram_config_file.writelines(content)
         except FileNotFoundError as exception:
-            log(f"Exception: {exception}")
+            archcraftsman.base.log(f"Exception: {exception}")
```

## archcraftsman/locales/french.po

```diff
@@ -1,528 +1,544 @@
 # SOME DESCRIPTIVE TITLE.
 # Copyright (C) YEAR ORGANIZATION
 # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
 #
 msgid ""
 msgstr ""
 "Project-Id-Version: \n"
-"POT-Creation-Date: 2023-03-30 23:31+0200\n"
-"PO-Revision-Date: 2023-03-30 23:34+0200\n"
+"POT-Creation-Date: 2023-05-12 01:19+0200\n"
+"PO-Revision-Date: 2023-05-12 01:21+0200\n"
 "Last-Translator: \n"
 "Language-Team: \n"
 "Language: fr_FR\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 "Plural-Forms: nplurals=2; plural=(n > 1);\n"
 "Generated-By: pygettext.py 1.5\n"
-"X-Generator: Poedit 3.2.2\n"
+"X-Generator: Poedit 3.3\n"
 
-#: archcraftsman/autopart.py:48
+#: archcraftsman/autopart.py:42
 msgid "Automatic partitioning :"
 msgstr "Partitionnement automatique :"
 
-#: archcraftsman/autopart.py:62
+#: archcraftsman/autopart.py:56
 msgid "Do you want to install Arch Linux next to other systems ?"
 msgstr "Voulez-vous installer Arch Linux à côté des autres systèmes ?"
 
-#: archcraftsman/autopart.py:68
+#: archcraftsman/autopart.py:62
 msgid "What type of Swap do you want ? (%s) : "
 msgstr "Quel type de swap voulez-vous ? (%s) : "
 
-#: archcraftsman/autopart.py:69
+#: archcraftsman/autopart.py:63
 msgid "Swap type '%s' is not supported."
 msgstr "Le type de swap '%s' n'est pas supporté."
 
-#: archcraftsman/autopart.py:71
+#: archcraftsman/autopart.py:65
 msgid "Supported Swap types : "
 msgstr "Types de swap supportés : "
 
-#: archcraftsman/autopart.py:75
+#: archcraftsman/autopart.py:69
 msgid "Do you want a separated Home ?"
 msgstr "Voulez-vous un Home séparé ?"
 
-#: archcraftsman/autopart.py:79 archcraftsman/autopart.py:85
+#: archcraftsman/autopart.py:73 archcraftsman/autopart.py:79
 msgid "Do you want to encrypt the %s partition ?"
 msgstr "Voulez-vous chiffrer la partition %s ?"
 
-#: archcraftsman/autopart.py:259 archcraftsman/basesetup.py:112
-#: archcraftsman/basesetup.py:266 archcraftsman/manualpart.py:159
+#: archcraftsman/autopart.py:248 archcraftsman/basesetup.py:107
+#: archcraftsman/basesetup.py:289 archcraftsman/manualpart.py:158
 msgid "Summary of choices :"
 msgstr "Résumé des choix :"
 
-#: archcraftsman/autopart.py:263 archcraftsman/manualpart.py:167
+#: archcraftsman/autopart.py:252 archcraftsman/manualpart.py:167
 msgid "Swapfile size : %s"
 msgstr "Taille du fichier d'échange : %s"
 
-#: archcraftsman/autopart.py:264 archcraftsman/basesetup.py:117
-#: archcraftsman/basesetup.py:287 archcraftsman/manualpart.py:168
+#: archcraftsman/autopart.py:253 archcraftsman/basesetup.py:115
+#: archcraftsman/basesetup.py:308 archcraftsman/manualpart.py:169
 msgid "Is the information correct ?"
 msgstr "Les informations sont-elles correctes ?"
 
-#: archcraftsman/autopart.py:267 archcraftsman/manualpart.py:171
+#: archcraftsman/autopart.py:256 archcraftsman/manualpart.py:172
 msgid "Do you want to change the partitioning mode ?"
 msgstr "Voulez-vous changer de mode de partitionnement ?"
 
-#: archcraftsman/basesetup.py:69
+#: archcraftsman/base.py:162
+msgid "Press any key to continue..."
+msgstr "Appuyez sur n'importe quelle touche pour continuer..."
+
+#: archcraftsman/base.py:208
+msgid "Help :"
+msgstr "Aide :"
+
+#: archcraftsman/base.py:243
+msgid "The input must not be empty."
+msgstr "La saisie ne doit pas être vide."
+
+#: archcraftsman/basesetup.py:64
 msgid "Querying IP geolocation information..."
 msgstr "Interrogation des informations de géolocalisation IP..."
 
-#: archcraftsman/basesetup.py:89
+#: archcraftsman/basesetup.py:84
 msgid "Welcome to ArchCraftsman !"
 msgstr "Bienvenue sur ArchCraftsman !"
 
-#: archcraftsman/basesetup.py:92
+#: archcraftsman/basesetup.py:87
 msgid ""
 "BIOS detected ! The script will act accordingly. Don't forget to select a "
 "DOS label type before partitioning."
 msgstr ""
 "BIOS détecté ! Le script agira en conséquence. N'oubliez pas de sélectionner "
 "un label type DOS avant de partitionner."
 
-#: archcraftsman/basesetup.py:98
+#: archcraftsman/basesetup.py:93
 msgid "Environment configuration : "
 msgstr "Configuration de l'environnement : "
 
-#: archcraftsman/basesetup.py:101
+#: archcraftsman/basesetup.py:96
 msgid "Choose your installation's language (%s) : "
 msgstr "Choisissez la langue de votre installation (%s) : "
 
-#: archcraftsman/basesetup.py:102
+#: archcraftsman/basesetup.py:97
 msgid "Global language '%s' is not supported."
 msgstr "La langue globale '%s' n'est pas prise en charge."
 
-#: archcraftsman/basesetup.py:104
+#: archcraftsman/basesetup.py:99
 msgid "Supported languages : "
 msgstr "Langues prises en charge : "
 
-#: archcraftsman/basesetup.py:114
+#: archcraftsman/basesetup.py:109
 msgid "Your installation's language : %s"
 msgstr "La langue de votre installation : %s"
 
-#: archcraftsman/basesetup.py:116
+#: archcraftsman/basesetup.py:113
 msgid "Your installation's keymap : %s"
 msgstr "La keymap de votre installation : %s"
 
-#: archcraftsman/basesetup.py:131
+#: archcraftsman/basesetup.py:127
+msgid "This script must be run as root."
+msgstr "Ce script doit être exécuté en tant que root."
+
+#: archcraftsman/basesetup.py:133
+msgid "Running pre-launch steps : "
+msgstr "Exécution des étapes de pré-lancement : "
+
+#: archcraftsman/basesetup.py:141
+msgid "Synchronising repositories..."
+msgstr "Synchronisation des dépôts..."
+
+#: archcraftsman/basesetup.py:147 archcraftsman/installer.py:237
+#: archcraftsman/shell.py:198
+msgid "Script execution interrupted by the user !"
+msgstr "Exécution du script interrompue par l'utilisateur !"
+
+#: archcraftsman/basesetup.py:151 archcraftsman/installer.py:243
+#: archcraftsman/partitioninginfo.py:73 archcraftsman/shell.py:203
+msgid "A subprocess execution failed ! See the following error: %s"
+msgstr ""
+"L'exécution d'un sous-processus a échoué ! L'erreur suivante s'est "
+"produite : %s"
+
+#: archcraftsman/basesetup.py:166
 msgid "System configuration : "
 msgstr "Configuration du système : "
 
-#: archcraftsman/basesetup.py:133
+#: archcraftsman/basesetup.py:168
 msgid "What will be your hostname (archlinux) : "
 msgstr "Quel sera votre nom d'hôte (archlinux) : "
 
-#: archcraftsman/basesetup.py:138
+#: archcraftsman/basesetup.py:174
 msgid "Choose your kernel (%s) : "
 msgstr "Choisissez votre kernel (%s) : "
 
-#: archcraftsman/basesetup.py:139 archcraftsman/shell.py:55
+#: archcraftsman/basesetup.py:175 archcraftsman/shell.py:48
 msgid "Kernel '%s' is not supported."
 msgstr "Le kernel '%s' n'est pas supporté."
 
-#: archcraftsman/basesetup.py:141 archcraftsman/shell.py:57
+#: archcraftsman/basesetup.py:177 archcraftsman/shell.py:50
 msgid "Supported kernels : "
 msgstr "Kernels pris en charge : "
 
-#: archcraftsman/basesetup.py:146
+#: archcraftsman/basesetup.py:184
 msgid "Install a desktop environment ? (%s) : "
 msgstr "Installer un environnement de bureau ? (%s) : "
 
-#: archcraftsman/basesetup.py:147 archcraftsman/shell.py:72
+#: archcraftsman/basesetup.py:185 archcraftsman/shell.py:65
 msgid "Desktop environment '%s' is not supported."
 msgstr "L'environnement de bureau '%s' n'est pas pris en charge."
 
-#: archcraftsman/basesetup.py:149 archcraftsman/shell.py:74
+#: archcraftsman/basesetup.py:187 archcraftsman/shell.py:67
 msgid "Supported desktop environments : "
 msgstr "Environnements de bureau supportés : "
 
-#: archcraftsman/basesetup.py:154
+#: archcraftsman/basesetup.py:194
 msgid "Choose your network stack (%s) : "
 msgstr "Choisissez votre pile réseau (%s) : "
 
-#: archcraftsman/basesetup.py:155
+#: archcraftsman/basesetup.py:195
 msgid "Network stack '%s' is not supported."
 msgstr "La pile réseau '%s' n'est pas supporté."
 
-#: archcraftsman/basesetup.py:157
+#: archcraftsman/basesetup.py:197
 msgid "Supported network stacks : "
 msgstr "Pile réseau supportés : "
 
-#: archcraftsman/basesetup.py:161
+#: archcraftsman/basesetup.py:202
 msgid "Install proprietary Nvidia driver ?"
 msgstr "Installer le pilote propriétaire Nvidia ?"
 
-#: archcraftsman/basesetup.py:164
+#: archcraftsman/basesetup.py:205
 msgid "Install terminus console font ?"
 msgstr "Installer la police de console Terminus ?"
 
-#: archcraftsman/basesetup.py:167
-msgid "Install Cups ?"
-msgstr "Installer Cups ?"
-
-#: archcraftsman/basesetup.py:171
+#: archcraftsman/basesetup.py:209
 msgid "Install ZSH with GRML configuration ?"
 msgstr "Installer ZSH avec la configuration GRML ?"
 
-#: archcraftsman/basesetup.py:173
+#: archcraftsman/basesetup.py:211
 msgid ""
 "If yes, the script will install the ZSH shell with GRML configuration. GRML "
 "is a ZSH pre-configuration used by Archlinux's live environment."
 msgstr ""
 "Si oui, le script installera le shell ZSH avec la configuration GRML. GRML "
 "est une pré-configuration de ZSH utilisée par l'environnement live "
 "d'Archlinux."
 
-#: archcraftsman/basesetup.py:182
-msgid "Install a set of main fonts ?"
-msgstr "Installer un ensemble de polices principales ?"
-
-#: archcraftsman/basesetup.py:184 archcraftsman/basesetup.py:192
-msgid ""
-"If yes, the following packages will be installed :\n"
-"%s"
-msgstr ""
-"Si oui, les paquets suivants seront installés :\n"
-"%s"
-
-#: archcraftsman/basesetup.py:190
-msgid "Install main file systems support ?"
-msgstr "Installer le support des systèmes de fichiers principaux ?"
-
-#: archcraftsman/basesetup.py:198
+#: archcraftsman/basesetup.py:220
 msgid "Install and enable ZRAM ?"
 msgstr "Installer et activer ZRAM ?"
 
-#: archcraftsman/basesetup.py:200
+#: archcraftsman/basesetup.py:222
 msgid ""
 "ZRAM is a process to compress datas directly in the RAM instead of moving "
 "them in a swap. Enabled ZRAM will allow you to compress up to half of your "
 "RAM before having to swap. This method is more efficient than the swap and "
 "do not use your disk but is more CPU demanding. ZRAM is fully compatible "
 "with a swap, it just has a higher priority."
 msgstr ""
 "ZRAM est un procédé permettant de compresser les données directement dans la "
 "RAM au lieu de les déplacer dans un swap. L'activation de ZRAM vous "
 "permettra de compresser jusqu'à la moitié de votre RAM avant de devoir swap. "
 "Cette méthode est plus efficace que le swap et n'utilise pas votre disque "
 "mais est plus gourmande en ressources CPU. ZRAM est entièrement compatible "
 "avec un swap, il a juste une priorité plus élevée."
 
-#: archcraftsman/basesetup.py:210
-msgid "Install PipeWire ?"
-msgstr "Installer PipeWire ?"
-
-#: archcraftsman/basesetup.py:212
-msgid ""
-"If yes, the PipeWire multimedia framework will be installed to manage audio "
-"and video capture."
-msgstr ""
-"Si oui, le framework multimédia PipeWire sera installé pour gérer l'audio et "
-"la capture vidéo."
-
-#: archcraftsman/basesetup.py:219
+#: archcraftsman/basesetup.py:231
 msgid "Copy ArchCraftsman to the new system ?"
 msgstr "Copier ArchCraftsman sur le nouveau système ?"
 
-#: archcraftsman/basesetup.py:224
+#: archcraftsman/basesetup.py:245
 msgid "Your timezone (%s) : "
 msgstr "Votre fuseau horaire (%s) : "
 
-#: archcraftsman/basesetup.py:231
+#: archcraftsman/basesetup.py:252
 msgid "Would you like to add a user? (type username, leave blank if none) : "
 msgstr ""
 "Voulez-vous ajouter un utilisateur ? (tapez le nom d'utilisateur, laissez "
 "vide si vous n'en avez pas) : "
 
-#: archcraftsman/basesetup.py:239
+#: archcraftsman/basesetup.py:260
 msgid "Invalid user name."
 msgstr "Nom d'utilisateur invalide."
 
-#: archcraftsman/basesetup.py:245
+#: archcraftsman/basesetup.py:266
 msgid ""
 "What is the %s's full name (type the entire full name, leave blank if "
 "none) : "
 msgstr ""
 "Quel est le nom complet de %s (tapez le nom complet, laissez un blanc si "
 "vous n'en avez pas) : "
 
-#: archcraftsman/basesetup.py:253 archcraftsman/basesetup.py:258
+#: archcraftsman/basesetup.py:274 archcraftsman/basesetup.py:280
 msgid "%s password configuration : "
 msgstr "Configuration du mot de passe de %s : "
 
-#: archcraftsman/basesetup.py:255 archcraftsman/basesetup.py:260
+#: archcraftsman/basesetup.py:276 archcraftsman/basesetup.py:283
 msgid "Enter the %s password : "
 msgstr "Entrez le mot de passe de %s : "
 
-#: archcraftsman/basesetup.py:267
+#: archcraftsman/basesetup.py:290
 msgid "Your hostname : %s"
 msgstr "Votre nom d'hôte : %s"
 
-#: archcraftsman/basesetup.py:278
+#: archcraftsman/basesetup.py:294
 msgid "Your timezone : %s"
 msgstr "Votre fuseau horaire : %s"
 
-#: archcraftsman/basesetup.py:280
+#: archcraftsman/basesetup.py:297
 msgid "Additional user name : %s"
 msgstr "Nom d'utilisateur supplémentaire : %s"
 
-#: archcraftsman/basesetup.py:282
+#: archcraftsman/basesetup.py:301
 msgid "User's full name : %s"
 msgstr "Nom complet de l'utilisateur : %s"
 
-#: archcraftsman/basesetup.py:285
+#: archcraftsman/basesetup.py:305
 msgid "More packages to install : %s"
 msgstr "Plus de paquets à installer : %s"
 
 #: archcraftsman/bundles/budgie.py:62 archcraftsman/bundles/cinnamon.py:63
 #: archcraftsman/bundles/cutefish.py:53 archcraftsman/bundles/lxqt.py:63
-#: archcraftsman/bundles/mate.py:66 archcraftsman/bundles/xfce.py:67
+#: archcraftsman/bundles/mate.py:68 archcraftsman/bundles/xfce.py:67
 msgid "The display manager to install is '%s'. Do you want to install it ?"
 msgstr ""
 "Le gestionnaire d'affichage à installer est '%s'. Voulez-vous l'installer ?"
 
 #: archcraftsman/bundles/budgie.py:68 archcraftsman/bundles/cinnamon.py:69
-#: archcraftsman/bundles/cutefish.py:59 archcraftsman/bundles/deepin.py:51
-#: archcraftsman/bundles/enlightenment.py:52 archcraftsman/bundles/gnome.py:53
+#: archcraftsman/bundles/cutefish.py:59 archcraftsman/bundles/deepin.py:53
+#: archcraftsman/bundles/enlightenment.py:52 archcraftsman/bundles/gnome.py:54
 #: archcraftsman/bundles/i3.py:57 archcraftsman/bundles/lxqt.py:69
-#: archcraftsman/bundles/mate.py:56 archcraftsman/bundles/plasma.py:61
+#: archcraftsman/bundles/mate.py:58 archcraftsman/bundles/plasma.py:63
 #: archcraftsman/bundles/sway.py:73 archcraftsman/bundles/xfce.py:57
 msgid "Desktop environment : %s"
 msgstr "Environnement de bureau : %s"
 
 #: archcraftsman/bundles/budgie.py:70 archcraftsman/bundles/cinnamon.py:71
-#: archcraftsman/bundles/cutefish.py:61 archcraftsman/bundles/deepin.py:52
-#: archcraftsman/bundles/enlightenment.py:53 archcraftsman/bundles/gnome.py:54
+#: archcraftsman/bundles/cutefish.py:61 archcraftsman/bundles/deepin.py:54
+#: archcraftsman/bundles/enlightenment.py:53 archcraftsman/bundles/gnome.py:55
 #: archcraftsman/bundles/i3.py:58 archcraftsman/bundles/lxqt.py:71
-#: archcraftsman/bundles/mate.py:58 archcraftsman/bundles/plasma.py:62
+#: archcraftsman/bundles/mate.py:60 archcraftsman/bundles/plasma.py:64
 #: archcraftsman/bundles/sway.py:74 archcraftsman/bundles/xfce.py:59
 msgid "Display manager : %s"
 msgstr "Gestionnaire d'affichage : %s"
 
 #: archcraftsman/bundles/budgie.py:71 archcraftsman/bundles/cinnamon.py:72
 #: archcraftsman/bundles/cutefish.py:61
 #: archcraftsman/bundles/enlightenment.py:53 archcraftsman/bundles/i3.py:58
-#: archcraftsman/bundles/lxqt.py:71 archcraftsman/bundles/mate.py:59
+#: archcraftsman/bundles/lxqt.py:71 archcraftsman/bundles/mate.py:61
 #: archcraftsman/bundles/sway.py:74 archcraftsman/bundles/xfce.py:60
 msgid "none"
 msgstr "aucun"
 
 #: archcraftsman/bundles/copyacm.py:36
 msgid "Copy ArchCraftsman to the new system."
 msgstr "Copier ArchCraftsman sur le nouveau système."
 
-#: archcraftsman/bundles/cups.py:52
-msgid "Install Cups."
-msgstr "Installer Cups."
-
-#: archcraftsman/bundles/deepin.py:54 archcraftsman/bundles/mate.py:62
-#: archcraftsman/bundles/plasma.py:64 archcraftsman/bundles/xfce.py:63
+#: archcraftsman/bundles/deepin.py:56 archcraftsman/bundles/mate.py:64
+#: archcraftsman/bundles/plasma.py:66 archcraftsman/bundles/xfce.py:63
 msgid "Install a minimal environment."
 msgstr "Installer un environnement minimal."
 
-#: archcraftsman/bundles/deepin.py:58 archcraftsman/bundles/gnome.py:58
-#: archcraftsman/bundles/mate.py:71 archcraftsman/bundles/plasma.py:70
+#: archcraftsman/bundles/deepin.py:60 archcraftsman/bundles/gnome.py:59
+#: archcraftsman/bundles/mate.py:73 archcraftsman/bundles/plasma.py:72
 #: archcraftsman/bundles/xfce.py:72
 msgid "Install a minimal environment ?"
 msgstr "Installer un environnement minimal ?"
 
-#: archcraftsman/bundles/deepin.py:60 archcraftsman/bundles/gnome.py:60
-#: archcraftsman/bundles/mate.py:73 archcraftsman/bundles/plasma.py:72
+#: archcraftsman/bundles/deepin.py:62 archcraftsman/bundles/gnome.py:61
+#: archcraftsman/bundles/mate.py:75 archcraftsman/bundles/plasma.py:74
 #: archcraftsman/bundles/xfce.py:74
 msgid ""
 "If yes, the script will not install any extra packages, only base packages."
 msgstr ""
 "Si oui, le script n'installera pas de paquets supplémentaires, seulement les "
 "paquets de base."
 
+#: archcraftsman/bundles/generateconfig.py:36
+msgid "Generate configuration."
+msgstr "Générer la configuration."
+
 #: archcraftsman/bundles/grmlzsh.py:40
 msgid "Install ZSH with GRML configuration."
 msgstr "Installer ZSH avec la configuration GRML."
 
-#: archcraftsman/bundles/iwd.py:42
+#: archcraftsman/bundles/iwd.py:41
 msgid "Install Iwd."
 msgstr "Installer Iwd."
 
-#: archcraftsman/bundles/linux.py:38
+#: archcraftsman/bundles/linux.py:39
 msgid "Install Linux current kernel."
 msgstr "Installer le noyau Linux current."
 
-#: archcraftsman/bundles/linux.py:50
+#: archcraftsman/bundles/linux.py:54
 msgid "Install Linux hardened kernel."
 msgstr "Installer le noyau Linux hardened."
 
-#: archcraftsman/bundles/linux.py:62
+#: archcraftsman/bundles/linux.py:69
 msgid "Install Linux LTS kernel."
 msgstr "Installer le noyau Linux LTS."
 
-#: archcraftsman/bundles/linux.py:74
+#: archcraftsman/bundles/linux.py:84
 msgid "Install Linux zen kernel."
 msgstr "Installer le noyau Linux zen."
 
-#: archcraftsman/bundles/mainfilesystems.py:56
-msgid "Install main file systems support."
-msgstr "Installer le support des systèmes de fichiers principaux."
-
-#: archcraftsman/bundles/mainfonts.py:67
-msgid "Install a set of main fonts."
-msgstr "Installer un ensemble de polices principales."
-
-#: archcraftsman/bundles/microcodes.py:66
+#: archcraftsman/bundles/microcodes.py:64
 msgid "Microcodes to install : %s"
 msgstr "Microcodes à installer : %s"
 
-#: archcraftsman/bundles/networkmanager.py:52
+#: archcraftsman/bundles/networkmanager.py:51
 msgid "Install NetworkManager."
 msgstr "Installer NetworkManager."
 
-#: archcraftsman/bundles/nvidia.py:40
+#: archcraftsman/bundles/nvidia.py:44
 msgid "Install proprietary Nvidia driver."
 msgstr "Installer le pilote propriétaire Nvidia."
 
-#: archcraftsman/bundles/pipewire.py:47
-msgid "Install PipeWire."
-msgstr "Installer PipeWire."
-
-#: archcraftsman/bundles/plasma.py:66
+#: archcraftsman/bundles/plasma.py:68
 msgid "Install Wayland support for the plasma session."
 msgstr "Installer le support Wayland pour la session plasma."
 
-#: archcraftsman/bundles/plasma.py:77
+#: archcraftsman/bundles/plasma.py:79
 msgid "Install Wayland support for the plasma session ?"
 msgstr "Installer le support Wayland pour la session plasma ?"
 
-#: archcraftsman/bundles/systemdnet.py:40
+#: archcraftsman/bundles/systemdnet.py:39
 msgid "Enable systemd network stack."
 msgstr "Activer la pile réseau de systemd."
 
 #: archcraftsman/bundles/terminus.py:40
 msgid "Install terminus console font."
 msgstr "Installer la police de console Terminus."
 
-#: archcraftsman/bundles/yay.py:25
+#: archcraftsman/bundles/yay.py:42
 msgid "Install YAY."
 msgstr "Installer YAY."
 
-#: archcraftsman/bundles/yay.py:29
+#: archcraftsman/bundles/yay.py:46
 msgid "You must not be root to install yay."
 msgstr "Vous devez ne pas être root pour installer yay."
 
-#: archcraftsman/bundles/zram.py:39
+#: archcraftsman/bundles/zram.py:38
 msgid "Install and enable ZRAM."
 msgstr "Installer et activer ZRAM."
 
 #: archcraftsman/disk.py:116
 msgid "Swapfile size ? (%s, type '0' for none) : "
 msgstr "Taille du fichier d'échange ? (%s, tapez '0' pour aucun) : "
 
-#: archcraftsman/installer.py:58
+#: archcraftsman/imessages.py:6
+msgid "Install Cups ?"
+msgstr "Installer Cups ?"
+
+#: archcraftsman/imessages.py:7
+msgid "Install Cups."
+msgstr "Installer Cups."
+
+#: archcraftsman/imessages.py:8
+msgid "Install main file systems support ?"
+msgstr "Installer le support des systèmes de fichiers principaux ?"
+
+#: archcraftsman/imessages.py:9
+msgid "Install main file systems support."
+msgstr "Installer le support des systèmes de fichiers principaux."
+
+#: archcraftsman/imessages.py:10
+msgid ""
+"If yes, the following packages will be installed :\n"
+"{packages}"
+msgstr ""
+"Si oui, les paquets suivants seront installés :\n"
+"{packages}"
+
+#: archcraftsman/imessages.py:11
+msgid "Install a set of main fonts ?"
+msgstr "Installer un ensemble de polices principales ?"
+
+#: archcraftsman/imessages.py:12
+msgid "Install a set of main fonts."
+msgstr "Installer un ensemble de polices principales."
+
+#: archcraftsman/imessages.py:13
+msgid "Install PipeWire ?"
+msgstr "Installer PipeWire ?"
+
+#: archcraftsman/imessages.py:14
+msgid "Install PipeWire."
+msgstr "Installer PipeWire."
+
+#: archcraftsman/imessages.py:15
+msgid ""
+"If yes, the PipeWire multimedia framework will be installed to manage audio "
+"and video capture."
+msgstr ""
+"Si oui, le framework multimédia PipeWire sera installé pour gérer l'audio et "
+"la capture vidéo."
+
+#: archcraftsman/installer.py:52
 msgid "Partitioning :"
 msgstr "Partitionnement :"
 
-#: archcraftsman/installer.py:60
+#: archcraftsman/installer.py:54
 msgid "Do you want an automatic partitioning ?"
 msgstr "Voulez-vous un partitionnement automatique ?"
 
-#: archcraftsman/installer.py:69
+#: archcraftsman/installer.py:63
 msgid "Updating mirrors..."
 msgstr "Mise à jour des miroirs..."
 
-#: archcraftsman/installer.py:127
+#: archcraftsman/installer.py:109
 msgid "Installation of the base..."
 msgstr "Installation de la base..."
 
-#: archcraftsman/installer.py:130
+#: archcraftsman/installer.py:112
 msgid "System configuration..."
 msgstr "Configuration du système..."
 
-#: archcraftsman/installer.py:156
+#: archcraftsman/installer.py:140
 msgid "Locales configuration..."
 msgstr "Configuration des locales..."
 
-#: archcraftsman/installer.py:162
+#: archcraftsman/installer.py:144
 msgid "Installation of the remaining packages..."
 msgstr "Installation des paquets restants..."
 
-#: archcraftsman/installer.py:176
+#: archcraftsman/installer.py:158
 msgid "Creation and activation of the swapfile..."
 msgstr "Création et activation du fichier d'échange..."
 
-#: archcraftsman/installer.py:195
+#: archcraftsman/installer.py:180
 msgid "Generating fstab..."
 msgstr "Génération du fstab..."
 
-#: archcraftsman/installer.py:199
+#: archcraftsman/installer.py:184
 msgid "Desktop configuration..."
 msgstr "Configuration du bureau..."
 
-#: archcraftsman/installer.py:205
+#: archcraftsman/installer.py:187
 msgid "Network configuration..."
 msgstr "Configuration du réseau..."
 
-#: archcraftsman/installer.py:213
+#: archcraftsman/installer.py:192
 msgid "Installation and configuration of the grub..."
 msgstr "Installation et configuration du grub..."
 
-#: archcraftsman/installer.py:218
+#: archcraftsman/installer.py:195
 msgid "Users configuration..."
 msgstr "Configuration des utilisateurs..."
 
-#: archcraftsman/installer.py:219
+#: archcraftsman/installer.py:196
 msgid "Root account configuration..."
 msgstr "Configuration du compte Root..."
 
-#: archcraftsman/installer.py:225
+#: archcraftsman/installer.py:204
 msgid "%s account configuration..."
 msgstr "Configuration du compte %s..."
 
-#: archcraftsman/installer.py:244
+#: archcraftsman/installer.py:225
 msgid "Extra packages configuration if needed..."
 msgstr "Configuration de paquets supplémentaires si nécessaire..."
 
-#: archcraftsman/installer.py:251
+#: archcraftsman/installer.py:233
 msgid "Installation complete ! You can reboot your system."
 msgstr "L'installation est terminée ! Vous pouvez redémarrer votre système."
 
-#: archcraftsman/installer.py:255 archcraftsman/installer.py:293
-#: archcraftsman/shell.py:189
-msgid "Script execution interrupted by the user !"
-msgstr "Exécution du script interrompue par l'utilisateur !"
-
-#: archcraftsman/installer.py:260 archcraftsman/installer.py:297
-#: archcraftsman/shell.py:193
-msgid "A subprocess execution failed ! See the following error: %s"
-msgstr ""
-"L'exécution d'un sous-processus a échoué ! L'erreur suivante s'est "
-"produite : %s"
-
-#: archcraftsman/installer.py:276
-msgid "This script must be run as root."
-msgstr "Ce script doit être exécuté en tant que root."
-
-#: archcraftsman/installer.py:279
-msgid "Running pre-launch steps : "
-msgstr "Exécution des étapes de pré-lancement : "
-
-#: archcraftsman/installer.py:287
-msgid "Synchronising repositories..."
-msgstr "Synchronisation des dépôts..."
-
-#: archcraftsman/manualpart.py:49 archcraftsman/manualpart.py:58
+#: archcraftsman/manualpart.py:44 archcraftsman/manualpart.py:54
 msgid "Manual partitioning :"
 msgstr "Partitionnement manuel :"
 
-#: archcraftsman/manualpart.py:51 archcraftsman/manualpart.py:60
+#: archcraftsman/manualpart.py:46 archcraftsman/manualpart.py:56
 msgid "Partitioned drives so far : %s"
 msgstr "Disques partitionnés jusqu'à présent : %s"
 
-#: archcraftsman/manualpart.py:64
+#: archcraftsman/manualpart.py:60
 msgid "Do you want to partition an other drive ?"
 msgstr "Voulez-vous partitionner un autre disque ?"
 
-#: archcraftsman/manualpart.py:77
+#: archcraftsman/manualpart.py:73
 msgid "Detected target drive partitions : %s"
 msgstr "Partitions du disque cible détectées : %s"
 
 #: archcraftsman/manualpart.py:83
 msgid "Partition :"
 msgstr "Partition :"
 
@@ -534,345 +550,188 @@
 msgid "Partition type '%s' is not supported."
 msgstr "Le type de partition '%s' n'est pas supporté."
 
 #: archcraftsman/manualpart.py:90 archcraftsman/manualpart.py:99
 msgid "Supported partition types : "
 msgstr "Types de partition supportés : "
 
-#: archcraftsman/manualpart.py:123
+#: archcraftsman/manualpart.py:122
 msgid "What is the mounting point of this partition ? : "
 msgstr "Quel est le point de montage de cette partition ? : "
 
-#: archcraftsman/manualpart.py:131
+#: archcraftsman/manualpart.py:130
 msgid "The EFI partition is required for system installation."
 msgstr "La partition EFI est nécessaire pour l'installation du système."
 
-#: archcraftsman/manualpart.py:138
+#: archcraftsman/manualpart.py:137
 msgid "The Root partition is required for system installation."
 msgstr "La partition Root est nécessaire pour l'installation du système."
 
-#: archcraftsman/manualpart.py:148
+#: archcraftsman/manualpart.py:147
 msgid "The Boot partition is required for system installation."
 msgstr "La partition Boot est nécessaire pour l'installation du système."
 
-#: archcraftsman/packages.py:93
+#: archcraftsman/packages.py:91
 msgid ""
 "Install more packages ? (type extra packages full names, example : 'htop "
 "neofetch', leave blank if none) : "
 msgstr ""
 "Installer d'autres paquets ? (tapez les noms complets des paquets "
 "supplémentaires, exemple : 'htop neofetch', laissez vide si vous n'en avez "
 "pas) : "
 
-#: archcraftsman/packages.py:103
+#: archcraftsman/packages.py:101
 msgid "Package %s doesn't exist."
 msgstr "Le paquet %s n'existe pas."
 
-#: archcraftsman/partition.py:146
+#: archcraftsman/partition.py:141
 msgid "Format the partition ?"
 msgstr "Formater la partition ?"
 
-#: archcraftsman/partition.py:179
+#: archcraftsman/partition.py:174
 msgid "Do you want to encrypt this partition ?"
 msgstr "Voulez-vous chiffrer cette partition ?"
 
-#: archcraftsman/partition.py:194 archcraftsman/utils.py:373
-#: archcraftsman/utils.py:375 archcraftsman/utils.py:380
+#: archcraftsman/partition.py:189 archcraftsman/utils.py:284
+#: archcraftsman/utils.py:286 archcraftsman/utils.py:291
 msgid "yes"
 msgstr "oui"
 
-#: archcraftsman/partition.py:196 archcraftsman/utils.py:373
-#: archcraftsman/utils.py:375 archcraftsman/utils.py:381
+#: archcraftsman/partition.py:191 archcraftsman/utils.py:284
+#: archcraftsman/utils.py:286 archcraftsman/utils.py:292
 msgid "no"
 msgstr "non"
 
-#: archcraftsman/partition.py:203
+#: archcraftsman/partition.py:196
 msgid "%s : %s"
 msgstr "%s : %s"
 
-#: archcraftsman/partition.py:204
+#: archcraftsman/partition.py:197
 msgid "%s : %s (mounting point : %s, format %s, format type %s)"
 msgstr "%s : %s (point de montage : %s, formater %s, type de formatage %s)"
 
-#: archcraftsman/partition.py:212
+#: archcraftsman/partition.py:205
 msgid "encrypted"
 msgstr "chiffrée"
 
-#: archcraftsman/partition.py:226
+#: archcraftsman/partition.py:219
 msgid "Formatting %s..."
 msgstr "Formatage de %s..."
 
-#: archcraftsman/partition.py:234
+#: archcraftsman/partition.py:227
 msgid "Opening %s..."
 msgstr "Ouverture de %s..."
 
-#: archcraftsman/partition.py:251
+#: archcraftsman/partition.py:257
 msgid "Mounting %s..."
 msgstr "Montage de %s..."
 
-#: archcraftsman/partition.py:268
+#: archcraftsman/partition.py:273
 msgid "Unmounting %s..."
 msgstr "Démontage de %s..."
 
-#: archcraftsman/partition.py:271
+#: archcraftsman/partition.py:276
 msgid "Closing %s..."
 msgstr "Fermeture de %s..."
 
-#: archcraftsman/partitioninginfo.info.py:50
+#: archcraftsman/partitioninginfo.py:60
 msgid "Formatting and mounting partitions..."
 msgstr "Formatage et montage des partitions..."
 
-#: archcraftsman/partitioninginfo.info.py:81
+#: archcraftsman/partitioninginfo.py:100
 msgid "Unmounting partitions..."
 msgstr "Démontage des partitions..."
 
-#: archcraftsman/prelaunchinfo.info.py:54
+#: archcraftsman/prelaunchinfo.py:59
 msgid "Configuring live environment..."
 msgstr "Configuration de l'environnement live..."
 
-#: archcraftsman/shell.py:89
+#: archcraftsman/shell.py:82
 msgid "Bundle '%s' is not supported."
 msgstr "Le bundle '%s' n'est pas supporté."
 
-#: archcraftsman/shell.py:91
+#: archcraftsman/shell.py:84
 msgid "Available bundles : "
 msgstr "Bundles disponibles : "
 
-#: archcraftsman/shell.py:107
+#: archcraftsman/shell.py:100
 msgid "Shell bundle '%s' is not supported."
 msgstr "Le bundle shell '%s' n'est pas supporté."
 
-#: archcraftsman/shell.py:109
+#: archcraftsman/shell.py:102
 msgid "Available shell bundles : "
 msgstr "Bundles shell disponibles : "
 
-#: archcraftsman/shell.py:140
+#: archcraftsman/shell.py:139
 msgid "ArchCraftsman interactive shell mode."
 msgstr "Mode shell interactif d'ArchCraftsman."
 
-#: archcraftsman/shell.py:141 archcraftsman/shell.py:164
+#: archcraftsman/shell.py:140 archcraftsman/shell.py:163
 msgid "Available commands :"
 msgstr "Commandes disponibles :"
 
-#: archcraftsman/shell.py:147
+#: archcraftsman/shell.py:146
 msgid "Command '%s' is not supported."
 msgstr "La commande '%s' n'est pas supporté."
 
-#: archcraftsman/shell.py:172
+#: archcraftsman/shell.py:180
 msgid "Sub-command '%s' is not supported."
 msgstr "La sous-commande '%s' n'est pas supporté."
 
-#: archcraftsman/shell.py:174
+#: archcraftsman/shell.py:182
 msgid "Available sub-commands : "
 msgstr "Sous-commandes disponibles : "
 
-#: archcraftsman/utils.py:206
-msgid "Press any key to continue..."
-msgstr "Appuyez sur n'importe quelle touche pour continuer..."
-
-#: archcraftsman/utils.py:252
-msgid "Help :"
-msgstr "Aide :"
-
-#: archcraftsman/utils.py:287
-msgid "The input must not be empty."
-msgstr "La saisie ne doit pas être vide."
-
-#: archcraftsman/utils.py:418
+#: archcraftsman/utils.py:171
 msgid ""
 "Type your installation's keymap, or 'help' to get the list of keymaps (%s) : "
 msgstr ""
 "Entrez la keymap de votre installation, ou 'help' pour obtenir la liste des "
 "keymaps (%s) : "
 
-#: archcraftsman/utils.py:430
+#: archcraftsman/utils.py:183
 msgid "Keymap '%s' doesn't exist."
 msgstr "La keymap '%s' n'existe pas."
 
-#: archcraftsman/utils.py:441
+#: archcraftsman/utils.py:194
 msgid "Which format type do you want ? (%s) : "
 msgstr "Quel type de formatage voulez-vous ? (%s) : "
 
-#: archcraftsman/utils.py:442
+#: archcraftsman/utils.py:195
 msgid "Format type '%s' is not supported."
 msgstr "Le type de formatage '%s' n'est pas supporté."
 
-#: archcraftsman/utils.py:444
+#: archcraftsman/utils.py:197
 msgid "Supported format types : "
 msgstr "Types de formatage supportés : "
 
-#: archcraftsman/utils.py:459
+#: archcraftsman/utils.py:213
 msgid "What will be the encrypted block name ? : "
 msgstr "Quel sera le nom de bloc chiffré ? : "
 
-#: archcraftsman/utils.py:462
+#: archcraftsman/utils.py:216
 msgid "Invalid encrypted block name."
 msgstr "Nom de bloc chiffré invalide."
 
-#: archcraftsman/utils.py:477
+#: archcraftsman/utils.py:231
 msgid "Enter it again to confirm : "
 msgstr "Saisissez le à nouveau pour confirmer : "
 
-#: archcraftsman/utils.py:480
+#: archcraftsman/utils.py:234
 msgid "Passwords entered don't match."
 msgstr "Les mots de passe saisis ne correspondent pas."
 
-#: archcraftsman/utils.py:503
+#: archcraftsman/utils.py:257
 msgid "Detected drives :"
 msgstr "Disques détectés :"
 
-#: archcraftsman/utils.py:507
+#: archcraftsman/utils.py:261
 msgid ""
 "On which drive should Archlinux be installed ? (type the entire name, for "
 "example '/dev/sda') : "
 msgstr ""
 "Sur quel disque Archlinux doit-il être installé ? (tapez le nom complet, par "
 "exemple '/dev/sda') : "
 
-#: archcraftsman/utils.py:515
+#: archcraftsman/utils.py:269
 msgid "The target drive '%s' doesn't exist."
 msgstr "Le disque cible '%s' n'existe pas."
-
-#~ msgid "You need to choose a target drive."
-#~ msgstr "Vous devez choisir un disque cible."
-
-#~ msgid ""
-#~ "Which drive do you want to partition ? (type the entire name, for example "
-#~ "'/dev/sda') : "
-#~ msgstr ""
-#~ "Quel disque souhaitez-vous partitionner ? (tapez le nom complet, par "
-#~ "exemple '/dev/sda') : "
-
-#~ msgid "Install a minimal environment ? (y/N/?) : "
-#~ msgstr "Installer un environnement minimal ? (o/N/?) : "
-
-#~ msgid "Install Wayland support for the plasma session ? (y/N) : "
-#~ msgstr "Installer le support Wayland pour la session plasma ? (o/N) : "
-
-#~ msgid "Install proprietary Nvidia driver ? (y/N) : "
-#~ msgstr "Installer le pilote propriétaire Nvidia ? (o/N) : "
-
-#~ msgid "Install terminus console font ? (y/N) : "
-#~ msgstr "Installer la police de console terminus ? (o/N) : "
-
-#~ msgid "Install Cups ? (y/N) : "
-#~ msgstr "Installer Cups ? (o/N) : "
-
-#~ msgid "Install ZSH with GRML configuration ? (y/N/?) : "
-#~ msgstr "Installer ZSH avec la configuration GRML ? (o/N/?) : "
-
-#~ msgid "Install a set of main fonts ? (y/N/?) : "
-#~ msgstr "Installer un jeu de polices principales ? (o/N/?) : "
-
-#~ msgid "Install main file systems support ? (y/N/?) : "
-#~ msgstr ""
-#~ "Installer le support des systèmes de fichiers principaux ? (o/N/?) : "
-
-#~ msgid "Install and enable ZRAM ? (y/N/?) : "
-#~ msgstr "Installer et activer ZRAM ? (o/N/?) : "
-
-#~ msgid "Install PipeWire ? (y/N/?) : "
-#~ msgstr "Installer PipeWire ? (o/N/?) : "
-
-#~ msgid "Copy ArchCraftsman to the new system ? (y/N) : "
-#~ msgstr "Copier ArchCraftsman sur le nouveau système ? (o/N) : "
-
-#~ msgid "Install Iwd with systemd network stack."
-#~ msgstr "Installer Iwd avec la pile réseau de systemd."
-
-#~ msgid "Format the %s partition ? (Y/n) : "
-#~ msgstr "Formater la partition %s ? (O/n) : "
-
-#~ msgid ""
-#~ "Enter the encrypted block password (it will be asked at boot to decrypt "
-#~ "the partition) : "
-#~ msgstr ""
-#~ "Entrez le mot de passe du bloc chiffré (il sera demandé au démarrage pour "
-#~ "déchiffrer la partition) : "
-
-#~ msgid "ROOT partition : %s (mounting point : %s, format type %s)"
-#~ msgstr "Partition ROOT : %s (point de montage : %s, type de formatage %s)"
-
-#~ msgid "Home partition : %s (mounting point : %s, format %s, format type %s)"
-#~ msgstr ""
-#~ "Partition Home : %s (point de montage : %s, formater %s, type de "
-#~ "formatage %s)"
-
-#~ msgid "Swap partition : %s"
-#~ msgstr "Partition Swap : %s"
-
-#~ msgid ""
-#~ "Other partition : %s (mounting point : %s, format %s, format type %s)"
-#~ msgstr ""
-#~ "Autre partition : %s (point de montage : %s, formater %s, type de "
-#~ "formatage %s)"
-
-#~ msgid "Format the EFI partition ? (Y/n) : "
-#~ msgstr "Formater la partition EFI ? (O/n) : "
-
-#~ msgid "Format the Home partition ? (Y/n) : "
-#~ msgstr "Formater la partition Home ? (O/n) : "
-
-#~ msgid "%s"
-#~ msgstr "%s"
-
-#~ msgid ""
-#~ "What type of Swap do you want ? (1: Partition, 2: None, other: File) : "
-#~ msgstr ""
-#~ "Quel type de Swap voulez-vous ? (1: Partition, 2: Aucun, autre: "
-#~ "Fichier) : "
-
-#~ msgid ""
-#~ "What is the role of this partition ? (1: Root, 2: Home, 3: Swap, 4: Not "
-#~ "used, other: Other) : "
-#~ msgstr ""
-#~ "Quel est le rôle de cette partition ? (1: Root, 2: Home, 3: Swap, 4: Non "
-#~ "utilisé, autre: Autre) : "
-
-#~ msgid ""
-#~ "What is the role of this partition ? (0: EFI, 1: Root, 2: Home, 3: Swap, "
-#~ "4: Not used, other: Other) : "
-#~ msgstr ""
-#~ "Quel est le rôle de cette partition ? (0: EFI, 1: Root, 2: Home, 3: Swap, "
-#~ "4: Non utilisé, autre: Autre) : "
-
-#~ msgid "Downloading and formatting translations..."
-#~ msgstr "Téléchargement et formatage des traductions..."
-
-#~ msgid "Updating archlinux-keyring and system..."
-#~ msgstr "Mise à jour de archlinux-keyring et du système…"
-
-#~ msgid "Install LTS Linux kernel ? (y/N) : "
-#~ msgstr "Installer le noyau Linux LTS ? (o/N) : "
-
-#~ msgid ""
-#~ "Install a minimal environment (no extra packages, only base) ? (y/N) : "
-#~ msgstr ""
-#~ "Installer un environnement minimal (pas de paquets supplémentaires, "
-#~ "seulement la base) ? (o/N) : "
-
-#~ msgid "ROOT partition : %s (mounting point : %s)"
-#~ msgstr "Partition ROOT : %s (point de montage : %s)"
-
-#~ msgid "Install LightDM ? (y/N) : "
-#~ msgstr "Installer LightDM ? (o/N) : "
-
-#~ msgid "Install LightDM."
-#~ msgstr "Installer LightDM."
-
-#~ msgid ""
-#~ "Choose your installation's language (%s, type 'h' or 'help' to list "
-#~ "supported languages) : "
-#~ msgstr ""
-#~ "Choisissez la langue de votre installation (%s, tapez 'h' ou 'help' pour "
-#~ "obtenir la liste des langues prises en charge) : "
-
-#~ msgid ""
-#~ "Install a desktop environment ? (1: Gnome, 2: KDE Plasma, 3: XFCE, other: "
-#~ "None) : "
-#~ msgstr ""
-#~ "Installer un environnement de bureau ? (1 : Gnome, 2 : KDE Plasma, 3 : "
-#~ "XFCE, autre : Aucun) : "
-
-#~ msgid "Swapfile size ? (Example: 8G, leave empty if none) : "
-#~ msgstr ""
-#~ "Taille du fichier d'échange ? (Exemple : 8G, laissez vide si aucun) : "
```

## archcraftsman/test/test_base.py

```diff
@@ -13,289 +13,306 @@
 #
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 Tests for the base module.
 """
+import io
 import subprocess
-import unittest
-from io import StringIO
-from unittest.mock import patch
-
-from archcraftsman.base import (
-    CYAN,
-    GRAY,
-    GREEN,
-    NOCOLOR,
-    ORANGE,
-    RED,
-    ExecutionResult,
-    elevate,
-    execute,
-    glob_completer,
-    input_str,
-    is_bios,
-    is_root,
-    log,
-    pause,
-    print_error,
-    print_help,
-    print_step,
-    print_sub_step,
-    prompt,
-    prompt_ln,
-    prompt_passwd,
-    sudo_exist,
-)
+import unittest.mock
+
+import archcraftsman.base
 
 
 class TestBase(unittest.TestCase):
     """
     Tests for the base module.
     """
 
-    @patch("glob.glob", return_value=["toto", "tata", "titi"])
-    @patch("os.path.isdir", return_value=False)
+    @unittest.mock.patch("glob.glob", return_value=["toto", "tata", "titi"])
+    @unittest.mock.patch("os.path.isdir", return_value=False)
     def test_glob_completer_first(self, _mock_glob, _mock_isdir):
         """
         Test the glob completer.
         """
-        self.assertEqual(glob_completer("t", 0), "toto")
+        self.assertEqual(archcraftsman.base.glob_completer("t", 0), "toto")
 
-    @patch("glob.glob", return_value=["toto", "tata", "titi"])
-    @patch("os.path.isdir", return_value=False)
+    @unittest.mock.patch("glob.glob", return_value=["toto", "tata", "titi"])
+    @unittest.mock.patch("os.path.isdir", return_value=False)
     def test_glob_completer_second(self, _mock_glob, _mock_isdir):
         """
         Test the glob completer.
         """
-        self.assertEqual(glob_completer("t", 1), "tata")
+        self.assertEqual(archcraftsman.base.glob_completer("t", 1), "tata")
 
-    @patch("glob.glob", return_value=["toto", "tata", "titi"])
-    @patch("os.path.isdir", return_value=False)
+    @unittest.mock.patch("glob.glob", return_value=["toto", "tata", "titi"])
+    @unittest.mock.patch("os.path.isdir", return_value=False)
     def test_glob_completer_third(self, _mock_glob, _mock_isdir):
         """
         Test the glob completer.
         """
-        self.assertEqual(glob_completer("t", 2), "titi")
+        self.assertEqual(archcraftsman.base.glob_completer("t", 2), "titi")
 
-    @patch("os.path.exists", return_value=False)
+    @unittest.mock.patch("os.path.exists", return_value=False)
     def test_is_bios(self, _mock_is_bios):
         """
         Test the is_bios function.
         """
-        self.assertTrue(is_bios())
+        self.assertTrue(archcraftsman.base.is_bios())
 
     def test_execute(self):
         """
         Test the execute function.
         """
-        with patch("subprocess.run") as mock_subprocess_run:
+        with unittest.mock.patch("subprocess.run") as mock_subprocess_run:
             mock_subprocess_run.side_effect = [
                 subprocess.CompletedProcess(args="echo A", returncode=0, stdout=b"A"),
                 subprocess.CompletedProcess(args="echo B", returncode=0, stdout=b"B"),
-                subprocess.CompletedProcess(args="echo C", returncode=0, stdout=b"C"),
+                subprocess.CompletedProcess(
+                    args="arch-chroot /mnt /bin/bash <<END\necho C\nEND",
+                    returncode=0,
+                    stdout=b"C",
+                ),
                 subprocess.CompletedProcess(args="echo D", returncode=0, stdout=b"D"),
+                subprocess.CompletedProcess(args="echo E", returncode=0, stdout=b"E"),
             ]
-            result1 = execute("echo A")
-            result2 = execute("echo B")
+            result1 = archcraftsman.base.execute("echo A")
+            result2 = archcraftsman.base.execute("echo B")
+            result3 = archcraftsman.base.execute("echo C", chroot=True)
             self.assertEqual(result1.command, "echo A")
             self.assertEqual(result1.returncode, 0)
             self.assertEqual(result1.output, "A")
             self.assertTrue(bool(result1))
             self.assertEqual(str(result1), "A")
             self.assertEqual(repr(result1), "A")
             self.assertFalse(result1 == result2)
             self.assertTrue(result1 != result2)
             self.assertEqual(
                 hash(result1),
                 hash(result1.command) ^ hash(result1.returncode) ^ hash(result1.output),
             )
+            self.assertEqual(result3.output, "C")
+            self.assertEqual(result3.returncode, 0)
+            self.assertEqual(
+                result3.command,
+                "arch-chroot /mnt /bin/bash <<END\necho C\nEND",
+            )
             with (
-                patch("sys.stdout", new_callable=StringIO) as mock_stdout,
-                patch("archcraftsman.arguments.test", return_value=True),
+                unittest.mock.patch(
+                    "sys.stdout", new_callable=io.StringIO
+                ) as mock_stdout,
+                unittest.mock.patch("archcraftsman.arguments.test", return_value=True),
             ):
-                execute("echo C")
+                archcraftsman.base.execute("echo D")
                 self.assertTrue(mock_stdout.getvalue())
             with (
-                patch("archcraftsman.base.sudo_exist", return_value=False),
-                patch("archcraftsman.base.is_root", return_value=False),
+                unittest.mock.patch(
+                    "archcraftsman.base.sudo_exist", return_value=False
+                ),
+                unittest.mock.patch("archcraftsman.base.is_root", return_value=False),
             ):
-                self.assertRaises(PermissionError, lambda: execute("echo D", sudo=True))
+                self.assertRaises(
+                    PermissionError,
+                    lambda: archcraftsman.base.execute("echo E", sudo=True),
+                )
             with (
-                patch("archcraftsman.base.sudo_exist", return_value=True),
-                patch("archcraftsman.base.is_root", return_value=False),
+                unittest.mock.patch("archcraftsman.base.sudo_exist", return_value=True),
+                unittest.mock.patch("archcraftsman.base.is_root", return_value=False),
             ):
-                self.assertTrue("sudo" in execute("echo D", sudo=True).command)
+                self.assertTrue(
+                    "sudo" in archcraftsman.base.execute("echo E", sudo=True).command
+                )
 
-    @patch(
+    @unittest.mock.patch(
         "archcraftsman.base.execute",
-        return_value=ExecutionResult(
+        return_value=archcraftsman.base.ExecutionResult(
             "whoami",
             subprocess.CompletedProcess(args="whoami", returncode=0, stdout=b"root"),
         ),
     )
     def test_is_root(self, _mock_is_root):
         """
         Test the is_root function.
         """
-        self.assertTrue(is_root())
+        self.assertTrue(archcraftsman.base.is_root())
 
-    @patch(
+    @unittest.mock.patch(
         "archcraftsman.base.execute",
-        return_value=ExecutionResult(
+        return_value=archcraftsman.base.ExecutionResult(
             "which sudo",
             subprocess.CompletedProcess(
                 args="which sudo", returncode=0, stdout=b"/usr/bin/sudo"
             ),
         ),
     )
     def tests_sudo_exist(self, _mock_sudo_exist):
         """
         Test the sudo_exist function.
         """
-        self.assertTrue(sudo_exist())
+        self.assertTrue(archcraftsman.base.sudo_exist())
 
-    @patch("archcraftsman.base.execute")
+    @unittest.mock.patch("archcraftsman.base.execute")
     def test_evelate(self, _mock_execute):
         """
         Test the elevate function.
         """
-        with patch("archcraftsman.base.is_root", return_value=True):
-            self.assertTrue(elevate())
-        with patch("archcraftsman.base.sudo_exist", return_value=True):
-            self.assertTrue(elevate())
+        with unittest.mock.patch("archcraftsman.base.is_root", return_value=True):
+            self.assertTrue(archcraftsman.base.elevate())
+        with unittest.mock.patch("archcraftsman.base.sudo_exist", return_value=True):
+            self.assertTrue(archcraftsman.base.elevate())
         with (
-            patch("archcraftsman.base.is_root", return_value=False),
-            patch("archcraftsman.base.sudo_exist", return_value=False),
+            unittest.mock.patch("archcraftsman.base.is_root", return_value=False),
+            unittest.mock.patch("archcraftsman.base.sudo_exist", return_value=False),
         ):
-            self.assertFalse(elevate())
+            self.assertFalse(archcraftsman.base.elevate())
 
-    @patch("archcraftsman.base.execute")
+    @unittest.mock.patch("archcraftsman.base.execute")
     def test_pause(
         self,
         _mock_execute,
     ):
         """
         Test the pause function.
         """
-        with patch("sys.stdout", new_callable=StringIO) as mock_stdout:
-            pause()
+        with unittest.mock.patch("sys.stdout", new_callable=io.StringIO) as mock_stdout:
+            archcraftsman.base.pause()
             self.assertEqual(
                 mock_stdout.getvalue(),
-                f"{ORANGE}Press any key to continue...{NOCOLOR}\n",
+                f"{archcraftsman.base.ORANGE}Press any key to continue...{archcraftsman.base.NOCOLOR}\n",
             )
 
-        with patch("sys.stdout", new_callable=StringIO) as mock_stdout:
-            pause(start_newline=True)
+        with unittest.mock.patch("sys.stdout", new_callable=io.StringIO) as mock_stdout:
+            archcraftsman.base.pause(start_newline=True)
             self.assertEqual(
                 mock_stdout.getvalue(),
-                f"\n{ORANGE}Press any key to continue...{NOCOLOR}\n",
+                f"\n{archcraftsman.base.ORANGE}Press any key to continue...{archcraftsman.base.NOCOLOR}\n",
             )
 
-        with patch("sys.stdout", new_callable=StringIO) as mock_stdout:
-            pause(end_newline=True)
+        with unittest.mock.patch("sys.stdout", new_callable=io.StringIO) as mock_stdout:
+            archcraftsman.base.pause(end_newline=True)
             self.assertEqual(
                 mock_stdout.getvalue(),
-                f"{ORANGE}Press any key to continue...{NOCOLOR}\n\n",
+                f"{archcraftsman.base.ORANGE}Press any key to continue...{archcraftsman.base.NOCOLOR}\n\n",
             )
 
-    @patch("archcraftsman.base.pause")
+    @unittest.mock.patch("archcraftsman.base.pause")
     def test_print_error(self, _mock_pause):
         """
         Test the print_error function.
         """
-        with patch("sys.stdout", new_callable=StringIO) as mock_stdout:
-            print_error("Error")
+        with unittest.mock.patch("sys.stdout", new_callable=io.StringIO) as mock_stdout:
+            archcraftsman.base.print_error("Error")
             self.assertEqual(
                 mock_stdout.getvalue(),
-                f"\n{RED}  /!\\ Error{NOCOLOR}\n\n",
+                f"\n{archcraftsman.base.RED}  /!\\ Error{archcraftsman.base.NOCOLOR}\n\n",
             )
 
-    @patch("archcraftsman.base.execute")
+    @unittest.mock.patch("archcraftsman.base.execute")
     def test_print_step(self, _mock_execute):
         """
         Test the print_step function.
         """
-        with patch("sys.stdout", new_callable=StringIO) as mock_stdout:
-            print_step("Step")
+        with unittest.mock.patch("sys.stdout", new_callable=io.StringIO) as mock_stdout:
+            archcraftsman.base.print_step("Step")
             self.assertEqual(
                 mock_stdout.getvalue(),
-                f"\n{GREEN}Step{NOCOLOR}\n",
+                f"\n{archcraftsman.base.GREEN}Step{archcraftsman.base.NOCOLOR}\n",
             )
 
-    @patch("archcraftsman.base.execute")
+    @unittest.mock.patch("archcraftsman.base.execute")
     def test_print_sub_step(self, _mock_execute):
         """
         Test the print_sub_step function.
         """
-        with patch("sys.stdout", new_callable=StringIO) as mock_stdout:
-            print_sub_step("Sub step")
+        with unittest.mock.patch("sys.stdout", new_callable=io.StringIO) as mock_stdout:
+            archcraftsman.base.print_sub_step("Sub step")
             self.assertEqual(
                 mock_stdout.getvalue(),
-                f"{CYAN}  * Sub step{NOCOLOR}\n",
+                f"{archcraftsman.base.CYAN}  * Sub step{archcraftsman.base.NOCOLOR}\n",
             )
 
-    @patch("archcraftsman.arguments.test", return_value=True)
+    @unittest.mock.patch("archcraftsman.arguments.test", return_value=True)
     def test_log(self, _mock_test):
         """
         Test the log function.
         """
-        with patch("sys.stdout", new_callable=StringIO) as mock_stdout:
-            log("Log")
-            self.assertEqual(mock_stdout.getvalue(), f"{GRAY}> Log{NOCOLOR}\n")
+        with unittest.mock.patch("sys.stdout", new_callable=io.StringIO) as mock_stdout:
+            archcraftsman.base.log("Log")
+            self.assertEqual(
+                mock_stdout.getvalue(),
+                f"{archcraftsman.base.GRAY}> Log{archcraftsman.base.NOCOLOR}\n",
+            )
 
-    @patch("archcraftsman.base.pause")
+    @unittest.mock.patch("archcraftsman.base.pause")
     def test_print_help(self, _mock_pause):
         """
         Test the print_help function.
         """
-        with patch("sys.stdout", new_callable=StringIO) as mock_stdout:
-            print_help("Test message", do_pause=True)
+        with unittest.mock.patch("sys.stdout", new_callable=io.StringIO) as mock_stdout:
+            archcraftsman.base.print_help("Test message", do_pause=True)
             self.assertEqual(
                 mock_stdout.getvalue(),
-                f"\n{GREEN}Help :{NOCOLOR}\n{CYAN}  * Test message{NOCOLOR}\n",
+                f"\n{archcraftsman.base.GREEN}Help :{archcraftsman.base.NOCOLOR}\n{archcraftsman.base.CYAN}  "
+                f"* Test message{archcraftsman.base.NOCOLOR}\n",
             )
 
     def test_input_str(self):
         """
         Test the input_str function.
         """
-        with patch("archcraftsman.base.input", return_value="toto"):
-            self.assertEqual(input_str("Enter:"), "toto")
-        with patch("archcraftsman.base.getpass.getpass", return_value="titi"):
-            self.assertEqual(input_str("Enter:", password=True), "titi")
+        with unittest.mock.patch("archcraftsman.base.input", return_value="toto"):
+            self.assertEqual(archcraftsman.base.input_str("Enter:"), "toto")
+        with unittest.mock.patch(
+            "archcraftsman.base.getpass.getpass", return_value="titi"
+        ):
+            self.assertEqual(
+                archcraftsman.base.input_str("Enter:", password=True), "titi"
+            )
 
-    @patch("sys.stdout", new_callable=StringIO)
-    @patch("archcraftsman.base.pause")
+    @unittest.mock.patch("sys.stdout", new_callable=io.StringIO)
+    @unittest.mock.patch("archcraftsman.base.pause")
     def test_prompt(self, _mock_pause, _mock_stdout):
         """
         Test the prompt function.
         """
-        with patch("archcraftsman.base.input_str") as mock_input:
+        with unittest.mock.patch("archcraftsman.base.input_str") as mock_input:
             mock_input.return_value = "Titi"
-            self.assertEqual(prompt("Enter:", default="Toto", help_msg="Help"), "Titi")
-        with patch("archcraftsman.base.input_str") as mock_input:
+            self.assertEqual(
+                archcraftsman.base.prompt("Enter:", default="Toto", help_msg="Help"),
+                "Titi",
+            )
+        with unittest.mock.patch("archcraftsman.base.input_str") as mock_input:
             mock_input.return_value = ""
-            self.assertEqual(prompt("Enter:", default="Toto", help_msg="Help"), "Toto")
-        with patch("archcraftsman.base.input_str") as mock_input:
+            self.assertEqual(
+                archcraftsman.base.prompt("Enter:", default="Toto", help_msg="Help"),
+                "Toto",
+            )
+        with unittest.mock.patch("archcraftsman.base.input_str") as mock_input:
             mock_input.side_effect = ["?", ""]
-            self.assertEqual(prompt("Enter:", default="Toto", help_msg="Help"), "Toto")
-        with patch("archcraftsman.base.input_str") as mock_input:
+            self.assertEqual(
+                archcraftsman.base.prompt("Enter:", default="Toto", help_msg="Help"),
+                "Toto",
+            )
+        with unittest.mock.patch("archcraftsman.base.input_str") as mock_input:
             mock_input.side_effect = ["", "Tata"]
-            self.assertEqual(prompt("Enter:", help_msg="Help", required=True), "Tata")
+            self.assertEqual(
+                archcraftsman.base.prompt("Enter:", help_msg="Help", required=True),
+                "Tata",
+            )
 
     def test_prompt_ln(self):
         """
         Test the prompt_ln function.
         """
-        with patch("archcraftsman.base.prompt", return_value="Titi"):
+        with unittest.mock.patch("archcraftsman.base.prompt", return_value="Titi"):
             self.assertEqual(
-                prompt_ln("Enter:", default="Toto", help_msg="Help"), "Titi"
+                archcraftsman.base.prompt_ln("Enter:", default="Toto", help_msg="Help"),
+                "Titi",
             )
 
     def test_prompt_password(self):
         """
         Test the prompt_password function.
         """
-        with patch("archcraftsman.base.prompt", return_value="Titi"):
-            self.assertEqual(prompt_passwd("Enter:"), "Titi")
+        with unittest.mock.patch("archcraftsman.base.prompt", return_value="Titi"):
+            self.assertEqual(archcraftsman.base.prompt_passwd("Enter:"), "Titi")
```

## archcraftsman/test/test_utils.py

```diff
@@ -14,75 +14,79 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 Test the utils module.
 """
 import unittest
-from unittest.mock import patch
+import unittest.mock
 
-from archcraftsman.options import Languages
-from archcraftsman.utils import from_iec, generate_translations, print_supported, to_iec
+import archcraftsman.options
+import archcraftsman.utils
 
 
 class TestUtils(unittest.TestCase):
     """
     Test the utils module.
     """
 
     def test_generate_translations(self):
         """
         Test the generate_translations function.
         """
-        with patch("archcraftsman.utils.execute") as mock_execute:
-            generate_translations(Languages.FRENCH)
+        with unittest.mock.patch("archcraftsman.base.execute") as mock_execute:
+            archcraftsman.utils.generate_translations(
+                archcraftsman.options.Languages.FRENCH
+            )
             mock_execute.assert_called()
 
     def test_generate_translations_with_invalid_language(self):
         """
         Test the generate_translations function with an invalid language.
         """
-        with patch("archcraftsman.utils.execute") as mock_execute:
-            generate_translations("invalid")
+        with unittest.mock.patch("archcraftsman.base.execute") as mock_execute:
+            archcraftsman.utils.generate_translations("invalid")
             mock_execute.assert_not_called()
 
     def test_to_iec(self):
         """
         Test the to_iec function.
         """
-        self.assertEqual(to_iec(10240), "10K")
+        self.assertEqual(archcraftsman.utils.to_iec(10240), "10K")
 
     def test_to_iec_with_negative_value(self):
         """
         Test the to_iec function with a negative value.
         """
-        self.assertEqual(to_iec(-1), "")
+        self.assertEqual(archcraftsman.utils.to_iec(-1), "")
 
     def test_from_iec(self):
         """
         Test the from_iec function.
         """
-        self.assertEqual(from_iec("1K"), 1024)
+        self.assertEqual(archcraftsman.utils.from_iec("1K"), 1024)
 
     def test_from_iec_with_invalid_value(self):
         """
         Test the from_iec function with an invalid value.
         """
-        self.assertEqual(from_iec("invalid"), 0)
+        self.assertEqual(archcraftsman.utils.from_iec("invalid"), 0)
 
     def test_from_iec_with_negative_value(self):
         """
         Test the from_iec function with a negative value.
         """
-        self.assertEqual(from_iec("-1K"), 0)
+        self.assertEqual(archcraftsman.utils.from_iec("-1K"), 0)
 
     def test_print_supported(self):
         """
         Test the print_supported function.
         """
         with (
-            patch("archcraftsman.utils.print_step") as mock_print_step,
-            patch("archcraftsman.utils.print_sub_step") as mock_print_sub_step,
+            unittest.mock.patch("archcraftsman.base.print_step") as mock_print_step,
+            unittest.mock.patch(
+                "archcraftsman.base.print_sub_step"
+            ) as mock_print_sub_step,
         ):
-            print_supported("test", ["test1", "test2"], "test1")
+            archcraftsman.utils.print_supported("test", ["test1", "test2"], "test1")
             mock_print_step.assert_called()
             mock_print_sub_step.assert_called()
```

## Comparing `archcraftsman-4.0.1.dist-info/LICENSE.txt` & `archcraftsman-4.1.0.dist-info/LICENSE.txt`

 * *Files identical despite different names*

## Comparing `archcraftsman-4.0.1.dist-info/METADATA` & `archcraftsman-4.1.0.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: archcraftsman
-Version: 4.0.1
+Version: 4.1.0
 Summary: The careful yet very fast Arch Linux Craftsman ensuring minimal user interactions.
 Home-page: https://github.com/Rawleenc/ArchCraftsman
 Author: Rawleenc
 License: GPL-3.0
 Project-URL: Bug Tracker, https://github.com/Rawleenc/ArchCraftsman/issues
 Keywords: linux,fast,installer,script,archlinux,quickstart,archcraftsman
 Classifier: Programming Language :: Python :: 3.10
```

## Comparing `archcraftsman-4.0.1.dist-info/NOTICES` & `archcraftsman-4.1.0.dist-info/NOTICES`

 * *Files identical despite different names*

## Comparing `archcraftsman-4.0.1.dist-info/RECORD` & `archcraftsman-4.1.0.dist-info/RECORD`

 * *Files 14% similar despite different names*

```diff
@@ -1,64 +1,63 @@
 archcraftsman/__init__.py,sha256=5ep5_AjU9ewXaak2P7VgAxiYKn3coX2Zc3Tn9k6Qx-E,732
-archcraftsman/__main__.py,sha256=c1gTlf2A2vV5kqYk6kCKOQXEQgOovd9fZ6N0X6qX55o,828
-archcraftsman/arguments.py,sha256=7K-86jh4qxy1DowBmp2U79fIt33clbWzzWl7d3TBx3U,1904
-archcraftsman/autopart.py,sha256=CHBurAWJ6QsXizrs12ZnPhxkuNPfdbLp_qluz2p8uOM,11383
-archcraftsman/base.py,sha256=BKvA8MeonG0JYSZ-mi9Tm2qZLwl88G3XXtFI9IEokj0,6720
-archcraftsman/basesetup.py,sha256=9RES73P71OCT6rm2VBMUuFyc37Jbx3u8ogcZi8j69ho,12635
-archcraftsman/config.py,sha256=oWEPOjai92Pasa_nruf5wBebf-dK1KOTTBQUDkIbUuY,5314
-archcraftsman/disk.py,sha256=o7Agvf7EZfym-waxtmBVTrG5ZjYxZ5V-_m62DiFBRQI,4444
-archcraftsman/i18n.py,sha256=6dRcuu7dxpjck3kC1Ek9-5PrHho0zIaRTtSMd4g_frs,1449
-archcraftsman/info.py,sha256=y2IxUda9Rk_k47OguRpVNgdaUuils8Vwz6ZYtW9Kjjs,1281
-archcraftsman/installer.py,sha256=s1sPUmpUE3zi7AhcszQJszVMjrevZ-zi7eZv5XC6iAo,11235
-archcraftsman/manualpart.py,sha256=p0PljqJ9jNDYSBfI2To1DmdbLTGNo4sSTJUsdLNk7q4,7320
-archcraftsman/options.py,sha256=wqtNBMb21BzZZIvV0r4Dch-LaAyeHZzbG4wUpf-LaG4,3984
-archcraftsman/packages.py,sha256=qKrK3c9oBbt7AeUGIRFCf97rUwhO5vja6Ql8i7fgjBs,3335
-archcraftsman/partition.py,sha256=asqmYBh6ah2YCiR81o4vLTbDIeYIrwMaeR9LufhORsU,10496
-archcraftsman/partitioninginfo.py,sha256=pAhAwa8Wsyfc2Uj6ItYA6-SC4ueGdU5eoaWbBFOv_Gk,4299
-archcraftsman/prelaunchinfo.py,sha256=YKTb_FVfqSAI9aC4xVw2OmkBSN43mF-VWnglRoNPQA4,3638
-archcraftsman/shell.py,sha256=hEVRM861ZhvgTU3BbrTJGEKu_pPcNbs_mZOU7MNzSvI,6180
-archcraftsman/systeminfo.py,sha256=hfbqew28lpAe-T60YH5aZ2TdWk1imYuTNfSb6xb0wtQ,3116
-archcraftsman/utils.py,sha256=Tnc-FnVBm7DHTKRqUyT4U9KGPJLjrwOOd0cxufOiJeo,8407
+archcraftsman/__main__.py,sha256=tnaO-bdz9D3_-gY5QcK2LWJjdpJdDa4nYSxw3rjiLsY,837
+archcraftsman/arguments.py,sha256=wtNbpyCnGMb93WjhbDakC8lxQ2dlAOnmpxqM5r7JjsQ,1900
+archcraftsman/autopart.py,sha256=5sMBeAtBS6vtuunG3GmuU6n5A-P-Ednx7YFYqdLYVRg,13374
+archcraftsman/base.py,sha256=pi4jdF24ZrfbAVQ4hxG2uqoJXPrQxf1rgjp7vxS0Vgo,6964
+archcraftsman/basesetup.py,sha256=uANqvDo6_Ga_DJyqmCKqG_j9JMSyqQsXBQBmoQlDKek,13886
+archcraftsman/config.py,sha256=aJLQOXrDoh6hEVhqXWRY_yBK2UcSgtGsZByW9N7xl3g,5917
+archcraftsman/disk.py,sha256=3nTrHYrsJNf1JG6plpBBOX7jR0-l5_KkiCDLNvhK9Rg,4772
+archcraftsman/i18n.py,sha256=lgTalwP3g3n7RM12vbn2AGPrhu2CbLaztBnZrZiqVwo,1464
+archcraftsman/imessages.py,sha256=24cA6A_sJbZ-I3_5CzHHvPEtz29Odjn2m34OsyQnUJg,1415
+archcraftsman/info.py,sha256=sta6Bc4rW-p26kTZZhvpcDYx0wvAj9Q3rUoQrn9_65c,1464
+archcraftsman/installer.py,sha256=4pbcIfooMkhq7tU5OY5jRGSOcCBbftCn6TzBg7CkkpQ,13327
+archcraftsman/manualpart.py,sha256=fkTVIZq3r-gRI03CZRQ_NOlRe1MK7FOcoTDvSDzBP8Q,9011
+archcraftsman/options.py,sha256=UklrVi7Ux7WSdyR-gC5VYBACImacfcPDtG5s_XaBk7k,4178
+archcraftsman/packages.py,sha256=QGMMbJO8BtXUvaVpRCiZfW9w1dTE3TInemu-80dReag,3458
+archcraftsman/partition.py,sha256=EVLuSXWWI0ln81wonLiZigsCvksJPsKfx_e1vbaQQB0,11555
+archcraftsman/partitioninginfo.py,sha256=LmmWLJY9UMTUnrtxQItsg30IZGjRWKMBGlzwa3kd7hg,4573
+archcraftsman/prelaunchinfo.py,sha256=bv_F9ugzYnYSJOFf1oEYo7qBe5arT2EM9jLEB-7vpG0,3953
+archcraftsman/shell.py,sha256=TDzpfnwEF0J6_nodWT0C0hZONAvBzZghoDcumk_uAMw,7108
+archcraftsman/systeminfo.py,sha256=w2_3nIYw7rj6KxQlNxFcPrSKdyt6AHSMm1Ws-zB76R4,3607
+archcraftsman/utils.py,sha256=whKsLW03Sn-bJMDFcEGAB6OKoL-rLY4YQWC7ptKlbGA,9030
 archcraftsman/bundles/__init__.py,sha256=5ep5_AjU9ewXaak2P7VgAxiYKn3coX2Zc3Tn9k6Qx-E,732
-archcraftsman/bundles/budgie.py,sha256=QwBgW3A2oDEwQQFVJ1eV18MM5PgXaJ28t9QLr5Qyy9M,2342
-archcraftsman/bundles/bundle.py,sha256=i-KG_1qL6WytbtqKbqvNnHaHoQqQmRTOlQrGPK9dKzA,1424
-archcraftsman/bundles/cinnamon.py,sha256=yraMYdRnO3Td700f-1vYda2PBsMMPcSPk3wwWsNqHCc,2491
-archcraftsman/bundles/copyacm.py,sha256=GlH9iCNvCieC8mikUC0xyMFV3FxA3egjhXmhsD9MSeo,1701
-archcraftsman/bundles/cups.py,sha256=_jj9WGTDgkAYcdEWYQIttgFkXkqjYnKTV3oKocWXN-M,1653
-archcraftsman/bundles/cutefish.py,sha256=eMCFQh1S9ucnhP56RyoAsk-OOPU_Wx1eklzIujz9hxc,2013
-archcraftsman/bundles/deepin.py,sha256=cpgSp5stwrPmDocUnZ4PMJiBKS69fjNUKw9VUMs-s04,2250
-archcraftsman/bundles/enlightenment.py,sha256=lyv7dIq9REta8bE_qoZVP8XtY9gVu_4MYq8ezIT4_QI,1684
-archcraftsman/bundles/generateconfig.py,sha256=7XLiNff29chYSKAvCrJ3mIjQjfjOWMlSz8RUubyP_8w,1066
-archcraftsman/bundles/gnome.py,sha256=FMmAmFmvqJD1PlgN_ofdqahrnpSJ_CxKmZWEMXX4t2o,2020
-archcraftsman/bundles/grmlzsh.py,sha256=oBgGJYZaLmQlOhWIp7GSakafJcL1iVgLQnpyTBL36y0,1415
-archcraftsman/bundles/grub.py,sha256=TqVX04GkVIKPUWTmqLVqyRZUdEvZKFhqP3nAZm63jU0,4149
-archcraftsman/bundles/i3.py,sha256=fSO8Y21Dvx0UrFU8kdBsddjh5dSXPAwky2YlRpNpGH8,1758
-archcraftsman/bundles/iwd.py,sha256=DsO6-d4AFdKDwuj0vV7xQpqPOBcHseiNXDagkTbwYEU,1380
-archcraftsman/bundles/linux.py,sha256=jMwlWUx89JeaHWZDgU7ZrYrtffGJIjO9Q9N1HtS_L4o,1985
-archcraftsman/bundles/lxqt.py,sha256=6ZDT1dypATMXqS-zneUqLcHQSC75uZNeyDm2maUMSVg,2271
-archcraftsman/bundles/mainfilesystems.py,sha256=atOPGk2hhGn99feYEp9AQROH_O78czrpSFQ6UybRhfs,1543
-archcraftsman/bundles/mainfonts.py,sha256=kCch3KLDkYJMbsyb7yeudz_ctNo2ZznbI_OeZOjIqkE,1826
-archcraftsman/bundles/mate.py,sha256=RdeLuJtJV2OwuDl8o-blAZvpvcHDGxIu11SOyQ1BImE,2728
-archcraftsman/bundles/microcodes.py,sha256=n91KKEFLZPYUU3J40wXGeyAq7h8sjNO57aoRQ2fxoU4,2126
-archcraftsman/bundles/networkmanager.py,sha256=F5-YbBa6la1zkvBqP6vyjZ7QziDIYE5_E18idzgdF2k,1661
-archcraftsman/bundles/nvidia.py,sha256=fkaD4CXe5JR9fcdSo4Tyis84tNH433vHxVsuXdN8D4E,1381
-archcraftsman/bundles/pipewire.py,sha256=hSNAvc-4lJCrga2LsPeV6RfP44q1NfQFUtgDUwMM1xA,1377
-archcraftsman/bundles/plasma.py,sha256=BVhwWld-5t3ui32isp1jlG01sYms5yYBcC3CCwNnivM,2807
-archcraftsman/bundles/sway.py,sha256=8AklWCMclesFc74vA910onRiNCRRR77IBNIgCfDSb0s,2332
-archcraftsman/bundles/systemdnet.py,sha256=gV5xxxWZhKQvX_1zy_Dktflpj1ZSP8dEgc4rNoaBVYA,1482
-archcraftsman/bundles/terminus.py,sha256=ssZqBmT78AaDpv7m0swLPrCqDYYdkfXFW9-bpNgIpak,1341
-archcraftsman/bundles/utils.py,sha256=doeNJxnIdqAYbBy7JmXzXwfObLZG0tQBWwYeblgYTfU,5493
-archcraftsman/bundles/xfce.py,sha256=Dxcx2_-2DCpNZWlTgLfVI7rMZIzAwczlcECqgcz7byo,2700
-archcraftsman/bundles/yay.py,sha256=58tS7xNWYnVdPply2e3aWZDR31JK-2corLBV9816nTY,1427
-archcraftsman/bundles/zram.py,sha256=hJk5gCcRoV_QGX2H64t06pGB_HPeDZ_VyaYFmHJC-LM,1484
+archcraftsman/bundles/budgie.py,sha256=y8CRbTBFTexBP5qH7Uzj2_HDF-2gexIVtEtU7vJArNY,2538
+archcraftsman/bundles/bundle.py,sha256=A1rXVFItdGoyxYFHmCalZ6VTzDtr8MRFNtFUmzE8Th8,1663
+archcraftsman/bundles/cinnamon.py,sha256=41l3rWi88wiToTtQrQktunNdSgIVZVscJkx6CsVZc84,2708
+archcraftsman/bundles/copyacm.py,sha256=PmAl5L0zcCIFktN_ysAUmZbHnyOe_mSSAP3ZRc_EFpE,1959
+archcraftsman/bundles/cutefish.py,sha256=L5ozrtC1FZl0GStnpLcArDY5uKOFZ6o2V8U5FCGm_c4,2211
+archcraftsman/bundles/deepin.py,sha256=zoltTEKpM2eHEFGyifxeEcm1oMBVbki9nrd5M97G-Ig,2484
+archcraftsman/bundles/enlightenment.py,sha256=HHXm3itJBfHEGu6tQF4Vc53vFLabLrncHxEAIFbDey4,1876
+archcraftsman/bundles/generateconfig.py,sha256=tPDTUyPFifd0t9gFADSxxq6eCVTjxO4heSXFdn1oGNA,1240
+archcraftsman/bundles/genericbundle.py,sha256=_Df6sNxvLl8vux9nu_cvP89tKYkbYzSzhtFm0IeBrw4,2695
+archcraftsman/bundles/gnome.py,sha256=zis9_0eXuWJxZW0Qhwtl3UGifVXKNtraBqszcvvLMoA,2250
+archcraftsman/bundles/grmlzsh.py,sha256=-aHXvHU8mBRd7D2MobvWpuMFISV3eZ7w9l5pYcnXs70,1668
+archcraftsman/bundles/grub.py,sha256=Q_92FNCAh-kxKlHIHOKox-KJw9enwtvOui44VMsEHbc,4552
+archcraftsman/bundles/i3.py,sha256=JvmGdJ2C25jiiXco1_BdxBl19S2cydN7D7ZhebtcUDk,1939
+archcraftsman/bundles/iwd.py,sha256=k6acZ02va3zstZ75uLeeRGgRn8IufZKx52t8FtqclNQ,1560
+archcraftsman/bundles/linux.py,sha256=ufl2b3GxE6_IQ9Uo2nBVvxntwWMsh24VbG2SMuHtPcw,2488
+archcraftsman/bundles/lxqt.py,sha256=4n4pL4LaGuckPVEYIuWXmJd-PnG01gJpjuehJ6ulGb0,2465
+archcraftsman/bundles/mate.py,sha256=Sh6G9kyiGAeoANtHh9HBEGN4W6rjiHmJpE-K1e48_MM,2989
+archcraftsman/bundles/microcodes.py,sha256=X7Xl0dgv46rt5CWouzYi8z088ubX9VzAohTWD287Jm8,2268
+archcraftsman/bundles/networkmanager.py,sha256=B8-6ZLbH3F-3RcihTYO6Q07RtMliTOvVYMiYIBp3sfY,1946
+archcraftsman/bundles/nvidia.py,sha256=NRpdcqHeAU9FGvE52TS9L5vxClJibE8iEvFOpopfnhU,1556
+archcraftsman/bundles/plasma.py,sha256=I4HVzdPHupb5Wz5wmd4v0CP8yi-FRQc844HgOdAYYtM,3180
+archcraftsman/bundles/sway.py,sha256=TOW-34QdHVfTnxEtdGorqOnQHe5nVZ0KPmOguxftEDU,2578
+archcraftsman/bundles/systemdnet.py,sha256=JFf4tVATPEjHJ31IqaZYzExez0vxRUiBM8eb0l8geJk,1704
+archcraftsman/bundles/terminus.py,sha256=B2RPVrtwKESKK1aCa0fchBJJy4VgMMd1QoruC6nWAAc,1522
+archcraftsman/bundles/utils.py,sha256=RdLgBkSsLJlLqYo5sYUceyiw3t7O0mStVwXfLE3m6m0,3191
+archcraftsman/bundles/xfce.py,sha256=wZE3KZSLUexWiX61F-p32BakBJxee9hQfJraPLHgDPI,2961
+archcraftsman/bundles/yay.py,sha256=SmXBCCH39IOCvaMUs0JFIF2CAlyx_WbfPoNmSKrWxiw,1664
+archcraftsman/bundles/zram.py,sha256=x1a2G2bovLPOaKwpBhvX_pj6Sxl4AmxRVJIbDkIuxoI,1656
+archcraftsman/bundles/configs/__init__.py,sha256=5ep5_AjU9ewXaak2P7VgAxiYKn3coX2Zc3Tn9k6Qx-E,732
 archcraftsman/locales/__init__.py,sha256=5ep5_AjU9ewXaak2P7VgAxiYKn3coX2Zc3Tn9k6Qx-E,732
-archcraftsman/locales/french.po,sha256=rxk_lhi5-lMGyr0FO61NxC3dZfCkHGPxws7-zoZuKW8,29220
+archcraftsman/locales/french.po,sha256=QBF6LRTPzqJfYVY0DWRCGfqO3tMx8frouWTNwE8Zk84,24293
 archcraftsman/test/__init__.py,sha256=5ep5_AjU9ewXaak2P7VgAxiYKn3coX2Zc3Tn9k6Qx-E,732
-archcraftsman/test/test_base.py,sha256=UkSQSHnHlHhfB9l4ujmiucjaXJC2IfhkVkqwKy87kUI,10466
-archcraftsman/test/test_utils.py,sha256=OdTalMW5HdFsx8UIr5N1kJU2CQmObACpiJMpOWobpHk,2858
-archcraftsman-4.0.1.dist-info/LICENSE.txt,sha256=OXLcl0T2SZ8Pmy2_dmlvKuetivmyPd5m1q-Gyd-zaYY,35149
-archcraftsman-4.0.1.dist-info/METADATA,sha256=5mmWyCkOe4kQWwBGr3Ctif82NNLTuFaadnr4IdaUVzI,10484
-archcraftsman-4.0.1.dist-info/NOTICES,sha256=dh7GS8sAUlwVN5rx9yzBYNKqtd-u_G-8VJsoVJn4CKY,704
-archcraftsman-4.0.1.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-archcraftsman-4.0.1.dist-info/entry_points.txt,sha256=DMRX0bSeIHU5fLAcml9jf2BGwO7IfzFYOa52zDAAlac,63
-archcraftsman-4.0.1.dist-info/top_level.txt,sha256=rI1QWoDRjsPsuYEgU7TEyglkfmoRuMKiHD4AU1hn4zg,14
-archcraftsman-4.0.1.dist-info/RECORD,,
+archcraftsman/test/test_base.py,sha256=0hUfs0s9FLibDFt5DvNo1jz0W0XfeJvhscbAhWxbFK8,12720
+archcraftsman/test/test_utils.py,sha256=EMsC7thDpqTq3iDrHl0kXWO3PGhyeuNoHbJWInTyqMY,3064
+archcraftsman-4.1.0.dist-info/LICENSE.txt,sha256=OXLcl0T2SZ8Pmy2_dmlvKuetivmyPd5m1q-Gyd-zaYY,35149
+archcraftsman-4.1.0.dist-info/METADATA,sha256=YtnlKOm9fnMF9ox6CfZ83a0YPFwJfsVpWhRXEr0G4sY,10484
+archcraftsman-4.1.0.dist-info/NOTICES,sha256=dh7GS8sAUlwVN5rx9yzBYNKqtd-u_G-8VJsoVJn4CKY,704
+archcraftsman-4.1.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+archcraftsman-4.1.0.dist-info/entry_points.txt,sha256=DMRX0bSeIHU5fLAcml9jf2BGwO7IfzFYOa52zDAAlac,63
+archcraftsman-4.1.0.dist-info/top_level.txt,sha256=rI1QWoDRjsPsuYEgU7TEyglkfmoRuMKiHD4AU1hn4zg,14
+archcraftsman-4.1.0.dist-info/RECORD,,
```

